<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GIS on 暗网探秘</title>
    <link>https://anwangtanmi.github.io/categories/gis/</link>
    <description>Recent content in GIS on 暗网探秘</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 05 Dec 2018 08:22:31 +0800</lastBuildDate>
    <atom:link href="https://anwangtanmi.github.io/categories/gis/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>利用遥感影像阴影建筑物高度计算</title>
      <link>https://anwangtanmi.github.io/posts/1ab0d4ff8c84306547fcb7aadaeb2a4c/</link>
      <pubDate>Wed, 05 Dec 2018 08:22:31 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/1ab0d4ff8c84306547fcb7aadaeb2a4c/</guid>
      <description> 遥感影像阴影指因倾斜照射，地物自身遮挡能源而造成影像上的暗色调，它反映了地物的空间结构特征，阴影不仅增强立体感，而且它的形状和轮廓还显示了地物的高度和侧面形状，有助于地物的识别。&#xA;遥感影像阴影，可根据侧影的长度和照射角度，推算出地物的高度；当然阴影也会拖盖一些信息,给解译工作带来麻烦。所以出发的目的不同，评判就不一。&#xA;提取精度：83%以上(验证三处)&#xA;先上图，为提取效果：&#xA;具体方法及步骤： 首先进行阴影提取，然后计算太阳方位角方向的阴影边长，根据三角函数相关公式计算得到建筑物高度，通过分析太阳和卫星天顶角存在a，b两种情况：&#xA;数据来源：遥感集市样例数据，下载方法参照：https://mp.csdn.net/postedit/81124974&#xA;数据获取时间：2014-09-27 11:04:41(仅作为练习操作使用)&#xA;具体步骤：&#xA;步骤一：对原始数据进行预处理，包括辐射定标、正射校正、大气校正和影像融合。&#xA;步骤二：进行ROI选择，平均光谱角分类(具体参照：https://blog.csdn.net/qq_33356563/article/details/84578113)。&#xA;步骤三：分类后处理—小斑点处理(Majority和Minority分析 )。&#xA;步骤四：栅格转矢量。&#xA;步骤五：剔除异常矢量值(根据面积大小)。&#xA;步骤六：阴影长度计算（Python+GDAL）&#xA;步骤七：ArcGIS中进行字段计算器计算值(注意：角度与弧度的转换)&#xA;计算公式：&#xA;精度粗略估计：&#xA;街景地图验证：&#xA;说明：主旨在于参考论文思路的实现，精度不高的原因自我分析主要在于：1.阴影边缘的处理；2.阴影长度的提取。 </description>
    </item>
    <item>
      <title>使用ArcGIS由DEM创建明暗等高线</title>
      <link>https://anwangtanmi.github.io/posts/298ca7ded4ff764fa8a4a8d6f36a35d3/</link>
      <pubDate>Mon, 08 Oct 2018 16:53:48 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/298ca7ded4ff764fa8a4a8d6f36a35d3/</guid>
      <description>1895年，波乌林（J. Pauling）提出明暗等高线法，又称波乌林法。明暗等高线在等高线中加入光照因素，使等高线具有较强的立体感，得到了较广泛的使用。普通等高线立体感不强、不便于初学者使用，地貌晕渲法难以定量表示地形起伏程度，明暗等高线法较好的弥补了以上的不足。&#xA;ArcGIS实现由DEM创建明暗等高线&#xA;实现思路：&#xA;由DEM生成等值线（等高线） 等值线转为栅格要素（栅格才可以直接参与运算） 栅格等值线重分类为一类，值为1 由DEM生成坡向（各个方向以角度表示） 使用栅格计算器将坡向与等高线相乘（带有坡向信息的等高线） 重分类，按照坡向为两大类：0，1 具体步骤：&#xA;生成等值线&#xA;在ArcToolBox中，点击 3D Analyst工具 | 栅格表面 | 等值线&#xA;在打开的窗口中，输入DEM数据和适当的等高距&#xA;等值线转栅格&#xA;在ArcToolBox中，点击 转换工具 | 转为栅格 | 要素转栅格&#xA;选择等值线数据，字段随便填，输出像元大小要适当，在尽量大的前提下（快），令每条等高线清晰表示。&#xA;栅格等高线重分类&#xA;在ArcToolBox中，点击 Spatial Analyst | 重分类 | 重分类&#xA;选择栅格等值线，将其分为一类，值为1&#xA;由DEM生成坡向&#xA;在ArcToolBox中，点击 Spatial Analyst | 表面分析 | 坡向&#xA;将栅格等高线乘以坡向&#xA;在ArcToolBox中，点击 Spatial Analyst | 地图代数 | 栅格计算器&#xA;输入表达式 “Aspect_eleva1” * “Reclass_Feat1” （示例，以实物为准）&#xA;重分类上一结果（带有方向的等高线栅格）&#xA;0-90，表示正北到正东，将其设置为0&#xA;90-270，东-南-西，将其设为1&#xA;270-360，西-北，将其设置为0&#xA;设置图层颜色&#xA;将上一结果中0值设置为黑，1设置为白&#xA;设置背景&#xA;将DEM数据重分类为1类，将其设置为灰色，作为底图</description>
    </item>
    <item>
      <title>【栅格】如何确保裁剪前后的栅格像素深度或者栅格颜色保持一致</title>
      <link>https://anwangtanmi.github.io/posts/34f930515359b45cf0bf6389fa9f5001/</link>
      <pubDate>Fri, 28 Sep 2018 20:28:54 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/34f930515359b45cf0bf6389fa9f5001/</guid>
      <description>如何确保裁剪前后的栅格像素深度保持一致 Data Management Tools——Raster——Raster Processing——Clip&#xA;Spatial Analyst Tools——Extraction ——Extract by Mask&#xA;使用Clip工具，在工具的界面中会有设置Nodata值的位置，而Extract byMask中则没有。再看得到的结果呢，对于一个8bit的栅格数据，clip的结果仍然是8bit，而extract的结果就会变成16bit。原因就是执行clip时，不管mask是什么形状，工具中只会使用到envelope的坐标，这样得到的结果就是一个标准的矩形。而使用extract工具时，为了保留mask的准确的形状，在envelope内mask外的值需要标记为NoData，Unsigned8bit栅格的值的范围是0~255，nodata的值只能是255以外的某个值了，导致的结果就是会使用一个16bit的栅格来记录这个裁剪的结果。&#xA;方法一：只能牺牲掉裁切的部分中个数最少的那类象元值做nodata了。用arctoolbox里的set null工具，将选定（个数最少的那类象元值）的值设为nodata，然后再裁剪。&#xA;方法二：查找0-255之间是否有没有用过的值，如果有，以此值存储Nodata值，保证位数不改变。在Clip工具的可选参数中可以设置：NoData Value (optional)&#xA;All the pixels with the specified value will be set to NoData in the output raster dataset.&#xA;如何确保裁剪前后的栅格颜色保持一致 使用clip工具或使用Extract by Mask，裁剪后的栅格颜色与原始的不同？&#xA;有两个原因，&#xA;首先，是裁剪后像元值发生变化导致；&#xA;其次，是拉伸方式和统计值不同导致。只要保证像元值和拉伸方式完全相同，问题即可解决。&#xA;（1）在使用裁剪时，在环境变量里设置Snap Raster为原始DEM，保证裁剪后的像元值和原始DEM一致。——&amp;gt;像元值不变&#xA;（2）将裁剪后的DEM和裁剪前的DEM使用相同的拉伸方式和统计值——&amp;gt;拉伸方式、统计值&#xA;在DEM图层右键，打开symbology,使用standard deviation，统计值选择自定义，然后将当前statics使用save as XML导出为display.stat.xml。&#xA;在裁剪后的图层上右键，打开symbology，使用standard deviation，统计值选择自定义，然后使用LoadXML导入刚才生成的原始DEM的统计值display.stat.xml。之后，对比两幅DEM，颜色上完全相同。&#xA;之后，对比两幅DEM，颜色上完全相同。&#xA;栅格影像数据此方法也同样试用。</description>
    </item>
    <item>
      <title>BaiduMap SDK-多个个性化地图切换Demo</title>
      <link>https://anwangtanmi.github.io/posts/b9c1554406eff8301fa1d2635f578c29/</link>
      <pubDate>Thu, 19 Jul 2018 23:36:40 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/b9c1554406eff8301fa1d2635f578c29/</guid>
      <description>目录&#xA;1. assets中添加多个json文件&#xA;1.1 json文件项目结构&#xA;1.2 陆地(custom_config_land.json)&#xA;1.3水系(custom_config_water.json)&#xA;1.4 绿地(custom_config_green.json)&#xA;1.5 行政边界(custom_config_district.json)&#xA;1.6 旅游景区(custom_config_scenic.json)&#xA;1.7 机场(custom_config_airport.json)&#xA;2 代码编写&#xA;2.1 xm代码&#xA;2.2 Activity代码&#xA;2.2.1 初始化所有view&#xA;2.2.2 初始化数据和事件&#xA;2.2.3 个性化切换事件&#xA;2.2.4 刷新地图(设置个性化地图)&#xA;2.2.5 加载assets中的json&#xA;2.2.6 onDestroy()销毁地图组件和地图&#xA;1. assets中添加多个json文件 1.1 json文件项目结构 1.2 陆地(custom_config_land.json) [ { &#34;featureType&#34;: &#34;land&#34;, &#34;elementType&#34;: &#34;geometry&#34;, &#34;stylers&#34;: { &#34;color&#34;: &#34;#800000ff&#34;, &#34;level&#34;: &#34;12&#34; } }, { &#34;featureType&#34;: &#34;land&#34;, &#34;elementType&#34;: &#34;geometry&#34;, &#34;stylers&#34;: { &#34;color&#34;: &#34;#800080ff&#34; } } ] 1.3水系(custom_config_water.json) [ { &#34;</description>
    </item>
    <item>
      <title>ArcGIS Runtime 添加谷歌地图、OpenStreetMap作为底图</title>
      <link>https://anwangtanmi.github.io/posts/fd2e5ecc7d2097c2a3c60708396906f5/</link>
      <pubDate>Thu, 05 Jul 2018 22:13:04 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/fd2e5ecc7d2097c2a3c60708396906f5/</guid>
      <description>ArcGIS 自从发布Runtime以来一直以Web+C/S的模式，慢慢挑战着AE/AO的江湖地位。其可以添加Web底图的方法更是其杀手锏。&#xA;现在就分享ArcGIS Runtime中添加Google底图的方法。&#xA;开门见山，直接写出其最关键的类，自定义的一个类GoogleTileLayer&#xA;public class GoogleTileLayer : ServiceImageTiledLayer { private string LayerType = &#34;s&#34;;//图层类型 public GoogleTileLayer(TileInfo tileInfo, Envelope fullExtent, String inputLayerType) : base(tileInfo, fullExtent) { LayerType = inputLayerType; } //重写Uri函数 protected override Task GetTileUriAsync(int level, int row, int column, CancellationToken cancellationToken) { //Console.WriteLine(level.ToString() + &#34;,&#34; + row.ToString() + &#34;,&#34; + column.ToString());//打印输出 Task myTask = new Task(() =&amp;gt; GetTileUri(level, row, column, cancellationToken)); myTask.Start(); return myTask; } private Uri GetTileUri(int level, int row, int column, CancellationToken cancellationToken) { MapViewControl.</description>
    </item>
    <item>
      <title>智能小车二十《摄像头和路由器装上小车》</title>
      <link>https://anwangtanmi.github.io/posts/98695e79b785f207a6baca86e8f4cb8c/</link>
      <pubDate>Sat, 26 Aug 2017 16:11:59 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/98695e79b785f207a6baca86e8f4cb8c/</guid>
      <description> 很多次失败后，昨晚突然找到一个路由器16m的flash。再来一遍吧，经过几次的安装、加锡、去锡，终于把路由器搞定了。我就用默认的网络配置吧，至少这样比较稳定，每次都能访问到路由器。 总结昨晚几次的路由器的问题，还是焊接问题。正常的情况是一插电会闪两次，之后关闭几秒钟，最后常亮，亮度较高。前两次都是灯常亮，比较暗的那样亮，前文已经发过。8个引脚与焊盘的间隙基本看不见，不过我还是加了两次锡，终于正常了。这问题应该需要拿个显微镜才能看出来。我再放上小车时，又歇菜了。应该是虚焊了，小车一抖锡掉了，又加了下锡，到目前为止没出现异常。因为这个已经放进了路由器，没法上图了。上一个费掉的路由器的图，指下位置。 关于电源线的问题，我试验用的还是arduino的5v输出。mico usb接口焊了两根杜邦线，不太结实，后面再优化。 好了，把路由器、摄像头、小车拼起来，可以看到最终的效果了。除了长得比较丑，功能还是很强大的。启动后可用手机控制它到各屋里跑，还能通过红外控制电视。 摄像内容在浏览器展示： 手机操作: 当然它还是有些问题的。我试验发现，摄像头的视野比较窄，不熟悉的地方还真不知道方向，有时候前面被比较矮的东西档住也看不见。另外移动过程中，图像很模糊，不能识别位置。只能在停下来看，才能知道在那儿。 后面我会先把线路优化下，最后就进入真正的智能阶段了。做事不能急，相信一个好的产品需要时间。 </description>
    </item>
    <item>
      <title>ArcGIS 10.2中栅格数据的属性表问题</title>
      <link>https://anwangtanmi.github.io/posts/927a785935f259bfd563cf9c3bde4568/</link>
      <pubDate>Fri, 19 May 2017 08:39:30 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/927a785935f259bfd563cf9c3bde4568/</guid>
      <description>什么条件下我们能在ArcGIS中看到栅格数据的属性表呢？&#xA;网上的说法是：对于单波段的整型ESRI GRID数据，如果它的像元值范围小于10万(max-min&amp;lt;1000000)，并且少于500条唯一值，那么软件会为它创建一个“真正”的属性表存储在INFO文件夹的grid.VAT表格中。对于不满足上述条件的单波段整型数据，VAT不会自动创建，但是ArcGIS会为其创建一个虚拟的属性表，我们在软件中使用的时候，感觉它和“真正”的属性表一样一样的。&#xA;对于浮点型的数据，它不仅不可能有“真正”属性表的，而且它建立虚拟属性表的条件也是相当苛刻的。ArcGIS为单波段浮点型栅格建立虚拟属性表的条件是：少于25条唯一值。&#xA;ArcGIS 10.2中提供了创建栅格数据属性表的工具，位于Data Management Tool→Raster→Build Raster Attribute Table&#xA;对于以上工具，ESRI给出的用法是：&#xA;1.如果要删除现有表并创建一个新表，可选中覆盖。将创建新的栅格属性表并删除原有表。&#xA;2.如果有一个现成的表并且未选中覆盖，则将更新该表。不会删除任何字段，但是表中的值将更改为最新值。&#xA;3.不能为 32 位浮点像素类型的栅格数据集构建栅格属性表。&#xA;如果使用不满足格式的数据，会提示错误信息：Only single band integer raster dataset is a valid input Python脚本为：&#xA;import arcpy&#xA;arcpy.BuildRasterAttributeTable_management(“c:/data/image.tif”, “Overwrite”)</description>
    </item>
    <item>
      <title>教程:在ArchLinux下安装xfce4(GUI)。</title>
      <link>https://anwangtanmi.github.io/posts/c663710cf0865ec3857f3d6860abe79c/</link>
      <pubDate>Fri, 07 Oct 2016 11:58:55 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/c663710cf0865ec3857f3d6860abe79c/</guid>
      <description>在安装之前，你需要确认你的ArchLinux必须已连接网络(喂这不是废话吗！&#xA;***第一步，你需要先安装好xorg-server才可以。&#xA;1 2 3 pacman -S xorg-server xorg-server-utils xorg-xini pacman -S xorg-twm xorg-xclock xterm ***第二步，安装显卡驱动。&#xA;1 2 3 4 5 6 7 8 9 英特尔：pacman -S xf86-video-intel ATI：pacman -S xf86-video-ati 英伟达：pacman -S xf86-video-nv 通用显卡驱动：pacman -S xf86-video-vesa 另附笔记本触摸板通用驱动：pacman -S xf86-input-synaptics ***第三步，测试环境是否已搭建好。&#xA;键入：startx&#xA;如果输入完之后你的情况和图上一样的话，就说明一切正常。&#xA;***第四步，安装xfce4。&#xA;安装xfce4前请先安装slim登录管理器。&#xA;1 pacman -S slim 安装xfce4：&#xA;1 pacman -S xfce4 ***安装完成后，键入startxfce4即可开启xfce4。&#xA;1 2 pacman -S xorg-server xorg-xinit xorg-utils xorg-server-utils pacman -S xfce4 slim fcitx-im network-manager-applet xfce4-notifyd 至此教程结束。</description>
    </item>
    <item>
      <title>基于Arduino实现Arduino控制的电灯</title>
      <link>https://anwangtanmi.github.io/posts/5fa7a4c8a57171b6e088fe98a27ef86f/</link>
      <pubDate>Tue, 01 May 2012 04:18:36 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/5fa7a4c8a57171b6e088fe98a27ef86f/</guid>
      <description>主要介绍使用Arduino做出一个可以通过Android手机控制开关的电灯。试想，当你晚上睡在床上，打开手机，关闭书房或者走廊的电灯，是不是一件很cool的事情。&#xA;一、所需部件介绍 1）Arduino UNO板&#xA;这当然是必须的。不过这里要特别说明一下，我使用是的DF-Bluetooth V3的蓝牙模块，而部分Arduino UNO板由于串口限流电阻设计存在问题，会导致蓝牙模块只能发送数据而不能接收数据，这实在是一个很大的问题。我因为这个原因，又重新购买了一块新的Arduino UNO板。所以，在购买时请注意咨询卖家，确认是否已经改造过串口电阻，支持DF-Bluetooth V3模块。在进行制作前，也请先验证你的UNO板是否能通过蓝牙模块正常接收数据。&#xA;2）蓝牙模块（BluetoothV3）及传感器扩展板&#xA;我使用的是DF-Bluetooth V3蓝牙模块及Arduino Xbee传感器扩展板V5，这两者是配套的。当然没有扩展板也没有关系，直接连线通过SoftSerial方式会更好调试。有了扩展板，在使用的时候会更清爽，一根连线都不用了。&#xA;3）继电器&#xA;由于要控制220v的电灯，所以我们需要一个继电器模块，用小电流来控制大电流设备。我使用的是Arduino兼容的JQC-3FF继电器模块，能承受277V/10A的交流设备，这对我们制作电灯来说足够用了，而且做工还挺精致的。&#xA;4）Android手机 当然，肯定还有android手机。必须android2.0以上系统的android手机，推荐2.3及以上系统，必须要有蓝牙喲（废话）。&#xA;二、电路连接 1）继电器与电灯的连接&#xA;继电器有四个接线柱：NO、NC、N/A、COM。在接通控制电源后，通过控制信号，可以控制NO/NC与COM端口的闭合。我制作了一个简单的灯，将接线的火线断开，分别接在NO口与COM口。继电器的模块引脚有三个，分别是：1脚–控制端，2脚–电源（VCC），3脚–地（GND），使用数据线直接与Arduino的数字信号端口连接（扩展板有专门的插口，很方便。），我们采用7数字引脚。接好的继电器如图所示。&#xA;2）蓝牙模块&#xA;由于是配套的扩展板，直接插上就是了。&#xA;三、Arduino程序 要实现的功能其实很简单：设备通过蓝牙接收到到数据进行判断，控制继电器的开合。&#xA;代码如下：&#xA;int LIGHT_PIN = 7; //设置继电器的控制数字引脚 char bt_command; void setup() { Serial.begin(9600); //蓝牙的波特率，默认一般是9600根据自己的蓝牙设备设置而定 pinMode(LIGHT_PIN,OUTPUT); } void loop() { bt_command = Serial.read(); //从蓝牙上读取数据 if(bt_command == &#39;1&#39;){ //如果为字符1，闭合继电器，灯亮 digitalWrite(LIGHT_PIN,HIGH); }else if(bt_command == &#39;0&#39;){ //如果为字符0，断开继电器，灯灭 digitalWrite(LIGHT_PIN,LOW); } delay(2000); //做一个保护，避免点击过快，损坏灯 } 代码很简单，相信大家理解没有问题。&#xA;四、Android代码 这块相信是大家认为比较麻烦的，的确也是最麻烦的地方。不多说了，大家自己看源码。之前是用自己蓝牙的mac地址做寻址，方便。为了方便大家用，增加了设备扫描功能，这样如果不想做Android程序的，可以直接安装apk就能用。我在我的里程碑（用的MIUI）和i9100上都试过了，没问题。Enjoy it！&#xA;代码在github.com上：https://github.com/kindlymouse/Arduino&#xA;五、效果演示 http://v.youku.com/v_show/id_XMzg5NDA1ODI4.html&#xA;说明：我玩Arduino时间很短，还是新手。不足之处，大家见谅并请多提意见！</description>
    </item>
  </channel>
</rss>
