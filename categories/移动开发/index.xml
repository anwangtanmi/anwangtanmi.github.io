<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>移动开发 on 暗网探秘</title>
    <link>https://anwangtanmi.github.io/categories/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/</link>
    <description>Recent content in 移动开发 on 暗网探秘</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 04 Jul 2019 21:27:19 +0800</lastBuildDate>
    <atom:link href="https://anwangtanmi.github.io/categories/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Android9.0网络兼容和依赖适配问题</title>
      <link>https://anwangtanmi.github.io/posts/99dc2b8fa1f4b5ad34662c516fce627a/</link>
      <pubDate>Thu, 04 Jul 2019 21:27:19 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/99dc2b8fa1f4b5ad34662c516fce627a/</guid>
      <description>客观来说，9.0兼容好像问题不是很大，很多的APP一点问题都没有，但是有些比较旧的APP就问题比较多了，下面简单写一下解决方法，本文纯属笔记，方便以后查看。&#xA;网络问题： 问题一&#xA;应对9.0 版本的网络明暗流量问题&#xA;设置一下 application （清单文件里面）&#xA;问题二&#xA;引用httpclient的报错&#xA;java.lang.NoClassDefFoundError: Failed resolution of: Lorg/apache/commons/logging/LogFactory;&#xA;Caused by: java.lang.ClassNotFoundException: Didn’t find class “org.apache.commons.logging.LogFactory” on path: DexPathList[[zip file “/data/app/com.inno.nestlesuper- oPFXtK6GZQsOCWb8lvmj2g==/base.apk”],nativeLibraryDirectories= [/data/app/com.inno.nestlesuper-oPFXtK6GZQsOCWb8lvmj2g==/lib/arm, /data/app/com.inno.nestlesuper-oPFXtK6GZQsOCWb8lvmj2g==/base.apk!/lib/armeabi, /system/lib, /vendor/lib]]&#xA;主要问题是 9.0版本谷歌不支持这两个网络包了需要自己导进去支持来规避兼容问题。&#xA;api files(&#39;libs/httpclient-4.3.6.jar&#39;) api files(&#39;libs/httpcore-4.3.2.jar&#39;) 然后 解决方法如下：&#xA;下载导入一个commons-logging的jar包&#xA;api files(&#39;libs/commons-logging-1.2.jar&#39;) 自此网络问题解决。&#xA;当然使用jar毕竟麻烦，时不时更新就需要改动，在此用新的方法：&#xA;在AndroidManifest.xml下的节点加入以下相关依赖（如果项目继续使用Apache的httpclient），这是因为httpclient在Android6.0就已经被废弃了，如果不想大变动我们可以将这个库强制依赖进来，避免报错。&#xA;同时在app目录下build.gradle的android节点加入httpclient依赖：&#xA;useLibrary &#39;org.apache.http.legacy&#39; Android9.0官方要求中，禁止传输接收没加密的数据，也就是说对网络数据传输这一块做了限制，我们需要在AndroidManifest.xml中的节点内加入网络安全配置：&#xA;其中network_security_config.xml在xml目录如下：&#xA;依赖问题 我们升级SDK编译版本和目标版本为28时，我们需要改动相应的依赖版本：&#xA;implementation &#39;com.android.support:appcompat-v7:28.0.0&#39; implementation &#39;com.android.support:support-v4:28.0.0&#39; 冲突Program type already present 下面是一个项目build.gradle中的依赖，我们简单做一下分类&#xA;网络相关 okhttp&#xA;retrofit&#xA;http-legacy&#xA;常用类库 rxpermission(权限监测)&#xA;leakcanary(内存泄漏)</description>
    </item>
    <item>
      <title>WWDC2019 ——iOS13适配（持续更新）</title>
      <link>https://anwangtanmi.github.io/posts/41458635bdb4f88e37f7a65bfc930aac/</link>
      <pubDate>Sat, 15 Jun 2019 23:08:26 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/41458635bdb4f88e37f7a65bfc930aac/</guid>
      <description>第一、Web Content适配 https://developer.apple.com/videos/play/wwdc2019/511/&#xA;https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme&#xA;问题展示 先看两张图：&#xA;如上图所示，如果h5未适配dark模式，则在dark模式下原来的页面内容展示就就存在问题。&#xA;适配方法 这里主要介绍基于CSS样式的修改来适配web内容&#xA;首先，一定要声明当前支持的color-scheme有两种样式，这一句很重要，用东北话说就是“必须的”&#xA;:root { color-scheme: light dark; } 适配的策略就是为两种color-scheme设置不同的颜色样式。&#xA;1、文本适配 如图一，它的CSS描述为&#xA;body { color: black; } h1 { color: #333; } .header { background-color: #593a78; color: white; } 这里相关的颜色样式都是写死的，所以dark模式下才会出现图二的情况。现在我们来看如何适配下面这段代码：&#xA;h1 { color: #333; } .header { background-color: #593a78; color: white; } 然后可用如下方式改造：&#xA;:root { color-scheme: light dark; --post-title-color: #333; --header-bg-color: #593a78; --header-txt-color: white; } h1 { color: var(--post-title-color); } .header { background-color: var(--header-bg-color); color: var(--header-txt-color); } 这里所做的工作实际上是抽象了颜色的值的setter和getter，即不同模式下的值统一定义，然后使用时通过var()去自动获取。</description>
    </item>
    <item>
      <title>Flutter资源管理</title>
      <link>https://anwangtanmi.github.io/posts/b00947d54ed4a9b2ec8539df8e7102d6/</link>
      <pubDate>Thu, 16 May 2019 19:41:22 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/b00947d54ed4a9b2ec8539df8e7102d6/</guid>
      <description>资源管理 Flutter应用程序可以包含代码和 assets（有时称为资源）。assets是会打包到程序安装包中的，可在运行时访问。常见类型的assets包括静态数据（例如JSON文件）、配置文件、图标和图片（JPEG，WebP，GIF，动画WebP / GIF，PNG，BMP和WBMP）等。&#xA;指定 assets 和包管理一样，Flutter也使用pubspec.yaml文件来管理应用程序所需的资源。举一个例子:&#xA;flutter: assets: - assets/my_icon.png - assets/background.png assets指定应包含在应用程序中的文件。 每个asset都通过相对于pubspec.yaml文件所在位置的显式路径进行标识。asset的声明顺序是无关紧要的。asset的实际目录可以是任意文件夹（在本示例中是assets）。&#xA;在构建期间，Flutter将asset放置到称为 asset bundle 的特殊存档中，应用程序可以在运行时读取它们（但不能修改）。&#xA;Asset 变体（variant） 构建过程支持asset变体的概念：不同版本的asset可能会显示在不同的上下文中。 在pubspec.yaml的assets部分中指定asset路径时，构建过程中，会在相邻子目录中查找具有相同名称的任何文件。这些文件随后会与指定的asset一起被包含在asset bundle中。&#xA;例如，如果应用程序目录中有以下文件:&#xA;…/pubspec.yaml …/graphics/my_icon.png …/graphics/background.png …/graphics/dark/background.png …etc. 然后pubspec.yaml文件中只需包含:&#xA;flutter: assets: - graphics/background.png 那么这两个graphics/background.png和graphics/dark/background.png 都将包含在您的asset bundle中。前者被认为是main asset （主资源），后者被认为是一种变体（variant）。&#xA;在选择匹配当前设备分辨率的图片时，Flutter会使用到asset变体（见下文），将来，Flutter可能会将这种机制扩展到本地化、阅读提示等方面。&#xA;加载 assets 您的应用可以通过AssetBundle对象访问其asset 。有两种主要方法允许从Asset bundle中加载字符串或图片(二进制)文件。&#xA;加载文本assets 通过rootBundle 对象加载：每个Flutter应用程序都有一个rootBundle对象， 通过它可以轻松访问主资源包，直接使用package:flutter/services.dart中全局静态的rootBundle对象来加载asset即可。 通过 DefaultAssetBundle 加载：建议使用 DefaultAssetBundle 来获取当前BuildContext的AssetBundle。 这种方法不是使用应用程序构建的默认asset bundle，而是使父级widget在运行时动态替换的不同的AssetBundle，这对于本地化或测试场景很有用。 通常，可以使用DefaultAssetBundle.of()在应用运行时来间接加载asset（例如JSON文件），而在widget上下文之外，或其它AssetBundle句柄不可用时，可以使用rootBundle直接加载这些asset，例如：&#xA;import &#39;dart:async&#39; show Future; import &#39;package:flutter/services.dart&#39; show rootBundle; Future loadAsset() async { return await rootBundle.</description>
    </item>
    <item>
      <title>echart相关操作xAxis,yAxis,series,grid,(包括x轴样式，y轴样式，折现样式，网格样式，折现阴影，折线上方显示数据，x轴文字倾斜)</title>
      <link>https://anwangtanmi.github.io/posts/3f989873d9f3cf073957b58b7781fc61/</link>
      <pubDate>Thu, 16 May 2019 15:49:52 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/3f989873d9f3cf073957b58b7781fc61/</guid>
      <description>样式截图大概如下：&#xA;1. x，y轴相关操作：xAxis，yAxis&#xA;(1) x，y轴的颜色：&#xA;axisLine: { lineStyle: { color: &#39;#2898e5&#39;, }, }, (2) x，y轴文字颜色：&#xA;axisLabel: { show: true, textStyle: { color: &#39;#019bf8&#39; } } （3）x，y轴刻度颜色：&#xA;axisTick: { lineStyle: { color: &#39;#2898e5&#39; } } (4) x，y轴坐标文字太长显示不全：,倾斜rotate&#xA;axisLabel: { show: true, interval: 0, rotate: 20 }, （5）x ,y 轴网格线的颜色：&#xA;splitLine: { show: true, lineStyle: { color: [&#39;rgb(1,155,246,0.3)&#39;], //网格线 width: 1, } }, 2. 折现 的样式&#xA;（1） 折现的平滑度series：&#xA;symbol: &#39;circle&#39;, //实心点 symbolSize: 6, //实心点的大小 smooth: true, //折现平滑 （2）折现的颜色：</description>
    </item>
    <item>
      <title>Activity页面变暗并且不可点击只能返回的问题</title>
      <link>https://anwangtanmi.github.io/posts/7fbc4059ed2ba9618d2e82622aa653fb/</link>
      <pubDate>Fri, 12 Apr 2019 10:28:58 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/7fbc4059ed2ba9618d2e82622aa653fb/</guid>
      <description>场景：一个Activity请求网络，当出现网络问题请求出错时，会弹出一个Dialog提示。但是，在结果返回之前就跳到了另一个Activity，使得之前那个Activity处于后台，此时如果回到之前的Activity会出现页面变暗，而且任何地方不能点击的现象。这是由于Activity处于后台，弹Dialog遇到问题没有弹出来，但是页面已经变暗了，并抢占了焦点，使得底部的控件看得见但不可点击。给人的感觉就是App死机了，只有点返回键才能激活页面。查了半天，只遇到一个知己遇到和我一样的问题，并提出来了。有人给了一些方案。如下：https://www.iteye.com/problems/77129&#xA;我的场景不太一样，Dialog弹出没有那么重要，极端情况下Dialog可以不弹出，只要页面不变暗并且不可点击。所以我的思路是：只要Activity不是可见的，就不在当前Activity上调用弹出Dialog的操作。具体操作如下：&#xA;在我的网络请求框架MyGernericCallback上作如下判断：&#xA;//只有当Activity处于前台时，才在当前Activity上弹Dialog if (IsActivityForegroundUtil.isForeground((Activity) mContext)) { try { dialog.show(); } catch (Exception e) { e.printStackTrace(); } } IsActvityForegroundUtil.java&#xA;import android.app.Activity; import android.app.ActivityManager; import android.content.ComponentName; import android.content.Context; import android.text.TextUtils; import java.util.List; public class IsActivityForegroundUtil { /** * 判断某个界面是否在前台 * * @param activity 要判断的Activity * @return 是否在前台显示 */ public static boolean isForeground(Activity activity) { return isForeground(activity, activity.getClass().getName()); } /** * 判断某个界面是否在前台 * * @param context Context * @param className 界面的类名 * @return 是否在前台显示 */ public static boolean isForeground(Context context, String className) { if (context == null || TextUtils.</description>
    </item>
    <item>
      <title>cocos creator 图片黑边, 灰边问题的解决</title>
      <link>https://anwangtanmi.github.io/posts/604e233cd0fb526aa4c102443d8da903/</link>
      <pubDate>Sat, 23 Mar 2019 09:02:05 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/604e233cd0fb526aa4c102443d8da903/</guid>
      <description>软件环境：cocos creator 2.0&#xA;cocos creator 中的图片或多或少有些黑边或灰边的问题，一般是在透明图片的边缘。&#xA;图片来自网络&#xA;问题是由于纹理缩放边缘插值计算导致的，cocos2d—x中精灵的blend源默认应该是one，但是cocos creator不是。&#xA;Cocos2d-x 中的设置更加智能，默认对图片进行 WebGL 预乘，如果发现贴图是已经预乘过的，那么 Sprite 就使用 ONE 作为 blend src，否则使用 SRC_ALPHA。这里带来的问题是，贴图切换，用户手动修改 Blend function 的冲突，cocos2d-x 在切换贴图的时候，会自动根据贴图的预乘属性重新设置 Blend function，而不管用户是否手动修改过，这里就有潜在的 bug 可能。&#xA;解决方案一：&#xA;利用打包工具 TexturePacker 将资源打包成图集，打包过程中设置成预乘：&#xA;图片来自网络&#xA;解决方案二：&#xA;在cocos creator编辑器的sprite 设置为图集里边的图，然后Blend/SrcBlendFactor设置为one ：&#xA;图片来自网络&#xA;方案三：通过代码修改sprite的混合模式：&#xA;node.getComponent(cc.Sprite).srcBlendFactor = cc.macro.BlendFactor.ONE;&#xA;【互动教程列表，真正的手把手教学模式，点击或扫码下载】</description>
    </item>
    <item>
      <title>设置Android系统永不休眠灭屏（Android 8.0源码修改）</title>
      <link>https://anwangtanmi.github.io/posts/4562697c01fa500abddd9dc4f7b6a071/</link>
      <pubDate>Fri, 15 Feb 2019 10:37:20 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/4562697c01fa500abddd9dc4f7b6a071/</guid>
      <description>设置Android系统永不休眠灭屏（Android 8.0源码修改） From: zhoujinjian Date: Thu, 14 Feb 2019 17:24:00 +0800 Subject: [PATCH] feat(Policy) : 保持屏幕不灭屏feature实现 Description: Settings.Global.putInt(mContext.getContentResolver(), Settings.Global.SCREEN_STAY_ON_ANYWAY, 1); 说明：1保持常亮，0规定时间灭屏，系统初始化默认保持常亮 Project：android/platform/frameworks/base&#x9;--- diff --git a/api/current.txt b/api/current.txt index 2836067..806665c 100755 --- a/api/current.txt +++ b/api/current.txt @@ -35044,6 +35044,7 @@ field public static final java.lang.String RADIO_CELL = &#34;cell&#34;; field public static final java.lang.String RADIO_NFC = &#34;nfc&#34;; field public static final java.lang.String RADIO_WIFI = &#34;wifi&#34;; + field public static final java.lang.String SCREEN_STAY_ON_ANYWAY = &#34;</description>
    </item>
    <item>
      <title>Android 获取圆角图标bitmap黑色背景问题解决</title>
      <link>https://anwangtanmi.github.io/posts/effcdf67342dbbd4622294707fa23fdc/</link>
      <pubDate>Thu, 14 Feb 2019 10:22:27 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/effcdf67342dbbd4622294707fa23fdc/</guid>
      <description>一、问题场景 在做社会化分享到微博时要展示应用图标，一般获取图标作为bitmap的方法如下：&#xA;Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), R.mipmap.ic_launcher); 我用该代码分享出去一个圆角的图标，但是圆角部分展示为黑色，并且无法去除。&#xA;二、解决步骤 private Bitmap getBitmapByBg(Bitmap bitmap, int color){ Bitmap newBitmap = Bitmap.createBitmap(bitmap.getWidth(), bitmap.getHeight(), Bitmap.Config.ARGB_4444); Canvas canvas = new Canvas(newBitmap); canvas.drawColor(color); Paint paint = new Paint(); canvas.drawBitmap(bitmap, 0, 0, paint); return newBitmap; } 搞定！</description>
    </item>
    <item>
      <title>解决设置沉浸式时华为手机底部导航栏兼容性问题</title>
      <link>https://anwangtanmi.github.io/posts/00005bc4afebf4cf939becab295b1624/</link>
      <pubDate>Tue, 29 Jan 2019 19:32:15 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/00005bc4afebf4cf939becab295b1624/</guid>
      <description>在设置沉浸式时，华为手机底部导航栏会覆盖app的真实内容，提供以下解决方案：&#xA;判断是否有导航栏并且获取高度，然后给window的content设置padding&#xA;public static int getNavigationBarHeight(Context context) { boolean hasMenuKey = ViewConfiguration.get(context).hasPermanentMenuKey(); boolean hasBackKey = KeyCharacterMap.deviceHasKey(KeyEvent.KEYCODE_BACK); if (!hasMenuKey &amp;amp;&amp;amp; !hasBackKey) { Resources resources = context.getResources(); int resourceId = resources.getIdentifier(&#34;navigation_bar_height&#34;, &#34;dimen&#34;, &#34;android&#34;);//获取NavigationBar的高度 int height = resources.getDimensionPixelSize(resourceId); return height; } else { return 0; } } 判断是否存在导航栏，并且返回高度，然后在activity的基类里设置&#xA;getWindow().getDecorView().findViewById(android.R.id.content).setPadding(0, 0, 0, getNavigationBarHeight(this)); 这样就能完美适应了，沉浸式改怎么做就这么做</description>
    </item>
    <item>
      <title>android studio 的 sync、make、clean、rebuild、build APK</title>
      <link>https://anwangtanmi.github.io/posts/ce48a846dddfff20c80909cee8338f7c/</link>
      <pubDate>Sat, 13 Oct 2018 14:09:54 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/ce48a846dddfff20c80909cee8338f7c/</guid>
      <description>一、sync idea 官网说明&#xA;功能是：&#xA;Synchronizing Changes in Gradle Project and IntelliJ IDEA Project&#xA;即同步 gradle 项目和 idea 项目&#xA;点击 as 的 help/Show Log in Finder（windows 可能略有不同）&#xA;点击 sync 后，查看 log：&#xA;2018-10-13 12:04:31,930 [e-1024-b01] INFO - e.project.sync.GradleSyncState - Started sync with Gradle for project &#39;JitpackTest&#39;. 2018-10-13 12:04:43,183 [d thread 3] INFO - ild.invoker.GradleBuildInvoker - About to execute Gradle tasks: [:app:generateDebugSources] 可看出，同步后，执行了 :app:generateDebugSources task。&#xA;二、make 查看 as 的 log（部分）：&#xA;2018-10-13 13:49:51,668 [e-1024-b01] INFO - ild.</description>
    </item>
    <item>
      <title>控制LED的亮度</title>
      <link>https://anwangtanmi.github.io/posts/b5bb31d1df916685a5828447e85ac4c2/</link>
      <pubDate>Wed, 03 Oct 2018 11:06:05 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/b5bb31d1df916685a5828447e85ac4c2/</guid>
      <description>int i=6; void setup() { // put your setup code here, to run once: pinMode(i,OUTPUT); } void loop() { // put your main code here, to run repeatedly: analogWrite(i,0); delay(1000); analogWrite(i,50); delay(1000); analogWrite(i,100); delay(1000); analogWrite(i,150); delay(1000); analogWrite(i,200); delay(1000); analogWrite(i,250); delay(1000); } 这里用到了analogWrite，参数一是引脚值，参数二是输出的电压值，最大是255V。这里有一个前提，输出的引脚只能是带波浪线的数字引脚，这样才能改变电压值</description>
    </item>
    <item>
      <title>android 把图片状态由彩色变成灰色</title>
      <link>https://anwangtanmi.github.io/posts/98ba84699493f2eedc2d67068cceaa7c/</link>
      <pubDate>Thu, 30 Aug 2018 11:36:18 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/98ba84699493f2eedc2d67068cceaa7c/</guid>
      <description> public static final Bitmap grey(Bitmap bitmap) { int width = bitmap.getWidth(); int height = bitmap.getHeight(); Bitmap faceIconGreyBitmap = Bitmap .createBitmap(width, height, Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(faceIconGreyBitmap); Paint paint = new Paint(); ColorMatrix colorMatrix = new ColorMatrix(); colorMatrix.setSaturation(0); ColorMatrixColorFilter colorMatrixFilter = new ColorMatrixColorFilter( colorMatrix); paint.setColorFilter(colorMatrixFilter); canvas.drawBitmap(bitmap, 0, 0, paint); return faceIconGreyBitmap; } </description>
    </item>
    <item>
      <title>android Glide简单使用</title>
      <link>https://anwangtanmi.github.io/posts/0855e953ad58d4914b8896ad004d6a7f/</link>
      <pubDate>Wed, 15 Aug 2018 13:39:21 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/0855e953ad58d4914b8896ad004d6a7f/</guid>
      <description>今天，简单讲讲Android里Glide的简单使用。&#xA;Android框架系列：&#xA;一.android EventBus的简单使用&#xA;二.android Glide简单使用&#xA;对于Glide这个加载图片的框架，很多人都在用，我之前使用的是ImageLoader，最近查资料时，发现Glide才是Google推荐的加载图片框架，功能非常强大，而且还有Google专人维护，要知道，ImageLoader已经没人维护了，除了问题可没人解答。所以有必要整理一下Glide的使用。&#xA;Glide是谷歌为我们推荐的一个图片加载库。为什么要选择使用Glide呢？&#xA;1、代码有人维护，不至于出现问题，项目组都搞不定的时候问题无法解决。（ImageLoader已没人维护了） 2、代码简洁，可读性很好。（Fresco是一个非常优秀的库，但是配置稍显麻烦，同时代码风格读起来有些生疏） 3、功能强大（400多k的包，包含很多功能，例如：像加载Gif图片就是Picasso做不到的） 下面我们就来介绍下Glide的用法：&#xA;Glide的基本使用 导入库 compile &#39;com.github.bumptech.glide:glide:3.7.0&#39; 添加代码混淆（可加可不加） -keep public class * implements com.bumptech.glide.module.GlideModule -keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** { **[] $VALUES; public *; } # for DexGuard only -keepresourcexmlelements manifest/application/meta-data@value=GlideModule 这个别忘了，不要粗心哦，很容易忘得，最简单的问题，往往需要最简单的搞定啦。&#xA;简单使用例子 // For a simple view: @Override public void onCreate(Bundle savedInstanceState) { ... ImageView imageView = (ImageView) findViewById(R.id.my_image_view); Glide.with(this).load(&#34;http://goo.gl/gEgYUd&#34;).into(imageView); } // For a simple image list: @Override public View getView(int position, View recycled, ViewGroup container) { final ImageView myImageView; if (recycled == null) { myImageView = (ImageView) inflater.</description>
    </item>
    <item>
      <title>Android摄像头使用问题记录</title>
      <link>https://anwangtanmi.github.io/posts/e4518a5212dda9f924cf6ff2ea2bb003/</link>
      <pubDate>Tue, 03 Jul 2018 09:57:52 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/e4518a5212dda9f924cf6ff2ea2bb003/</guid>
      <description>一. camera.getParameters()时候抛出异常“getParameters failed (empty parameters)” 查看了here&#xA;由于本应用多处使用摄像头，在不断切换中，可能存在释放和预览相争问题，在遇到这个异常的时候，捕获后对摄像头做释放操作，即可恢复正常。&#xA;二. 预览使用surfaceview ，底部有视频（surface）等，需要设置surfaceview到顶部覆盖底部 //解决和底部视频广告重叠的时候不能显示问题 surfaceHolder.setFormat(PixelFormat.TRANSPARENT); //surfaceView放置在顶层，即始终位于最上层 //surfaceView.setZOrderOnTop(true);//位于最上层 surfaceView.setZOrderMediaOverlay(true);//覆盖底部视频 三. 预览后通过setPreviewCallback获取到的data无法转bitmap 因为data属于YUMImage格式，所以不能直接转bitmap,先处理一下byte，使得可以转bitmap&#xA;private byte[] zpiByte(byte[] data, int mWidth, int mHeight) { YuvImage image = new YuvImage(data, ImageFormat.NV21, mWidth, mHeight, null);//这个参数不要乱动，乱动会转错误 ByteArrayOutputStream stream = new ByteArrayOutputStream(); image.compressToJpeg(new Rect(0, 0, mWidth, mHeight), 100, stream);//先按原尺寸转成jpeg的流，后面再压缩一次。这个也不要乱动参数 byte[] finalface = stream.toByteArray();//此时的尺寸并不小，但我尝试在上面代码直接转小会错位，考虑到要经过网络，所以后面会再转换一次，但转换速度非常快，基本上不会影响性能 int rotateAngle = mFaceFragment.getRotation(); Log.i(TAG, &#34;rotateAngle&#34; + rotateAngle); if (rotateAngle &amp;gt; 0) {//如果检测的时候需要旋转，那么拍下来的图片也需要旋转 shi Bitmap bitmap; bitmap = BitmapFactory.</description>
    </item>
    <item>
      <title>HttpUrlConnection</title>
      <link>https://anwangtanmi.github.io/posts/a257e70ff1239a09b801f768eb074973/</link>
      <pubDate>Sat, 09 Jun 2018 22:27:14 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/a257e70ff1239a09b801f768eb074973/</guid>
      <description>一.GET和POST方式有什么区别 GET方式属于明文传参，在地址栏可以看到参数，调用简单，不安全。 POST方式输入暗文传参，在地址栏不可见，调用复杂，安全。 二.HttpUrlConnection请求网络实例 1.创建URL对象 URL url = new URL(&#34;https://www.baidu.com/&#34;); 2.通过URL对象调用openConnection()方法获得HttpURLConnection对象 HttpURLConnection connection = (HttpURLConnection) url.openConnection(); 3.HttpURLConnecton对象调用getlnputStream()方法向服务器发送http请求并获取到服务器返回的输入流 InputStream inputStream = connection.getInputStream(); 4.读取输入流，转换成String字符串 InputStreamReader reader = new InputStreamReader(inputStream); //创建BufferedReader对象 BufferedReader bufferedReader = new BufferedReader(reader); //开始读取 String temp = &#34;&#34;; StringBuffer stringBuffer = new StringBuffer(); 注：1.在Android中访问网络必须添加网络权限。 &amp;lt;uses-permission android:name=&#34;android.permission.INTERNET&#34; /&amp;gt; 2.在Android中访问网络必须放在子线程中执行 三.HttpUrlConnection请求网络图片实例 xml代码如下： id=&#34;@+id/web_btn1&#34; android:layout_width=&#34;match_parent&#34; android:layout_height=&#34;50dp&#34; android:text=&#34;访问网络图片&#34;/&amp;gt; id=&#34;@+id/web_iv&#34; android:layout_width=&#34;match_parent&#34; android:layout_height=&#34;match_parent&#34; android:scaleType=&#34;centerCrop&#34;/&amp;gt; 效果如图： Java代码如下： web_btn1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { new Thread(new Runnable() { @Override public void run() { getWebpic(); } }).</description>
    </item>
    <item>
      <title>webView中导入百度地图和设置样式</title>
      <link>https://anwangtanmi.github.io/posts/35d0ae49abd57cf5f72c1164eea6670c/</link>
      <pubDate>Sat, 28 Apr 2018 12:15:33 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/35d0ae49abd57cf5f72c1164eea6670c/</guid>
      <description>首先看效果图：&#xA;####怎样获取百度地图api&#xA;第一种方式：找到“百度地图api”&#xA;第二种方式：”百度地图生成器“&#xA;注意此方式生成的地图使用的是百度地图api1.1&#xA;####设置地图样式&#xA;博主使用的是用百度地图生成器生成的地图，可以先保存成html格式，查看地图是否需要改进&#xA;– 消除百度地图的logo 方法：使用Google浏览器打开刚刚保存的HTML，打开开发者模式（或者按F12）&#xA;添加样式消除logo&#xA;.BMap_cpyCtrl { display: none; } .anchorBL { display: none; } #####设置背景色&#xA;因为这个样式在百度地图api1.0中不起效，所以我把JavaScript换成了3.0&#xA;原js: 换成api3.0 #####设置地图的大小&#xA;这里设置充满屏幕，需要改动三个地方，是否还有其他方法不太清楚，但是博主是这样做的（可能我太菜了）&#xA;暂时博主就只设置这几个样式，最终效果图如下：&#xA;####使用webView加载百度地图&#xA;这里我使用Javafx中的webView组件，详情可见：WebView组件概览&#xA;目录结构：&#xA;package work.javaee.maptest; import javafx.application.Application; import javafx.scene.Scene; import javafx.scene.layout.BorderPane; import javafx.scene.web.WebEngine; import javafx.scene.web.WebView; import javafx.stage.Stage; public class Main extends Application{ @Override public void start(Stage primaryStage) throws Exception { //设置窗体布局 BorderPane borderPane = new BorderPane(); //创建scene Scene scene = new Scene(borderPane); //创建WebView和WebEngine对象 WebView webView = new WebView(); WebEngine webEngine = webView.</description>
    </item>
    <item>
      <title>popopWindow 实现顶部筛选菜单（顶部不变，底部阴暗）思路记录</title>
      <link>https://anwangtanmi.github.io/posts/356143f167b7e5477291f50f44691582/</link>
      <pubDate>Fri, 23 Mar 2018 18:30:58 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/356143f167b7e5477291f50f44691582/</guid>
      <description> 先上效果：&#xA;需要解决的问题：&#xA;1.popopWindow 位置（此处为toolbar正下方）&#xA;2.顶部不变，底部阴暗&#xA;3.popopWindow 根据item个数适配高度，并设置最大height&#xA;一、popopWindow 位置&#xA;首先第一点，传入的parent为toolbar。下面的location位置为toolbar在屏幕中位置的左上角那个点（x，y）&#xA;int[] location = new int[2]; parent.getLocationOnScreen(location); popupWindow = new PopupWindow(view, popWidth, LayoutParams.WRAP_CONTENT); popupWindow.setFocusable(true); popupWindow.setOutsideTouchable(true); popupWindow.setBackgroundDrawable(new BitmapDrawable()); popupWindow.showAtLocation(view, Gravity.NO_GRAVITY, ScreenUtils.getScreenWidth(parent.getContext())- popupWindow.getWidth()-DensityUtil.dip2px(context,10), location[1] + parent.getHeight()); 二、顶部不变，底部阴暗&#xA;第一次尝试&#xA;WindowManager.LayoutParams lp = context.getWindow().getAttributes(); lp.alpha = alpha; context.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND); context.getWindow().setAttributes(lp); 标题栏也会变暗，尝试失败。&#xA;第二次尝试&#xA;在toolbar下方放一个view（背景色为暗色）占满剩余屏幕，通过popupwindow展示与否，来控制view的显示与否来实现&#xA;尝试成功。&#xA;三、popopWindow 根据item个数适配高度，并设置最大height&#xA;其他弹出类的窗口类似！在获取width与height之前先进行测量！myView为展示的listview，通过获取其高度，并与最大高度比较来决定最终使用的高度值。&#xA;PopupWindow pw= new PopupWindow(myView, ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT); int maxH = DensityUtil.dip2px(getActivity(), 80);&#xA;myView.measure(View.MeasureSpec.UNSPECIFIED, View.MeasureSpec.UNSPECIFIED);&#xA;if(myView.getMeasuredHeight()&amp;gt;maxH){&#xA;pw.setHeight(maxH);&#xA;} </description>
    </item>
    <item>
      <title>Activity 转场动画踩坑</title>
      <link>https://anwangtanmi.github.io/posts/bb6ca8cc2c6d06f29f44179251e2ef17/</link>
      <pubDate>Thu, 08 Mar 2018 16:51:43 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/bb6ca8cc2c6d06f29f44179251e2ef17/</guid>
      <description>目标效果 实现方案 Activity#overridePendingTransition() android:windowAnimationStyle 参考文章 目标效果 页面出现的效果是自下向上滑入，消失的效果是自上向下滑出，时长、速度未知。&#xA;实现方案 为表述方便，我们假设由 Activity A 打开 Activity B。&#xA;Activity#overridePendingTransition() A 页面不变，B 页面出现，在 Activity A 中 startActivity() 后面添加代码：&#xA;overridePendingTransition(android.R.anim.slide_in_up, R.anim.anim_hold); 注意，如果第二个参数为 0，切换时未出现黑色背景。&#xA;slide_in_up.xml&#xA;&amp;lt;translate xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34; android:duration=&#34;300&#34; android:fromYDelta=&#34;100%&#34; android:interpolator=&#34;@android:anim/accelerate_interpolator&#34; android:startOffset=&#34;0&#34; android:toXDelta=&#34;0&#34; /&amp;gt; slide_out_down.xml&#xA;&amp;lt;translate xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34; android:duration=&#34;300&#34; android:fromYDelta=&#34;0%p&#34; android:interpolator=&#34;@android:anim/accelerate_interpolator&#34; android:toYDelta=&#34;100%p&#34; /&amp;gt; anim_hold.xml &amp;lt;translate xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34; android:duration=&#34;200&#34; android:fromYDelta=&#34;0&#34; android:toYDelta=&#34;0&#34; /&amp;gt; 注意，anim_hold.xml 中的 duration 不能设置过长，否则，页面过度已完成立即返回桌面，Activity A 依然在展示，覆盖在桌面上。&#xA;A 页面不变，B 页面消失的动画，是在 Activity B 中 finish() 后面添加代码：&#xA;overridePendingTransition(0, android.R.anim.slide_out_down); 效果(锤子 t2 和 华为 mate 9 pro): 图1</description>
    </item>
    <item>
      <title>Android Deep Link</title>
      <link>https://anwangtanmi.github.io/posts/091a9ca7bfe538534cc80158ee8bf387/</link>
      <pubDate>Sun, 17 Dec 2017 21:22:03 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/091a9ca7bfe538534cc80158ee8bf387/</guid>
      <description>Android Deep Link 官网参考文档&#xA;使用场景 用户在网页点击了一个链接以后，直接引导用户在本地应用中查看对应的内容。&#xA;原理 当我们点击或者自动化的网络请求会生成一个web URI intent，Android系统按照一定顺序去处理这个请求。 处理顺序为：1.打开所有可以处理本URL应用中用户默认选择的；2.打开唯一能处理这个URL的应用；3.将所有可以处理这个URL的应用展示在Dialog中让用户选择&#xA;基本步骤 在manifest文件中定义IntentFilter 建立对应处理的Activity (对于Android App Link而言)将本地内容与URL地址通过服务器上的Digital Asset Links文件关联起来 辅助工具 Android Studio的App Link Assistant使用说明：官方使用指南&#xA;分类 Deep Link,Android App Link&#xA;Deep Link 配置 在Manifest中增加intent filter : ACTION_VIEW : 包含BROWSABLE,DEFAULT.BROWSABLE(必须包含，才可以处理来至l浏览器的Intent Filter) : 指定可以响应的URI信息，至少包含scheme标签，可以使用path,pathPattern或者pathPrefix去处理相似的URI // 可以响应example://gizmos 和 http://www.example.com/gizmos的Activity &amp;lt;activity android:name=&#34;com.example.android.GizmosActivity&#34; android:label=&#34;@string/title_gizmos&#34; &amp;gt; &amp;lt;intent-filter android:label=&#34;@string/filter_view_http_gizmos&#34;&amp;gt; &amp;lt;action android:name=&#34;android.intent.action.VIEW&#34; /&amp;gt; &amp;lt;category android:name=&#34;android.intent.category.DEFAULT&#34; /&amp;gt; &amp;lt;category android:name=&#34;android.intent.category.BROWSABLE&#34; /&amp;gt; &amp;lt;data android:scheme=&#34;http&#34; android:host=&#34;www.example.com&#34; android:pathPrefix=&#34;/gizmos&#34; /&amp;gt; intent-filter&amp;gt; &amp;lt;intent-filter android:label=&#34;@string/filter_view_example_gizmos&#34;&amp;gt; &amp;lt;action android:name=&#34;</description>
    </item>
    <item>
      <title>Deep linking 深度链接</title>
      <link>https://anwangtanmi.github.io/posts/5a6b06b9a4bfe6b4714ee7e802e9fbb1/</link>
      <pubDate>Thu, 23 Nov 2017 18:30:20 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/5a6b06b9a4bfe6b4714ee7e802e9fbb1/</guid>
      <description>使用安卓或ios软件的过程中经常碰到这样一种情况：当我在浏览器打开一个页面时，时常会自动打开相对应的app，并进入相应的app页面中，这就用到一项技术-Deep Linking，下面就来介绍一下如何在自己的android APP中使用这项技术。&#xA;1。假设已经有了一个app项目，我们需要在项目中新建一个Activity。我们暂且取名为ViewActivity，在AndroidManifest.xml文件中的ViewActivity标签中添加Intent-filter：&#xA;&amp;lt;activity android:name=&#34;.activity.ViewActivity&#34;&amp;gt; &amp;lt;intent-filter&amp;gt; &amp;lt;action android:name=&#34;android.intent.action.VIEW&#34;/&amp;gt; &amp;lt;category android:name=&#34;android.intent.category.DEFAULT&#34;/&amp;gt; &amp;lt;category android:name=&#34;android.intent.category.BROWSABLE&#34;/&amp;gt; &amp;lt;data android:scheme=&#34;myapp&#34;/&amp;gt; intent-filter&amp;gt; activity&amp;gt; 2。此时在网页中就可调用这个地址就可以打开我们的app，下面是我写的一个测试deep linking的html代码：&#xA;&amp;lt;/span&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&#34;{CHARSET}&#34;&amp;gt; &amp;lt;title&amp;gt;title&amp;gt; head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;a href=&#34;myapp://&#34;&amp;gt;打开我的appa&amp;gt; body&amp;gt; html&amp;gt; 在手机上打开这个网页，点击链接“打开我的app”就可以自动打开我们的app了，并且能自动进入ViewActivity这个页面中。其实并不是只有myapp://这个链接可以进入我们的app，只要开头为myapp://的链接都可以自动进入我们的app。&#xA;3.但是我们的要求不是自动进入app的ViewActivity页面，我们的ViewActivity只是作为一个处理deep linking 的一个过渡页面。总不能在每个页面都要写这么一套代码吧，当然不能，下面我就来介绍如何根据schema内容来引导app进入页面 1).在ViewActivity中取出我们的URI值。在此顺带讲解一下URI值中的各个属性，可能有些代码在我们这个测试项目中用不到，只是作为demo讲解一下（我的项目使用kotlin写的，暂时就用kotlin给大家讲解了，我相信懂java的应该都能看懂kotlin）&#xA;val uri = intent.data//链接地址 val host = uri.host//域名 var query=uri.query//获取参数列表 var params = query.toString().split(&#34;&amp;amp;&#34;) var bundle=Bundle()//bundle容器，用来保存传递链接问号后带的参数 if(null!=params){ for (key_value in params) { bundle.putString(key_value.split(&#34;=&#34;)[0],key_value.split(&#34;=&#34;)[1]) } } intent.putExtras(bundle) var pageName=uri.getHost()//这就是我们链接中传递过来的页面名字，因为很多情况下需要统一android与IOS的页面跳转，所以这个名字并不是我们严格意义上的项目中的页面名，而是我们私下里商量好的那个字符串对应哪个页面 when(pageName){ &#34;page1&#34; -&amp;gt;{ intent.setClass(this,Page1::class.java) startActivity(intent) } &#34;</description>
    </item>
    <item>
      <title>Android踩坑日记：点击变暗效果的ImageView实现原理</title>
      <link>https://anwangtanmi.github.io/posts/11632a52aec06530048dec9875ea2084/</link>
      <pubDate>Sat, 21 Oct 2017 10:00:57 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/11632a52aec06530048dec9875ea2084/</guid>
      <description>很多时候我们使用ImagView显示图片，无论是Gilde，Fresco等图片显示框架，比如设置中心更换头像，网格相册点击预览，选择等情况，会遇到点击变暗的交互需求。&#xA;源码分析 我们想的办法是自定义一个ImageView，当点击图片时，是不是有回调方法来同时改变图片的滤镜或者蒙版等。 特意去看了View.java的源码（ImageView继承View），想看看View被点击之后是是否有回调函数可用。 View的onTouchEvent()方法 case MotionEvent.ACTION_DOWN: mHasPerformedLongPress = false; if (performButtonActionOnTouchDown(event)) { break; } // Walk up the hierarchy to determine if we&#39;re inside a scrolling container. boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for // a short period in case this is a scroll. if (isInScrollingContainer) { mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) { mPendingCheckForTap = new CheckForTap(); } postDelayed(mPendingCheckForTap, ViewConfiguration.</description>
    </item>
    <item>
      <title>Android 绘图Shader之BitmapShader</title>
      <link>https://anwangtanmi.github.io/posts/2984031911b8f24dcef3d336202a75fe/</link>
      <pubDate>Tue, 19 Sep 2017 14:27:09 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/2984031911b8f24dcef3d336202a75fe/</guid>
      <description>Shader Shader在计算机图形领域叫做着色器，是一组提供给GPU的绘图指令，用于告诉GPU在绘图时应该怎么绘制并对绘制的物体进行色彩渲染。&#xA;Android中定义了几种Shader给Paint使用，在Paint绘制图像时对其设置不同的Shader，绘制出来的物体就会使用Shader提供的信息进行着色。&#xA;Shader的子类有：BitmapShader、LinearGradient、ComposeShader、RadialGradient、SweepGradient&#xA;BitmapShader BitmapShader是使用一张指定的图片给Paint进行着色，在绘制的时候会根据设置的TileMode（平铺模式）和图像来形成不同的效果，其中TileMode有&#xA;如下三种：&#xA;CLAMP 这种模式在绘制的时候如果绘制区域超出提供的图片的尺寸，超出区域会使用超出部分的边缘颜色进行着色&#xA;REPEAT 这种模式在绘制的时候如果绘制区域超出提供的图片的尺寸，超出区域会重新使用完整的图片进行着色&#xA;MIRROR 这种模式在绘制的时候如果绘制区域超出提供的图片的尺寸，超出区域会重新使用完整的图片进行着色，并且呈镜面反转效果&#xA;BitmapShader构造函数：&#xA;/** * 唯一的一个构造函数，调用这个构造函数构造一个新的BitmapShader * * @param bitmap 用于着色的bitmap对象 * @param tileX 水平方向的平铺模式. * @param tileY 垂直方向的平铺模式. */ public BitmapShader(@NonNull Bitmap bitmap, TileMode tileX, TileMode tileY) { BitmapShader实例 public class BitmapShaderView extends View { private Paint mPaint; private Shader mShader; /** * 用于给Paint着色的图片 */ private Bitmap mBitmap; public BitmapShaderView(Context context, @Nullable AttributeSet attrs) { super(context, attrs); initial(); } private void initial(){ mPaint = new Paint(); mPaint.</description>
    </item>
    <item>
      <title>[FAQ17385]录像打开EIS后画面变的突然很暗</title>
      <link>https://anwangtanmi.github.io/posts/7ce5326fcafc43733b279fedee08a4a5/</link>
      <pubDate>Tue, 29 Aug 2017 19:05:38 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/7ce5326fcafc43733b279fedee08a4a5/</guid>
      <description>[DESCRIPTION] 录像打开EIS后,画面变得很暗. [SOLUTION] [MT6735/53,MT6755,MT6732/52] 1. 没开EIS, recording是动态帧率. 2. 打开EIS后, recording是固定帧率为30fps. 帧率固定以后,画面会变暗. 解决办法: /vendor/mediatek/proprietary/custom/[platform]/hal/camera/camera_custom_eis.cpp bool GetEisLinkWithDfr()&#xA;{&#xA;return true; // true : dynamic frame rate off when eis on; false : dynamic frame rate on when eis on }&#xA;将return ture修改为false, 打开EIS后不会固定录像的帧率. [MT6580] alps\vendor\mediatek\proprietary\platform\mt6580\hardware\mtkcam\v1\hal\adapter\mtkdefault\MtkDefaultCamParameter.cpp&#xA;status_t CamAdapter::setParameters()&#xA;{&#xA;…&#xA;cam3aParam.u4ShotMode = mpParamsMgr-&amp;gt;getShotMode();&#xA;cam3aParam.u4CamMode = mpParamsMgr-&amp;gt;getHalAppMode();&#xA;cam3aParam.i4RotateDegree = mpParamsMgr-&amp;gt;getInt(MtkCameraParameters::KEY_ROTATION);&#xA;////////将下面这行////&#xA;cam3aParam.bVideoStabilization = (mpParamsMgr-&amp;gt;getVideoStabilization(); /////////////////改成/////&#xA;cam3aParam.bVideoStabilization = 0;</description>
    </item>
    <item>
      <title>一个高仿微博等待动画loading——等待动画的简单实现</title>
      <link>https://anwangtanmi.github.io/posts/25d7fc27e62ad7a9d45910b4f349f647/</link>
      <pubDate>Thu, 24 Aug 2017 10:04:22 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/25d7fc27e62ad7a9d45910b4f349f647/</guid>
      <description>正文 背景&#xA;大家都知道，当我们在app开发的时候，一般少不了，比如当请求网络数据时，肯定网速不好的时候。&#xA;在这种情况下，加载的时候比较慢，所以如果此时已经进入了新的界面，那么肯定不好看。&#xA;所以一般都会有一个loading等待提示框，告诉用户正在加载中，给用户更好的体验。因此这就是我教大家实现的效果，先看一下效果图吧:&#xA;我这里使用了一个handler延迟两秒钟让它消失不见。当然项目中大家可以监听自己所需要的方法，使加载框消失。&#xA;这只是简单的两种实现方式，当然还有更好的其他效果，具体可以自己实现以下，也可以去网上搜索一下。&#xA;说主题吧，我这里只是讲一下思路，具体代码可以试着写一下，当然我在最后会给大家放源代码下载地址。&#xA;第一步，先写一个自定义dialog，代码也比较详细。就是创建一个dialog，如：&#xA;public static Dialog createLoadingDialog(Context context, String msg) { LayoutInflater inflater = LayoutInflater.from(context); View v = inflater.inflate(R.layout.dialog_loading, null);// 得到加载view LinearLayout layout = (LinearLayout) v.findViewById(R.id.dialog_loading_view);// 加载布局 TextView tipTextView = (TextView) v.findViewById(R.id.tipTextView);// 提示文字 tipTextView.setText(msg);// 设置加载信息 Dialog loadingDialog = new Dialog(context, R.style.MyDialogStyle);// 创建自定义样式dialog loadingDialog.setCancelable(true); // 是否可以按“返回键”消失 loadingDialog.setCanceledOnTouchOutside(false); // 点击加载框以外的区域 loadingDialog.setContentView(layout, new LinearLayout.LayoutParams( LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.MATCH_PARENT));// 设置布局 /** *将显示Dialog的方法封装在这里面 */ Window window = loadingDialog.getWindow(); WindowManager.LayoutParams lp = window.</description>
    </item>
    <item>
      <title>【关于适配】PopupWindow弹出时背景不变暗 或者 PopupWindow背景一闪一闪问题处理</title>
      <link>https://anwangtanmi.github.io/posts/92a8ba2d67a1e55374888000108b4e8a/</link>
      <pubDate>Wed, 09 Aug 2017 10:53:33 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/92a8ba2d67a1e55374888000108b4e8a/</guid>
      <description> 前言： 项目开发中遇到关于PopupWindow适配性的问题，特别是在华为手机上显示就会出现类似的情况。&#xA;下面这段PopupWindow弹出时背景变暗效果的代码在网上随处可见：&#xA;private void setBackgroundAlpha(float bgAlpha){ WindowManager.LayoutParams layoutParams = MainActivity.this.getWindow().getAttributes(); layoutParams.alpha = bgAlpha; //0.0-1.0 MainActivity.this.getWindow().setAttributes(layoutParams); } 1 2 3 4 5 1 2 3 4 5 解决方法：&#xA;在相关的PopupWindow方法中加入这个方法，问题完美解决。 getWindow().addFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND);//多加这一句，问题就解决了！这句的官方文档解释是：让窗口背景后面的任何东西变暗 1 2 3 1 2 3 private void setBackgroundAlpha(float bgAlpha){ WindowManager.LayoutParams layoutParams = MainActivity.this.getWindow().getAttributes(); layoutParams.alpha = bgAlpha; //0.0-1.0 getWindow().addFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND); MainActivity.this.getWindow().setAttributes(layoutParams); } 控件：自定义popwindow&#xA;机型：mi4&#xA;闪屏事件：拖动popupwindow中的listview时会导致闪屏 闪屏原因：一般而言， GPU 的帧速率应高于刷新率，才不会卡顿或掉帧。如果屏幕刷新率比帧速率还快， 屏幕会在两帧中显示同一个画面，这种断断续续情况持续发生时，用户将会很明显地感觉到动画的卡顿或者掉帧，&#xA;然后又恢复正常，我们常称之为闪屏、跳帧、延迟。&#xA;解决方案：在当前的Activity配置中添加android:hardwareAccelerated=&#34;true&#34;&#xA;注意事项：如果把这句代码放到application中，那么会在三星部分手机上报错&#xA;1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8 </description>
    </item>
    <item>
      <title>Android静态注册的屏幕开启和屏幕关闭的广播捕捉不到的原因</title>
      <link>https://anwangtanmi.github.io/posts/3ee9eda13a3b9e833819e32f3b65570b/</link>
      <pubDate>Sun, 09 Jul 2017 13:53:30 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/3ee9eda13a3b9e833819e32f3b65570b/</guid>
      <description>今天进行了手机屏幕亮屏、暗屏、屏幕开锁、WIFI和移动网络状态改变、开机等广播的功能实现,其中遇到了一个问题，就是无论如何，屏幕亮屏、暗屏的广播都接收不到。这是因为我在AndroidManifest.xml采用了静态 注册的缘故。事实上，对应屏幕亮屏、暗屏的广播，必须通过代码动态注册 才可以获取到广播，这是系统做出的限制。 实例代码见第一代码原创文章http://www.diyidaima.com/article/detail/km3rgm28</description>
    </item>
    <item>
      <title>Android 禁止安装没有授权的第三方应用</title>
      <link>https://anwangtanmi.github.io/posts/80d320e6aee03895668076c1d92bf721/</link>
      <pubDate>Sat, 03 Jun 2017 10:16:35 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/80d320e6aee03895668076c1d92bf721/</guid>
      <description>平时也就只会跑程序，也不知道Android安装程序是个什么原理&#xA;Android应用安装有如下四种方式&#xA;1.系统应用安装――开机时完成，没有安装界面&#xA;2.网络下载应用安装――通过market应用完成，没有安装界面&#xA;3.ADB工具安装――没有安装界面。&#xA;4.第三方应用安装――通过SD卡里的APK文件安装，有安装界面&#xA;应用安装的流程及路径 应用安装涉及到如下几个目录：&#xA;system/app 系统自带的应用程序，无法删除&#xA;data/app 用户程序安装的目录，有删除权限。安装时把apk文件复制到此目录&#xA;data/data 存放应用程序的数据&#xA;data/dalvik-cache 将apk中的dex文件安装到dalvik-cache目录下(dex文件是dalvik虚拟机的可执行文件,其大小约为原始apk文件大小的四分之一)；&#xA;详细介绍第4 种&#xA;apk文件安装，会弹出一个安装界面，其实这是Android调用了另外一个叫PackageInstaller的APP来专门卸载和安装&#xA;apk。这个还真没想到&#xA;首先讲讲他的主界面 PackageInstallActivity&#xA;onCreate() 主要就是解析一大堆的APK信息，来判断有没有错误&#xA;initiateInstall() 检查是否安装过，有没有相同的包名&#xA;startInstallConfirm() 这里面提取权限的信息，并展示权限列表啥的，源码看的也很是头疼。。。点击确认，又到了另外一个类去进行安装的操作了。&#xA;刚开始我的想法就简单了，自己自定义个权限，第三方应用过来了我就检查它的权限列表，没有我定义的权限就不让它走后面安装的步骤，弹出了Dialog警告。&#xA;提取权限列表的代码&#xA;private List getPermissions(PackageInfo pi){&#xA;String[] ps=pi.requestedPermissions;&#xA;if(ps!=null){&#xA;for (String str:ps) {&#xA;Log.e(“AAAAAAAAAAAA”,str);&#xA;}&#xA;return Arrays.asList(ps);&#xA;}&#xA;return null;&#xA;}&#xA;private void showFailDialog(){&#xA;final AlertDialog.Builder builder=new AlertDialog.Builder(this);&#xA;builder.setTitle(“安装提示”)&#xA;.setMessage(“该第三方应用缺少权限：com.example.xiefei.permission,不允许安装”)&#xA;.setCancelable(false)&#xA;.setPositiveButton(“确定”, new DialogInterface.OnClickListener() {&#xA;@Override&#xA;public void onClick(DialogInterface dialogInterface, int i) {</description>
    </item>
    <item>
      <title>解决Android手机USB调试是灰色的问题</title>
      <link>https://anwangtanmi.github.io/posts/3a311c38f35a91ca49576f3b70cb536c/</link>
      <pubDate>Sat, 22 Apr 2017 13:15:36 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/3a311c38f35a91ca49576f3b70cb536c/</guid>
      <description> 手上有一部HTC D820t型号的手机，并且已经开启了开发者选项（这是废话，不然也看不到USB调试），然而USB调试就是灰色的。怎么调怎么选择连接选项都不行，重置手机也不行，后来在网上搜到说需要插入手机SIM才行。&#xA;没有插入SIM卡，手机不让使用 连接方式不对，选为“文件传输” </description>
    </item>
    <item>
      <title>改变Android状态栏字体为黑色</title>
      <link>https://anwangtanmi.github.io/posts/840d312632484d66ca99b2164567261e/</link>
      <pubDate>Wed, 19 Apr 2017 10:47:24 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/840d312632484d66ca99b2164567261e/</guid>
      <description>最近做的这个项目因为标题栏的颜色是一种很浅的颜色,我在开发时也没有关注标题栏字体的颜色.然后昨天UI拿 着手机突然过来找我,说我手机上的标题栏的字体怎么这么浅,我拿过来看了看,原来是她手机标题栏字体的颜色是 白色的,所以基本上看不清,我拿我自己的手机看了看,发现我手机的标题栏字体颜色却是黑色的(我手机是魅族5, 她的是vivo x9),所以我当时就怀疑是不是系统的原因.然后就上网搜了下发现:Android4.4以上系统版本可以修改 状态栏颜色,但是只有小米的MIUI、魅族的Flyme和Android6.0以上系统可以把状态栏文字和图标换成深色,其他 的系统状态栏文字都是白色的，换成浅色背景的话就看不到了.而且魅族设置状态栏图标为深色和魅族特定的文 字风格,Flyme4.0以上;小米的MIUI设置状态栏字体图标为深色,需要MIUIV6以上,最后就找到了下面这篇博客: http://www.jianshu.com/p/7f5a9969be53 他写了一个工具类,下面我就贴出来:&#xA;class StatusBarUtil { /** * 修改状态栏为全透明 * @param activity */ @TargetApi(19) public static void transparencyBar(Activity activity){ if(Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.LOLLIPOP) { Window window = activity.getWindow(); window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE); window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS); window.setStatusBarColor(Color.TRANSPARENT); } else if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.KITKAT) { Window window =activity.getWindow(); window.setFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS, WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); } } /** * 修改状态栏颜色，支持4.4以上版本 * @param activity * @param colorId */ public static void setStatusBarColor(Activity activity,int colorId) { if (Build.</description>
    </item>
    <item>
      <title>性能优化十六之Wake_Lock唤醒锁以及JobScheduler使用</title>
      <link>https://anwangtanmi.github.io/posts/fd0780c8b40ca90d8d767d760ec3d41f/</link>
      <pubDate>Fri, 14 Apr 2017 20:57:05 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/fd0780c8b40ca90d8d767d760ec3d41f/</guid>
      <description>前言 上一篇博客记录了电量优化中的第一种优化，把一些不需要及时和用户交互的一些操作，放到当用户插上电源的时候。根据自己目前的知识了解，只知道三种优化方式，第二种和第三种方式接下来进行介绍。&#xA;第二种方式：网络类型选择优化 目前大部分手机都支持4G网络，殊不知蜂窝移动信号是在所有的网络类型中是最消耗电量的，很多人在使用手机的过程中，发现如果一直在使用4G移动网络，电量会持续不了多久就没电了，而相对来说WIFI会比蜂窝移动信号的电量消耗会小很多，所以我们在开发过程中可以将某些操作放在连接WIFI后进行操作。如何去判读网络类型的代码例子，网上都有。&#xA;第三种方式：wake_lock wakelock是个什么东西呢？查了很多资料了解到它是一个唤醒锁，什么是唤醒锁？它主要是相对系统的休眠而言的，意思就是我的程序给CPU加了这个锁那系统就不会休眠了，这样做的目的是为了全力配合我们程序的运行。有的情况如果不这么做就会出现一些问题，比如微信等及时通讯的心跳包会在熄屏不久后停止网络访问等问题。所以微信里面是有大量使用到了wake_lock锁(可以利用WLD进行测试)。&#xA;使用场景一：保持屏幕常亮 当Android设备空闲时，屏幕会变暗，然后关闭屏幕，最后会停止CPU的运行，这样可以防止电池电量掉的快。在休眠过程中自定义的Timer、Handler、Thread、Service等都会暂停。但有些时候我们需要改变Android系统默认的这种状态：比如玩游戏时我们需要保持屏幕常亮，比如一些下载操作不需要屏幕常亮但需要CPU一直运行直到任务完成。&#xA;1、保持屏幕常亮，最好的方式是在Activity中使用FLAG_KEEP_SCREEN_ON 的Flag。 public class MainActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); } } 优点：这个方法的好处是不像唤醒锁（wake locks），需要一些特定的权限（permission）。并且能正确管理不同app之间的切换，不用担心无用资源的释放问题(唤醒锁如何使用下面介绍)。 注意：一般不需要人为的去掉flag，WindowManager会管理好程序进入后台回到前台的操作。如果确实需要手动清掉常亮的flag，使用 getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON) 2、布局文件中设置屏幕常亮： 另一个方式是在布局文件中使用android:keepScreenOn属性：&#xA;&amp;lt;RelativeLayout xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34; android:layout_width=&#34;match_parent&#34; android:layout_height=&#34;match_parent&#34; android:keepScreenOn=&#34;true&#34;&amp;gt; &amp;lt; /RelativeLayout&amp;gt; android:keepScreenOn = ” true “的作用和FLAG_KEEP_SCREEN_ON一样。但是使用代码的好处是你允许你在需要的地方关闭屏幕。&#xA;使用场景二：保持CPU运行 需要使用PowerManager这个系统服务的唤醒锁(wake locks)特征来保持CPU处于唤醒状态。唤醒锁允许程序控制宿主设备的电量状态。创建和持有唤醒锁对电池的续航有较大的影响，所以，除非是真的需要唤醒锁完成尽可能短的时间在后台完成的任务时才使用它。比如在Acitivity中就没必要用了。如果需要关闭屏幕，使用上述FLAG_KEEP_SCREEN_ON。&#xA;只有一种合理的使用场景，就是在使用后台服务需要在屏幕关闭情况下hold住CPU完成一些工作。这时就需要使用唤醒锁，如果不使用唤醒锁来执行后台服务，当CPU在未来的某个时刻休眠导致某个时刻任务会停止，这是我们不想看到的。 (有的人可能认为我以前写的后台服务运行得挺好的，1.可能是你的任务时间比较短；2.可能CPU被手机里面很多其他的软件一直在唤醒状态。)。下面是很多网友有同样的问题：&#xA;唤醒锁可划分为并识别四种用户唤醒锁：&#xA;标记值 CPU 屏幕 键盘 PARTIAL_WAKE_LOCK 开启 关闭 关闭 SCREEN_DIM_WAKE_LOCK 开启 变暗 关闭 SCREEN_BRIGHT_WAKE_LOCK 开启 变亮 关闭 FULL_WAKE_LOCK 开启 变亮 变亮 请注意，自 API 等级 17 开始，FULL_WAKE_LOCK 将被弃用，应用应使用FLAG_KEEP_SCREEN_ON 使用方法一： 第一步就是添加唤醒锁权限：</description>
    </item>
    <item>
      <title>Android实现暗透明背景的页面</title>
      <link>https://anwangtanmi.github.io/posts/694175d68666c5db68da9b66e5970478/</link>
      <pubDate>Wed, 29 Mar 2017 18:10:15 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/694175d68666c5db68da9b66e5970478/</guid>
      <description> 项目要求做一个对话框样式的页面，仅页面上的文字和按钮可见，背景效果和对话框类似。下面看看怎么实现：&#xA;方案一： 首先实现一个继承自对话框样式的主题：&#xA;@android:color/transparent的值为#00000000。前两个00表示透明度，后6位为RGB值。#00000000表示全透明的黑色。&#xA;然后把这个主题应用到activity：&#xA;&amp;lt;activity android:name=&#34;.activity.TestActivity&#34; android:theme=&#34;@style/DarkTransParent&#34; /&amp;gt; 这个activity不用做别的设置，布局文件里仅包含一个TextView和一个Button。 如果在布局文件里给它们设置了背景色，则背景色也会显示出来。&#xA;效果如下： 但是这个方法有缺点： 1. 页面布局会被自动调整，不易控制。 2. 背景的暗色不好改。&#xA;所以尝试了一种新的方案：&#xA;方案二： 继承系统的透明主题，然后自定义windowBackground属性：&#xA;&amp;lt;style name=&#34;DarkTransParent&#34; parent=&#34;android:style/Theme.Translucent&#34;&amp;gt; &amp;lt;item name=&#34;android:windowBackground&#34;&amp;gt;@color/lock_bg style&amp;gt; 看下Theme.Translucent的定义：&#xA;然后，lock_bg即为我们想要设置的背景的颜色，我们可以在colors.xml中自定义其值：&#xA;&amp;lt;color name=&#34;lock_bg&#34;&amp;gt;#cc000000 然后把这个主题应用到activity即可：&#xA;&amp;lt;activity android:name=&#34;.activity.TestActivity&#34; android:theme=&#34;@style/DarkTransParent&#34; /&amp;gt; </description>
    </item>
    <item>
      <title>Glide结合高斯模糊使用</title>
      <link>https://anwangtanmi.github.io/posts/0d2aef44cb077dd318b5123228326d16/</link>
      <pubDate>Mon, 20 Mar 2017 15:42:01 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/0d2aef44cb077dd318b5123228326d16/</guid>
      <description>最近在做毕业设计，想做一个跟网易音乐播放界面差不多的，在做到播放详情界面的时候用到Glide加载网络图片作为整个布局的背景，但是背景太明显反而显得不好看，上网查了查，找到了高斯模糊感觉还行，接下来我就说一下使用流程。&#xA;第一步肯定是在build中加入依赖库&#xA;//加载图片 compile &#39;com.github.bumptech.glide:glide:3.7.0&#39; //高斯模糊 compile &#39;jp.wasabeef:glide-transformations:2.0.1&#39; transformations库里面还有好多其他转换形式，具体github地址glide转换库&#xA;第二步 加载一张图片的话比较简单，Gilde做的非常好了，不会的自己去搜。&#xA;//加载背景，也是加载专辑封面 Glide.with(MusicPlayerActivity.this) .load(service.getImageUri()) .dontAnimate() .error(R.drawable.no_music_rotate_img) .into(allBg); 第三部就是在上面代码中加一句话就可以了。&#xA;// &#34;14&#34;:模糊度；&#34;3&#34;:图片缩放3倍后再进行模糊，缩放3-5倍个人感觉比较好。 .bitmapTransform(new BlurTransformation(this, 14, 3)) 完整的代码&#xA;//加载背景， Glide.with(MusicPlayerActivity.this) .load(service.getImageUri()) .dontAnimate() .error(R.drawable.no_music_rotate_img) // 设置高斯模糊 .bitmapTransform(new BlurTransformation(this, 14, 3)) .into(allBg); 完整代码点这里 在MusicPlayerActivity中使用到</description>
    </item>
    <item>
      <title>Deeplink:web唤醒app</title>
      <link>https://anwangtanmi.github.io/posts/23263d434ca5e45d828ec9b1aa29208e/</link>
      <pubDate>Fri, 10 Mar 2017 15:40:31 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/23263d434ca5e45d828ec9b1aa29208e/</guid>
      <description>在Android平台URI主要分五个部分：scheme, authority, path, queryParameter, queryString。其中authority又分为host和port。格式如下：(url的所有字母命名只能为小写) scheme://host:port/path?qureyParameter=queryString 例如：myscheme://www.febmaple.com:80/mypath?key=mykey&#xA;在Android的Manifest配置文件中，在要启动的activity下配置项中有配置。 其中包含内容有:&#xA;&amp;lt;data android:host=&#34;&#34; android:mimeType=&#34;&#34; android:path=&#34;&#34; android:pathPattern=&#34;&#34; android:pathPrefix=&#34;&#34; android:port=&#34;&#34; android:scheme=&#34;&#34; android:ssp=&#34;&#34; android:sspPattern=&#34;&#34; android:sspPrefix=&#34;&#34;/&amp;gt; 1、web端html里写入 Click 2、android端在menifest的响应activity的intentfilter下配置,一般只需配置scheme和host即可。 3、这样手机系统自带浏览器碰到不能处理的scheme之后会发送intent给能处理的应用，因为我们的app可以处理该scheme，所以我的app得到启动。（ps：如果用webview加载html，webview碰到处理不了的scheme并不会发送intent找app处理，而系统自带浏览器是可以的，当然我们的需求就是用系统自带浏览器触发）。&#xA;Show u my code:&#xA;一、跳到app首页：新建一个app工程用webview加载所写的html，用以触发目标app。（实际需求是直接在系统浏览器里触发目标app） 1、建立html放到工程的main/assets目录下&#xA;&amp;lt;/span&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;Test Schemeh1&amp;gt; &amp;lt;a href=&#34;myscheme://www.febmaple.com:80/mypath?key=mykey&#34;&amp;gt;Clicka&amp;gt; body&amp;gt; html&amp;gt; 2、webview加载本地html内容来触发目标app&#xA;wvUrl.loadUrl(&#34;file:///android_asset/test.html&#34;); 3、在app manifeset的**欢迎**activity添加intent-filter配置data标签.&#xA;&amp;lt;activity android:name=&#34;.ui.launching.DemoLaunchingActivity&#34; android:screenOrientation=&#34;portrait&#34;&amp;gt; &amp;lt;intent-filter&amp;gt; &amp;lt;action android:name=&#34;android.intent.action.MAIN&#34;/&amp;gt; &amp;lt;category android:name=&#34;android.intent.category.LAUNCHER&#34;/&amp;gt; intent-filter&amp;gt; &amp;lt;intent-filter&amp;gt; &amp;lt;action android:name=&#34;android.intent.action.VIEW&#34;/&amp;gt; &amp;lt;category android:name=&#34;android.intent.category.DEFAULT&#34;/&amp;gt; &amp;lt;category android:name=&#34;android.intent.category.BROWSABLE&#34;/&amp;gt; &amp;lt;data android:scheme=&#34;myscheme&#34;/&amp;gt; intent-filter&amp;gt; activity&amp;gt; 4、在配置好的Activity里即可获取外部跳转的参数信息。&#xA;@Override protected void onCreate(Bundle savedInstanceState) { super.</description>
    </item>
    <item>
      <title>沉浸式状态栏（修改状态栏）颜色的简单实现</title>
      <link>https://anwangtanmi.github.io/posts/eee29c95d8a59bd51fc2b1974da0367c/</link>
      <pubDate>Fri, 03 Mar 2017 16:59:38 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/eee29c95d8a59bd51fc2b1974da0367c/</guid>
      <description>Google 推出MaterialDesign后，可以说极大的美化了Android的UI，开发者只需按照MaterialDesign的相关标准就能设计出炫酷的界面。&#xA;自从5.0推出后，Android就开始支持修改状态栏的颜色，从QQ、网易云音乐等主流的App都可以看到这一特性使得Android界面更加一体化。&#xA;网络上关于修改状态栏的方法更多，也有很多开源库，今天讲一种简单的实现方式。&#xA;1、在Java代码中设置状态栏为透明&#xA;if (Build.VERSION.SDK_INT &amp;gt;= 21) { View decorView = getWindow().getDecorView(); int option = View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE; decorView.setSystemUiVisibility(option); getWindow().setStatusBarColor(Color.TRANSPARENT); } 2、在布局文件中添加下面的属性：android:paddingTop=”28dp”，笔者经测试，28dp是比较合适的，大家也可以根据需要调整。&#xA;...... 下面是效果图：</description>
    </item>
    <item>
      <title>解决ProGuard混淆代码时出现的java.lang.NoSuchFieldException: xxx…异常</title>
      <link>https://anwangtanmi.github.io/posts/f498d5e1258fe7d3cb4f34228a6a3c28/</link>
      <pubDate>Sat, 21 Jan 2017 15:23:12 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/f498d5e1258fe7d3cb4f34228a6a3c28/</guid>
      <description>用Android Studio写小Demo的时候，由于需要混淆代码，所以把build.gradle文件里的minifyEnabled false改成了true。&#xA;然后编译成release发布版本，就会发现apk包小了不少，说明混淆成功。&#xA;这对一般的小项目倒是没什么影响，混淆后程序运行仍然正常，但如果用到了Java的反射机制，就没那么轻松了。&#xA;下面是我程序中的一段代码：&#xA;Class&amp;lt;RecyclerView&amp;gt; recyclerViewClass = RecyclerView.class; try { Field declaredField = recyclerViewClass.getDeclaredField(&#34;mRecycler&#34;); declaredField.setAccessible(true); Method declaredMethod = Class.forName(RecyclerView.Recycler.class.getName()).getDeclaredMethod(&#34;clear&#34;); declaredMethod.setAccessible(true); declaredMethod.invoke(declaredField.get(activeRecyclerView)); RecyclerView.RecycledViewPool recycledViewPool = activeRecyclerView.getRecycledViewPool(); recycledViewPool.clear(); } catch (Exception e) { e.printStackTrace(); } 在Build时就会报类似下面的错：&#xA;java.lang.NoSuchFieldException: No field mRecycler in class&#xA;Landroid/support/v7/widget/RecyclerView; (declaration of&#xA;‘android.support.v7.widget.RecyclerView’ appears in&#xA;/data/app/com.xxx……&#xA;还有：&#xA;java.lang.NoSuchMethodException: clear []&#xA;报错提示找不到相应的域和方法。&#xA;看最开始的代码我们知道用到了反射，大致的原理是根据字符串去寻找方法，然而代码经过ProGuard混淆后一些方法名都变成了无意义的短字符了（比如a、b、c这种），&#xA;但是经过反编译可以发现，代码中的字符串是不会被混淆修改的。&#xA;所以程序运行时就无法映射到相应的方法了。&#xA;解决办法：&#xA;ProGuard官方文档也是建议了大家不要混淆反射所涉及的类方法，因此我们需要自定义配置项目中的proguard-rules.pro文件。&#xA;第一个报错解决办法就是保留RecyclerView类不被混淆即可，文件中添加：&#xA;-keep class android.support.v7.widget.RecyclerView {*;} 第二个报错，阅读了很多文档，我做了很多尝试，由于技艺不精，还是无法通过配置rules文件来消除混淆对clear()方法的影响，反编译代码后我发现clear()方法名还是被混淆改成了a()。&#xA;最后我就干脆把最开始原始代码里的字符串“clear”改成了“a”，然后成功消除报错。&#xA;其实这不是很好的解决办法，因为你需要得知相应的方法名被混淆成了什么，而且修改项目源代码去应付混淆也非上策，如果有大神知道如何配置rules文件来保证反射的正常运行，欢迎评论留言，交流指点。&#xA;（这里可以通过查看项目下面的 \build\outputs\mapping\release\mapping.txt 映射文件去查看相应的方法名被混淆成了什么，或者简单粗暴一点的，直接查看反编译apk后的代码也能得知）</description>
    </item>
    <item>
      <title>百度地图开发时：只显示灰色的网格而不显示具体地图信息的解决办法</title>
      <link>https://anwangtanmi.github.io/posts/2850b5fb87eb5e09a454ddce2725615f/</link>
      <pubDate>Fri, 06 Jan 2017 15:55:09 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/2850b5fb87eb5e09a454ddce2725615f/</guid>
      <description>最近在开发百度地图时遇到只显示灰色的框框，不显示具体的地图信息：&#xA;查阅资料后，自己的解决办法是：&#xA;1、百度地图API key的申请&#xA;在申请key的时候需要注意的是安全码的设置，安全码的组成为：数字签名+;+包名，其中数字签名不是随便给出就行的，获取数字签名的方法：&#xA;方法一：如果使用adt 22，可以在eclipse中直接查看：winows -&amp;gt; preferance -&amp;gt; Android -&amp;gt; build，然后在该页面中有个SHA1 fingerprint值，这个值就是上面的数字签名；&#xA;方法二：如果使用的是adt21及以下的，可以在default debug keystore项目里找到该文件，然后运行cmd命令:&#xA;keytool -list -v -keystoreC:Usersuser.androiddebug.keystore&#xA;然后输入密码，这里密码一般为空，直接按回车就行。即可看到sha1码！&#xA;包名可以是你任意给出的包名（但是你一定要记者这个包名），在新建功能的时候，自己创建的工程包名就必须和这个包名一致了。也就是说该key只能在该包位置下使用。（PS：在不同的工程下如果给出相同的包名，这种情况我就没有试验了，但是我想应该也是可以的，因为在申请key的时候只给定了包名，而没有限定你的项目工程名）&#xA;1、创建工程工程部分目录如下：&#xA;如图中包名和上面百度key值申请时候所定义的包名一致。另外，有些人新建了工程后，刚开始建的包名和百度key申请时的包名不一致的时候，有些人将包名改过来，但是却忘记了一件事，那就是AndroidManifest.xml文件中还有个需要改的地方，如图：要将该包名同样修改一下。&#xA;到此，问题应该可以解决</description>
    </item>
    <item>
      <title>SystemUI状态条下拉视图显示过程</title>
      <link>https://anwangtanmi.github.io/posts/f99a8e15572f34f40747b9290ed0b914/</link>
      <pubDate>Thu, 05 Jan 2017 08:45:56 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/f99a8e15572f34f40747b9290ed0b914/</guid>
      <description>super_status_bar.xml中的brightness_mirror是状态条上面亮度调节的控件。panel_holder是下面包括所有控件的一个容器。在status_bar_expanded_header.xml中system_icons_super_container为状态条下拉时候显示的顶层布局。split_clock_view.xml用来绘制下拉菜单左边的时间日期。状态条控件的显示是用的PanelBar.java。 顶上的状态条被下拉首先被处理的是触摸事件，也就是PhoneStatusBar里面的interceptTouchEvent函数，当状态条被下拉出来之后就会执行PanelBar里面的onTouchEvent函数，它会根据触摸的位置选择被触摸的panel，然后执行startOpeningPanel()就是用来初始化panel的状态，调用除NotificationPanelView以外其他视图的collapse函数，然后调用被触摸panel的onTouchEvent函数里面的ACTION_MOVE分支，执行setExpandedHeightInternal根据手指移动的距离刷新panel的高度并更新状态条的状态指示当前被扩展的状态，如果被完全下拉下来，则不会在更新状态条视图，否则不断调用NotificationPanelView里面的onHeightUpdated函数来更新该状态条的里面的内容。因此在PhoneStatusBar里面的onInterceptKeyEvent中的最后加入if(SystemProperties.get(“persist.sys.sysui.config”)){return true;}使得状态条不能被下拉下来。setprop persist.sys.sysui.config命令需要被写入init.rc文件里面，该文件会被编译成boot.img，所以要替换掉boot.img，之后在使用setprop命令就会在data/local目录下生成该 persist.sys.sysui.config目录，所以重启之后该属性值还生效。//1612001724 yah1826</description>
    </item>
    <item>
      <title>Android简单联网获取网页</title>
      <link>https://anwangtanmi.github.io/posts/4f2794d0376c19e7d507b2eac04e1a06/</link>
      <pubDate>Thu, 22 Dec 2016 13:05:35 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/4f2794d0376c19e7d507b2eac04e1a06/</guid>
      <description>一门语言，联网编程都是非常重要，所以我们来简单的实现以下android开发如何写联网程序。&#xA;Http请求分为：&#xA;GET:明文传参，在地址栏上可以看到参数，调用简单没，不安全。 POST:暗文传参，在地址栏上看不到参数，调用稍微复杂，安全。 android上发送Http请求的方式有两种：&#xA;HttpURLConnection类:是java的标准指定网站发送GET请求、POST请求类，使用相对简单，并且易于扩展，推荐使用。 HttpClient类:是android SDK提供的请求方式，对HTTP协议全面支持，但是在android6.0（API23）中，Google已经移除了该相关的类，因此不在赘述使用该类的使用。&#xA;这次我们使用GET方式进行获取数据，步骤:&#xA;1.创建URL对象。 2.通过 URL对象调用openConnection(）方法获取HttpURLConnection对象。 3.设置相关属性。 4.HttpURLConnection对象通过getInputStream()方法获得输入流。 5.读取输入流，转成字符串。&#xA;效果图： **其实很简单，列举一个例子： 假如从水库引水，首先要找到水库的位置，第二步将水引到工厂后建立一个阀门来控制水，第三步建立水道将水引到蓄水池，在水道口放上网来过滤鱼虾蟹，然后用小水桶把渔网的鱼一点一点的捞起来放到大水桶，最后晒网。**&#xA;代码演示：&#xA;布局文件：&#xA;&amp;lt;RelativeLayout xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34; xmlns:tools=&#34;http://schemas.android.com/tools&#34; android:layout_width=&#34;match_parent&#34; android:layout_height=&#34;match_parent&#34; android:paddingBottom=&#34;@dimen/activity_vertical_margin&#34; android:paddingLeft=&#34;@dimen/activity_horizontal_margin&#34; android:paddingRight=&#34;@dimen/activity_horizontal_margin&#34; android:paddingTop=&#34;@dimen/activity_vertical_margin&#34; tools:context=&#34;com.example.httpdemo.MainActivity&#34; &amp;gt; &amp;lt;Button android:id=&#34;@+id/a12&#34; android:layout_width=&#34;match_parent&#34; android:layout_height=&#34;wrap_content&#34; android:text=&#34;获取&#34; android:onClick=&#34;aaa&#34; /&amp;gt; &amp;lt;ScrollView android:layout_below=&#34;@id/a12&#34; android:layout_width=&#34;match_parent&#34; android:layout_height=&#34;match_parent&#34; &amp;gt; &amp;lt;TextView android:id=&#34;@+id/a&#34; android:layout_width=&#34;wrap_content&#34; android:layout_height=&#34;wrap_content&#34; android:text=&#34;@string/hello_world&#34; /&amp;gt; ScrollView&amp;gt; RelativeLayout&amp;gt; MainActivity：&#xA;package com.example.httpdemo; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.net.HttpURLConnection; import java.net.MalformedURLException; import java.net.URL; import android.</description>
    </item>
    <item>
      <title>【Android休眠】之Android休眠机制</title>
      <link>https://anwangtanmi.github.io/posts/eacf88530b53126934bba7c580bf7c71/</link>
      <pubDate>Wed, 14 Dec 2016 21:42:13 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/eacf88530b53126934bba7c580bf7c71/</guid>
      <description>http://blog.csdn.net/u013686019/article/details/53645646&#xA;一、休眠概述 休眠，简而言之就是设备在不需要工作的时候把一些部件、外设关掉(掉电或让它进入低功耗模式)。&#xA;为什么要休眠呢？一言以蔽之：省电。&#xA;休眠分主动休眠和被动休眠。主动休眠：比如我电脑不用了，就通过设置让系统进入休眠模式；被动休眠：系统检测到自己闲的慌，为了节约故，自己就休眠去了。&#xA;废话不叙。&#xA;二、Android休眠 休眠是内核的核心工作，而Android是基于Linux内核的，所以Android休眠和内核有着千丝万缕的联系；由于Android的特殊应用场景：移动设备，所以Android休眠和内核又有着特别的需求。&#xA;1、联系： Android设备停止使用，系统没有什么事情可做，进入休眠状态的功能最终是由内核去实现的；每一类硬件都有自己的驱动，具体的驱动决定怎么进入休眠以及处于何种层次的休眠。比如：对于platform_device，就按照platform_driver定义的规则，在suspend调用的时候，去做上面提到的事情：&#xA;struct platform_driver { int (*probe)(struct platform_device *); int (*remove)(struct platform_device *); void (*shutdown)(struct platform_device *); int (*suspend)(struct platform_device *, pm_message_t state); int (*resume)(struct platform_device *); struct device_driver driver; const struct platform_device_id *id_table; }; 2、Android的特别需求： 比如对于自己的电脑，不用让它休眠好了；但是对于我们形影不离的手机，在休眠的时候还要睁一只眼：来电了要通知你，QQ啊微信啊什么的由信息了也要通知你，所以Android在Linux内核休眠机制之上，提出了“Opportunistic Suspend”。&#xA;三、休眠实践 絮絮叨叨这么多，下面让我们切切实实体验下休眠。&#xA;1、休眠模式 休眠是分好几种模式的，不同模式实现方式、耗电量不同，以下来自Documentation/power/states.txt：&#xA;The kernel supports four power management states generically, though one is generic and the other three are dependent on platform support code to implement the low-level details for each state.</description>
    </item>
    <item>
      <title>Error:Execution failed for task ‘:app:clean’. &gt; Unable to delete directory: E:\Work\Testjni\app\buil</title>
      <link>https://anwangtanmi.github.io/posts/c744c7419bceb3e7a25a57312cac2186/</link>
      <pubDate>Thu, 20 Oct 2016 09:30:54 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/c744c7419bceb3e7a25a57312cac2186/</guid>
      <description>解决方法一：&#xA;进入File&amp;gt; Settings&amp;gt; Build,Execution,Deployment&amp;gt; Instant Run &amp;gt;取消选择(Enable Instant Run to hot swap code)&#xA;解决方法二：&#xA;打开下面的Terminal 输入gradlew clean：&#xA;解决方法三：&#xA;关掉 Android studio ,去相应的目录下删除文件</description>
    </item>
    <item>
      <title>【Android】设定主题的背景样式，android:windowBackground。</title>
      <link>https://anwangtanmi.github.io/posts/a02c4fe9e6c144e1ae0262bbfe1eb159/</link>
      <pubDate>Fri, 09 Sep 2016 10:47:52 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/a02c4fe9e6c144e1ae0262bbfe1eb159/</guid>
      <description> &amp;lt;style name=&#34;SplashScreenAppTheme&#34; parent=&#34;AppTheme&#34;&amp;gt; &amp;lt;item name=&#34;android:windowFullscreen&#34;&amp;gt;trueitem&amp;gt; &amp;lt;item name=&#34;android:windowContentOverlay&#34;&amp;gt;@null &#34;android:windowBackground&#34;&amp;gt;@color/bg_white style&amp;gt; </description>
    </item>
    <item>
      <title>Android Zxing 扫描器 扫描框、扫描线定制样式</title>
      <link>https://anwangtanmi.github.io/posts/4c065a57e3aa9340c8990cf3738e15b4/</link>
      <pubDate>Fri, 08 Jul 2016 10:59:04 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/4c065a57e3aa9340c8990cf3738e15b4/</guid>
      <description>###一、概述&#xA;相信Adnroid开发都知道，世界上有四款扫描器，Zxing 、Zbar ，Barcode4J、OkapiBarcode 前二者应用较广泛，至于介绍与区别就在此阐述，网上有很多。此文主要介绍在在使用过程中，官方客户端各种达不到需求。相信很多童鞋都有此体会，所以借此机会就在Zxing 官方客户端基础上修改，去除无用功能并二次封装达到可扩展。&#xA;官方客户端目前问题汇总 设置功能多余 竖屏后不能正向扫描条形码 扫描框大小、颜色、扫描线配置不够灵活 无生成二维码、主动识别二维码功能 介于以上问题，于是该库就华丽的诞生 修复竖屏不能正向扫描条形码 可定制扫描框与扫描线样式 加入创建二维码、识别图片中的二维码功能 ###二、效果图&#xA;本库地址：https://github.com/mylhyl/Android-Zxing&#xA;###三、代码说明&#xA;Zxing 核心代码 https://github.com/zxing/zxing/tree/master/core 不作任何修改也不需要修改，只管用就行主要修改客户端代码。你可以自己编译成 jar 或者直接下源码拷到工程，可以参考Zxing编译。也可以到github下载本库，利用gradle编译 如下图双击 makeJar&#xA;等待控制出现 BUILD SUCCESSFUL 即编译完成，zxing 工程目录build将出libs目录&#xA;精简后的代码，去掉资源文件、扫描历史记录、分享等，目录结构如下&#xA;camera 摄像头相关 common 全局静态常量相关 decode 解析二维码相关 encode 生成二维码相关 OnScannerCompletionListener 扫描成功接口 ViewfinderView 扫描预览视图 ScannerView 新增自定义View，包括 ViewfinderView 、SurfaceView，公开一些样式设置方法，具体使用后面介绍 样式定义上来说，其实就在darw方法中，与平时自定义View一样，废话不多说来看一下干货 定义所用的变量&#xA;private int laserColor = Scanner.color.VIEWFINDER_LASER;//扫描线颜色 private int laserFrameBoundColor = laserColor;//扫描框4角颜色 private int laserLineTop;// 扫描线最顶端位置 private int laserLineHeight;//扫描线默认高度 private int laserMoveSpeed;// 扫描线默认移动距离px private int laserFrameCornerWidth;//扫描框4角宽 private int laserFrameCornerLength;//扫描框4角高 private int laserLineResId;//扫描线图片资源 private String drawText = &#34;</description>
    </item>
    <item>
      <title>retrofit2&#43;Executors&#43;DiskLruCache 2秒加载100张图片从此告别OOM的困扰</title>
      <link>https://anwangtanmi.github.io/posts/06307dd30cd9834b093e926cacf9d7e2/</link>
      <pubDate>Thu, 02 Jun 2016 17:35:39 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/06307dd30cd9834b093e926cacf9d7e2/</guid>
      <description>人生的旅途，前途很远，也很暗。然而不要怕，不怕的人的面前才有路。——鲁迅&#xA;自从上一篇博客发布后，已经有很长时间没有更新博客了，一直忙着支付通的事情，在此给大家道个歉。&#xA;先贴个图：&#xA;你不要惊讶，这就是第一次从网络获取图片的速度，感觉比本地读取图片的速度还要快吧。加载100张图片真的只要2秒时间，你不要不相信，不信你就来看。&#xA;一、概述 在众多的app当中，缓存可以作为衡量一款产品的好坏，既能节省流量，减少电量消耗，最重要的是用户体验好。你想想一款产品每个月消耗你100M以上的流量，你愿意用吗？当然这里除了游戏以外。那么怎么才能做好缓存呢？这里要介绍两个重要的概念，一个是内存缓存LruCache，一个是硬盘缓存DiskLruCache，大家对这两个概念肯定不会陌生，如果你还不了解的话请链接郭神的Android DiskLruCache完全解析，硬盘缓存的最佳方案 真心写的很棒。从标题中就可以看出今天还有一个主角就是线程池这个概念我很久以前都听说过了，但没具体去研究过，我也只会使用它。&#xA;相关文章请链接一下地址：&#xA;Retrofit2与RxJava用法解析&#xA;android中对线程池的理解与使用&#xA;Android DiskLruCache完全解析，硬盘缓存的最佳方案&#xA;二、Executors初探线程池 Android常用的线程池有以下几种，在Executors里面对应的方法：&#xA;newFixedThreadPool 每次执行限定个数个任务的线程池 newCachedThreadPool 所有任务都一次性开始的线程池 newSingleThreadExecutor 每次只执行一个任务的线程池 newScheduledThreadPool 创建一个可在指定时间里执行任务的线程池，亦可重复执行 获取实例：&#xA;Executors.newSingleThreadExecutor();// 每次只执行一个线程任务的线程池 Executors.newFixedThreadPool(3);// 限制线程池大小为3的线程池 Executors.newCachedThreadPool(); // 一个没有限制最大线程数的线程池 Executors.newScheduledThreadPool(3);// 一个可以按指定时间可周期性的执行的线程池 我们来看看下面这个例子：&#xA;new Thread(new Runnable() { @Override public void run() { } }).start(); 在功能上等价于：&#xA;mMyHandler.post(new Runnable() { @Override public void run() { } }); 还等价于：&#xA;executors.execute(new Runnable() { @Override public void run() { } }); 我们为啥要使用ExecutorService呢，而不使用Thread和Handler？使用线程池我觉得可以对我们开启的线程进行跟进，可以复用这点很重要，能够减少内存消耗，当然也可以指定个数来执行任务的线程池、创建一个可在指定时间里执行任务的线程池。&#xA;线程池使用</description>
    </item>
    <item>
      <title>android 中style的使用</title>
      <link>https://anwangtanmi.github.io/posts/bf40c374145645f4477fa28ac9bc5def/</link>
      <pubDate>Wed, 27 Apr 2016 17:59:35 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/bf40c374145645f4477fa28ac9bc5def/</guid>
      <description>Android的Styles(样式)和Themes(主题)非常类似Web开发里的CSS，方便开发者将页面内容和布局呈现分开。Style和Theme在Android里的定义方式是完全一样的，两者只是概念上的区别：Style作用在单个视图或控件上，而Theme用于Activity或整个应用程序。由于作用范围的不同，Theme也就需要比Style包含更多的定义属性值的项目(item)。不过本文，我将Style和Theme都归为Style来称呼。&#xA;Android的Style和Web的CSS相比，有一个缺陷就是只能针对一个对象只能通过android:theme=&#34;@style/AppTheme&#34;或style=&#34;@style/MyStyle&#34;指定一个值。而CSS则可以通过class属性在DOM元素上定义多个样式来达到组合的效果。不过Style也有CSS没有的功能，那就是继承(Inheritance)。(当然CSS通过LESS和SASS这些工具也获得继承的能力。)&#xA;Style继承简介 根据Android Developers官方文档的介绍，定义Style的继承有两种方式：一是通过parent标志父Style；&#xA;Java &lt;style name=&#34;”GreenText”&#34; parent=&#34;”@android:style/TextAppearance”&#34;&gt;&#xA;&lt;item name=”android:textColor”&gt;#00FF00&lt;/item&gt;&#xA;1 2 3 另一种则是将父Style的名字作为前缀，然后通过“.”连接新定义Style的名字：&#xA;Java &lt;style name=&#34;”CodeFont.Red”&#34;&gt;&#xA;&lt;item name=”android:textColor”&gt;#FF0000&lt;/item&gt;&#xA;1 2 3 第二种方式可以无限连接子Style来实践多层继承：&#xA;Java &lt;style name=&#34;”CodeFont.Red.Big”&#34;&gt;&#xA;&lt;item name=”android:textSize”&gt;30sp&lt;/item&gt;&#xA;1 2 3 相对第一种，Android对第二种方式做出的限制就是Style必须是由自己定义的，或者说父Style和子Style必须是定义在同一个程序内，不能是引用第三方或系统的Style。毕竟对于系统的Style的引用是需要加上android:前缀作为命名空间。&#xA;其次在使用Style时，对于第二种方式定义的Style，必须引用其完全的名字，也就是说必须要包含完整的前缀和名字：&#xA;Java &lt;edittext&gt; style=”@style/CodeFont.Red.Big”&#xA;… /&amp;gt; 1 2 3 &amp;lt;&#xA;EditText style&#xA;=&#xA;“@style/CodeFont.Red.Big” .&#xA;.&#xA;.&#xA;/&#xA;&amp;gt; Android对于第一种定义方式并没用限制，所以所有以第二种方式定义的Style都可以转用第一种：&#xA;Java &lt;style name=&#34;”Big”&#34; parent=&#34;”CodeFont.Red”&#34;&gt;&#xA;&lt;item name=”android:textSize”&gt;30sp&lt;/item&gt;&#xA;1 2 3 只要parent中的名字对应上实际定义的Style名字即可。不过换成第一种后Style的名字如果太简洁就容易冲突了。&#xA;两种继承方式混合的效果 前面说到Style的两种继承方式的效果是一致的，那假如将两种方式混在一起定义一个Style又会是什么样的效果呢？下边就用实际例子来分析一下。&#xA;首先定义一些实验所需的自定义属性(attr)，（这样可以减少系统属性的干扰，因为系统总是会为它的属性定义值，那样可能无法分辨最后的效果是来自系统还是定义的值）&#xA;Java &lt;?xml version=”1.0″ encoding=”utf-8″?</description>
    </item>
    <item>
      <title>Android中显示PNG图标背景变黑色</title>
      <link>https://anwangtanmi.github.io/posts/21fccbc3e4ff025ade6066a052e25d40/</link>
      <pubDate>Wed, 27 Apr 2016 11:26:32 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/21fccbc3e4ff025ade6066a052e25d40/</guid>
      <description>最近项目中遇到一个问题：就是从网络获取应用PNG图标后，显示到GridView中，发现图标透明的地方都变成了黑色？为什么呢？&#xA;个人习惯有问题先梳理一遍代码：&#xA;一、从网络异步下载图标并显示代码&#xA;class IconAsyncTask extends AsyncTask { private AdsInfo tAdsInfo; private ImageView tAppIcon; public IconAsyncTask(ImageView appIcon, AdsInfo adsInfo) { // TODO Auto-generated constructor stub tAppIcon = appIcon; tAdsInfo = adsInfo; } @Override protected Bitmap doInBackground(String... params) { // TODO Auto-generated method stub Bitmap icon = getBitmapFromURL(params[0]); try { FileUtil.writeImgFile(icon, getIconPath(tAdsInfo.id)); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } return icon; } @Override protected void onPostExecute(Bitmap result) { // TODO Auto-generated method stub if (tAppIcon.</description>
    </item>
    <item>
      <title>android自定义view-强大的点击灰色背景imageview</title>
      <link>https://anwangtanmi.github.io/posts/7b2e120739a302d3d9ab04653d0fa994/</link>
      <pubDate>Wed, 20 Apr 2016 13:51:09 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/7b2e120739a302d3d9ab04653d0fa994/</guid>
      <description>前言：&#xA;微信作为很火的社交平台广受大众推崇，作为开发者不仅要学会使用软件，更重要的是要琢磨那些吸引人的控件的研发思路。刷了好久的朋友圈，作为一个安卓开发者来说，朋友圈九宫格的图片显示，以及点击图片会有灰色蒙板的效果吸引了我，为了方便大家，也为了给自己温习知识，写下这篇博文。&#xA;效果图：&#xA;就是这样的效果!&#xA;正文:&#xA;今天我们就来实现这样的一个效果，在我们动笔写代码之前，我们必须要理清自己的思路，不能一开始就盲目的去写代码，磨刀不误砍柴工。我们唯一能够确定的是，继承自imageview。然后呢？然后重写构造方法，由于用到了点击，所以还要去手动处理一下onTouchEvent方法。看似困难的问题处理起来也会游刃有余了。想法都是对的，其实我们还少分析一个问题，图片会分为本地和远程两种形式，这样的图片如何去加一个灰色的蒙板，远程图片又如何加载呢？带着这些个问题，我们来一一探寻答案。&#xA;思考一：继承ImageView&#xA;public class GrayScaleImageView extends ImageView 思考二：重写构造方法&#xA;public GrayScaleImageView(Context context) { super(context); } public GrayScaleImageView(Context context, AttributeSet attrs) { super(context, attrs); } public GrayScaleImageView(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); } 我没有进行一些初始化操作，因为这里还没有什么需要初始化。 思考三：处理onTouchEvent事件&#xA;@Override public boolean onTouchEvent(MotionEvent event) { Drawable drawable = getDrawable(); switch (event.getAction()) { case MotionEvent.ACTION_DOWN: if (drawable != null) { // drawable.mutate使得此drawable共享状态，改变时全部改变 drawable.mutate().setColorFilter(Color.GRAY, PorterDuff.Mode.MULTIPLY); } break; case MotionEvent.</description>
    </item>
    <item>
      <title>android ImageView亮度变化</title>
      <link>https://anwangtanmi.github.io/posts/d3f938d658b37a358d3f75a8f6c86229/</link>
      <pubDate>Tue, 19 Apr 2016 17:12:19 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/d3f938d658b37a358d3f75a8f6c86229/</guid>
      <description>1.较好的办法（特别适用于亮度渐变效果）：&#xA;//改变图片的亮度方法 0--原样 &amp;gt;0---调亮 &amp;lt;0---调暗 private void changeLight(ImageView imageView, int brightness) { ColorMatrix cMatrix = new ColorMatrix(); cMatrix.set(new float[] { 1, 0, 0, 0, brightness, 0, 1, 0, 0, brightness, // 改变亮度 0, 0, 1, 0, brightness, 0, 0, 0, 1, 0 }); imageView.setColorFilter(new ColorMatrixColorFilter(cMatrix)); } 引用自：&#xA;http://www.jb51.net/article/78163.htm&#xA;2.另一种方法：&#xA;/** * 设置滤镜 */ private void setFilter(ImageView imageView) { //先获取设置的src图片 Drawable drawable=imageView.getDrawable(); //当src图片为Null，获取背景图片 if (drawable==null) { drawable=getBackground(); } if(drawable!=null){ //设置滤镜 drawable.</description>
    </item>
    <item>
      <title>android的 deeplink与服务路由的思考</title>
      <link>https://anwangtanmi.github.io/posts/3d5667b94c454b26421fe58fab9b645e/</link>
      <pubDate>Sat, 02 Apr 2016 19:42:23 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/3d5667b94c454b26421fe58fab9b645e/</guid>
      <description>deep link 1.deep link 应用间的深度链接 分发 传播 和检测 url scheme 服务路由 上下文还原 唤醒优化 （突破微信的限制） 一种是跳转应用市场 另一种是web页面&#xA;场景还原 android app links iOS9 universailink 对服务发现 服务的参数化 服务网关（后台切换） 服务检测 曝光 点击 安装 转化 让自己的应用被第三方应用发现和打开应用 协议标准 app的场景网络化 魔窗&#xA;3.android网络请求volly框架&#xA;compile ‘com.mcxiaoke.volley:library:1.0.15’&#xA;依赖extental library 1.0.15 volly 网络请求框架&#xA;只需要修改build.grade的dependencies修改依赖就可以了&#xA;3.com.google.gson.reflect class TypeToken 表示范型&#xA;4.注解 注解类 @interface这是java用来定义一个注解类。&#xA;@Target和@Retention这两个是JDK提供的元注解。请看下面。&#xA;@Target(ElementType.TYPE) //接口、类、枚举、注解&#xA;@Target(ElementType.FIELD) //字段、枚举的常量&#xA;@Target(ElementType.METHOD) //方法&#xA;@Target(ElementType.PARAMETER) //方法参数&#xA;@Target(ElementType.CONSTRUCTOR) //构造函数&#xA;@Target(ElementType.LOCAL_VARIABLE)//局部变量&#xA;@Target(ElementType.ANNOTATION_TYPE)//注解&#xA;@Target(ElementType.PACKAGE) ///包&#xA;@Retention(RetentionPolicy.RUNTIME) // 注解会在class字节码文件中存在，在运行时可以通过反射获取到&#xA;简单解释一下，比如ElementType.TYPE这个表示是一个类注解。比如struts2和springMVC的@controller</description>
    </item>
    <item>
      <title>【Android技巧】通过am完成发送开机广播等操作</title>
      <link>https://anwangtanmi.github.io/posts/6edfc927fda5864e4977b2cc060320a9/</link>
      <pubDate>Thu, 17 Mar 2016 17:14:52 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/6edfc927fda5864e4977b2cc060320a9/</guid>
      <description>作者：Yogi&#xA;前言：许多应用都有接收开机广播，进行一些操作的功能，每次调试这些功能总是要重启机器很麻烦，庆幸的是，我们可以在终端通过安卓自带的am命令来发送开机广播，省去了等待的时间。&#xA;发送开机广播的命令如下&#xA;am broadcast -a android.intent.action.BOOT_COMPLETED 类似的，我们可以使用 am broadcast -a xxaction 来发送广播&#xA;后续，我将再添加进其他am的使用。</description>
    </item>
    <item>
      <title>Glide加载图片变色问题</title>
      <link>https://anwangtanmi.github.io/posts/48bed8b4d279007e5a799484f174d49b/</link>
      <pubDate>Tue, 26 Jan 2016 01:55:57 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/48bed8b4d279007e5a799484f174d49b/</guid>
      <description>项目中使用glide加载图片&#xA;加载图片的代码&#xA;Glide.with(context).load(t.getRecommend_img()) .into(imageView); 普通的不能再普通&#xA;再看布局文件&#xA;嗯，也没什么奇怪的嘛，但是每次加载白色图片，图片总是会变绿。。。。。这，这，这能忍吗？？ 给图片设置白色背景，没有效果。。。&#xA;好吧，这么晚了，我就不卖关子了，将Imageview的尺寸写死就OK了，可以不明白为什么，求大神指点</description>
    </item>
    <item>
      <title>android surfaceview播放视频前,出现黑屏</title>
      <link>https://anwangtanmi.github.io/posts/9760bde15c46b6727f6c643f79625256/</link>
      <pubDate>Tue, 12 Jan 2016 08:40:56 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/9760bde15c46b6727f6c643f79625256/</guid>
      <description> 问下，surfaceview播放视频前，总是黑屏2秒钟，就显示画面，有谁碰到过么 ？ 回答1：那是加载啊 缓冲buffer100% 。 回答2： 这是正常情况.. 回答3：我们是还没有播放的情况下,先实现图片在上面,这样就看不出来了 回答4：原因是 Activity加载布局后，才开始加载surfaceview，其他布局都加载好了，但是sur就黑屏2秒 回答5：不光是你播放的时候会黑屏,轮循播放每次开始的时候都会有 提问：当一模一样的图片放在survuew位置？我也试过，还是黑屏 提问：今天经理要我消除黑屏，我查了好多资料都实现不了 回答：提取第一帧图片就好了 提问：怎么提取 回答：用一个ImageView先覆盖在surfaceVIew的上面 Bitmap bitmap = ThumbnailUtils.createVideoThumbnail(videoPath, Images.Thumbnails.FULL_SCREEN_KIND);&#xA;看你是弄小图还是大图.修改下参数就可以了&#xA;你不要把图片弄在SurfaceView中显示,就在ImageView中显示就好了啊 </description>
    </item>
    <item>
      <title>Android 导航栏ActionBar和状态栏StautsBar的定制</title>
      <link>https://anwangtanmi.github.io/posts/ceac4e9a1b801269cd45188009ccf8b2/</link>
      <pubDate>Sun, 20 Dec 2015 14:49:12 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/ceac4e9a1b801269cd45188009ccf8b2/</guid>
      <description>有关Theme主题 &amp;lt;resources&amp;gt; &amp;lt;style name=&#34;AppTheme&#34; parent=&#34;Theme.AppCompat.Light.DarkActionBar&#34;&amp;gt; -- Customize your theme here. --&amp;gt; style&amp;gt; &amp;lt;style name=&#34;AppTheme2&#34; parent=&#34;Theme.AppCompat.Light&#34;&amp;gt; -- Customize your theme here. --&amp;gt; style&amp;gt; &amp;lt;style name=&#34;AppTheme3&#34; parent=&#34;Theme.AppCompat&#34;&amp;gt; -- Customize your theme here. --&amp;gt; style&amp;gt; &amp;lt;style name=&#34;AppTheme4&#34; parent=&#34;android:style/Theme.Material.Light.DarkActionBar&#34;&amp;gt; -- Customize your theme here. --&amp;gt; style&amp;gt; &amp;lt;style name=&#34;AppTheme5&#34; parent=&#34;android:style/Theme.Material.Light&#34;&amp;gt; -- 自定义ActionBar的风格--&amp;gt; &amp;lt;item name=&#34;android:actionBarStyle&#34;&amp;gt;@style/AppTheme5.ActionBar style&amp;gt; &amp;lt;style name=&#34;AppTheme5.ActionBar&#34; parent=&#34;android:style/Theme.Material.Light&#34;&amp;gt; -- actionBar背景--&amp;gt; &amp;lt;item name=&#34;android:background&#34;&amp;gt;@android:color/white &#34;android:elevation&#34;&amp;gt;@dimen/activity_horizontal_margin &#34;android:displayOptions&#34;&amp;gt;homeAsUp|showTitle style&amp;gt; &amp;lt;style name=&#34;AppTheme6&#34; parent=&#34;android:style/Theme.Material&#34;&amp;gt; -- Customize your theme here. --&amp;gt; style&amp;gt; &amp;lt;style name=&#34;</description>
    </item>
    <item>
      <title>SpriteBuilder实现2D精灵光影明暗反射效果(一)</title>
      <link>https://anwangtanmi.github.io/posts/81d6130265ee4d2322dcb1c545655a58/</link>
      <pubDate>Tue, 17 Nov 2015 16:50:08 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/81d6130265ee4d2322dcb1c545655a58/</guid>
      <description>其实不用3D建模,用2D的图像就可以模拟3D场景中光照反射的效果.&#xA;这里我们不得不提到一个normalMap(法线图)的概念,请各位童鞋自己度娘吧,简单来说它可以使得2D表面生成一定细节程度的光照方向和反射效果.&#xA;我们首先要制作精灵的法线贴图,至于怎么做,懂3D制图的童鞋应该都知道,有专门的软件.不过对于本猫猪这种图痴来说,也有简单容易上手的工具,名字为SpriteIlluminator,可以到其官网下载:&#xA;https://www.codeandweb.com/spriteilluminator&#xA;软件非常不错,可惜要收费 ;( 不过有7天的试用期限,以下是软件运行界面:&#xA;至于怎么用,大家可以看其简明教程:&#xA;https://www.codeandweb.com/blog/2015/03/17/cocos2d-dynamic-lighting-tutorial&#xA;而在这里可以看到更多的教程:&#xA;https://www.codeandweb.com/blog&#xA;以下就是其教程中,app完成后实际的效果:&#xA;还是相当不错的,我们在下篇中就来简单说说用SpriteBuilder如何完成类似效果.</description>
    </item>
    <item>
      <title>学习安卓设备管理器锁屏、清除数据总结—DevicePolicyManager</title>
      <link>https://anwangtanmi.github.io/posts/7d150c499c177cdccaf53f535d1f9d10/</link>
      <pubDate>Sat, 17 Oct 2015 23:08:37 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/7d150c499c177cdccaf53f535d1f9d10/</guid>
      <description>一:设备管理器介绍：&#xA;Android 2.2 SDK提供了一个可管理和操作设备的API叫DevicePolicyManager，&#xA;使用这个API你可以接管手机的应用权限，&#xA;对手机做出很多大胆的操作，&#xA;比如锁屏、恢复出厂设置、设置密码、强制清除密码，修改密码、设置屏幕灯光渐暗时间间隔等操作。&#xA;二：设备管理器创建&#xA;1.要调用DevicePolicyManager 必须有个设备管理器admin，&#xA;那么第一步创建一个MyAdmin,必须继承DeviceAdminReceiver，&#xA;不用重写什么方法，&#xA;public class MyAdmin extends DeviceAdminReceiver { //showToast方法方便查看方法调用情况并提示 private void showToast(Context context, String msg) { Toast.makeText(context, msg, Toast.LENGTH_SHORT).show(); } @Override /** R.string.devices_onEnabled=&#34;&#34; */ public void onEnabled(Context context, Intent intent) { showToast(context, &#34;开启设备管理器&#34;); } @Override public CharSequence onDisableRequested(Context context, Intent intent) { return &#34;警告禁止用户的请求&#34;; } @Override public void onDisabled(Context context, Intent intent) { showToast(context, &#34;设备管理器关闭&#34;)); } @Override public void onPasswordChanged(Context context, Intent intent) { showToast(context, &#34;</description>
    </item>
    <item>
      <title>使用adb解锁</title>
      <link>https://anwangtanmi.github.io/posts/2b7af8c8674921109b067c2fad1dd2fd/</link>
      <pubDate>Tue, 08 Sep 2015 13:08:40 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/2b7af8c8674921109b067c2fad1dd2fd/</guid>
      <description>手机锁屏忘记密码，可以通过adb进行解屏安全不丢失东西&#xA;1)下载adb.zip,并解压到D盘&#xA;2)通过dos进入d盘的adb目录下，cmd 输入D:\adb”并回车，然后输入”D:”回车;&#xA;3)输入”adb shell”并回车&#xA;4)输入”su”并回车&#xA;5)输入”cd data/system”&#xA;6)输入”ls”查看system目录下的文件&#xA;7)看到有一个”password.key”,输入“rm password.key”删除此文件;&#xA;8)重启手机就可以了&#xA;当然了还可以通过刷机、或双清来解决，但是我觉得通过adb才是安全的&#xA;adb工具下载地址：http://download.csdn.net/detail/niuba123456/9088571&#xA;﻿﻿</description>
    </item>
    <item>
      <title>android 设备在设置节能模式的情况下 调用 Toast 会 唤醒屏幕 突然变亮</title>
      <link>https://anwangtanmi.github.io/posts/00ceed7243c79292f04380588de71785/</link>
      <pubDate>Thu, 16 Jul 2015 16:27:44 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/00ceed7243c79292f04380588de71785/</guid>
      <description>最近在开发中遇到题目所说的问题 特此记录一下&#xA;首先，设备设置从不休眠，设置节能模式为15秒（即：15秒后设备亮度变暗）&#xA;然后，进入我们开发的应用，在我们开发的应用中会定时执行某项上传任务，当网络未连接时，会提示用户 “网络未连接，请检查网络”&#xA;如果用 Toast.makeText(NetWorkErrorActivity.this, “网络未连接，请检查网络”,Toast.LENGTH_SHORT).show(); 这样提示的话&#xA;会唤醒屏幕 ，因为会定时执行任务，所以每次提示后都会唤醒屏幕 到时耗电&#xA;所以可以换用AlertDialog 方式提示</description>
    </item>
    <item>
      <title>Android亮屏和熄屏控制</title>
      <link>https://anwangtanmi.github.io/posts/ffc91764f63f8caf147c5025e09ee92c/</link>
      <pubDate>Tue, 07 Jul 2015 17:53:50 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/ffc91764f63f8caf147c5025e09ee92c/</guid>
      <description>Android系统提供了电源管理的类PowerManager；调用相应的属性即可实现；&#xA;系统服务 — PowerManager.java&#xA;顾名思义，PowerManager.java就是管理我们电源方面的功能的，当然也包括我们屏幕的亮和熄灭。没错，我们的应用程序就是通过这个系统服务来实现亮屏和熄屏的功能的。&#xA;1. 应用程序获取PowerManager服务, 我们可以这样书写：&#xA;PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);&#xA;因为PowerManager是系统服务，所以它的生命周期不是应用程序所能控制的；应用程序只能通过系统，向系统请求获取PowerManager服务，然后系统把这个服务的应用给我们。&#xA;2. goToSleep()方法， 这个方法可以强制我们的屏幕熄屏。我们可以这样调用：&#xA;在上面拿到pm对象之后，这样调用 pm.goToSleep(SystemClock.uptimeMillis());&#xA;3. setBacklightBrightness()方法，这个方法可以设置背光的亮度，从0-255 三. 定时熄灭屏幕&#xA;那么这里，还可以介绍一个控制屏幕的方法就是PowerManager.WakeLock&#xA;顾名思义，WakeLock这个东西就是亮屏控制，这里说的亮屏，它定义了几种类型的亮屏。如下：&#xA;类型 cpu 屏幕 键盘 PARTIAL_WAKE_LOCK on off off SCREEN_DIM_WAKE_LOCK on dim off SCREEN_BRIGHT_WAKE_LOCK on Bright off FULL_WAKE_LOCK on Bright Bright 由于它定义了这么多类型，每种类型可以指定相对应的部件工作和不工作。那么我们就可以利用这些类型，从最细粒度来控制我们的屏幕，控制我们的电源，从而让我们的电源工作时间尽可能的延长(大家都知道，智能手机的电池问题是一个硬伤， 每天一充电，有木有？ 别人说用安卓手机的男人都是顾家好男人，因为他每天晚上都要回家充电。。^^).&#xA;好的，好的，闲话不扯，继续。。。&#xA;怎么使用这个WakeLock呢？我们可以这样写：&#xA;PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE); PowerManager.WakeLock wakeLock = pm.newWakeLock(PowerManager.SCREEN_DIM_WAKE_LOCK, “TAG”); wakeLock.acquire(); //做我们的工作，在这个阶段，我们的屏幕会持续点亮&#xA;//释放锁，屏幕熄灭。&#xA;wl.release();&#xA;那么这里我们也可以这样使用，就是多少时间后熄灭屏幕&#xA;首先点亮屏幕&#xA;PowerManager pm = (PowerManager) getSystemService(Context.</description>
    </item>
    <item>
      <title>Android抽屉效果的实现（不挤压，不覆盖）</title>
      <link>https://anwangtanmi.github.io/posts/de31133da5a915ab0d4645d6743d8734/</link>
      <pubDate>Thu, 02 Apr 2015 19:03:01 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/de31133da5a915ab0d4645d6743d8734/</guid>
      <description>抽屉效果，顾名思义就是可以像抽屉一样拉出来推进去，在Android中一般是通过滑动（从左到右，或者像帘子一样从上往下拉，或者通过某个按钮）来实现抽屉效果。其实Android的抽屉效果很简单(V4.0以上)，使用了一个叫做DrawerLayout的类就可以轻松实现。废话少说，开始干活。&#xA;Android官网的教程（需要翻墙）：http://developer.android.com/training/implementing-navigation/nav-drawer.html&#xA;首先说说我今天准备实现的目标：&#xA;1、抽屉效果，就是可以推拉的，这个是基本（我的是从左向右滑动）。&#xA;2、挤压效果。所谓挤压，就是当把抽屉拉出来是，原来的屏幕不会被遮挡或者覆盖，而是顺势向同样的方向移动相同的距离。之所以会做这一个效果，是因为官网的DrawerLayout是默认会挤压的。&#xA;效果如下图（由于不知道怎么手机动态截屏，只能上静态图了，有知道的可以告诉我，当然腾讯手机管家的试过了，不流畅）&#xA;下面是具体的实现步骤&#xA;1、布局文件mlayout.xml&#xA;需要注意的是： （1）这里的根标签是android.support.v4.widget.DrawerLayout而不是普通的RelativeLayout之类的，里面有2个部分，第一个部分是The main content view，主界面，也就是抽屉还没打开之前的界面，这里官网用的是FrameLayout，其实也就是一个主界面的布局，所以都无所谓，我喜欢用RelativeLayout所以用它，主界面布局内根据自己的需要随意添加空间；&#xA;（2）第二个部分就是抽屉的界面，布局也是随意的。我用的是ListView，因为一般拉出来的抽屉，都是系统的一些设置和检查更新什么的。&#xA;（3）主界面布局宽和高，必须match_parent，抽屉的高也是，抽屉的宽度不得超过320dp（官方规定的），否则会全部遮挡（或挤压）掉主布局。&#xA;（4）抽屉有个属性是layout_gravity，这个是指抽屉出来的方向，必须设置。一般可以设置left、end、right、start（不过貌似我出来start，其他的感觉都会使应用崩溃）&#xA;2、主类MainActivity.java，其中滑动和点击按钮都可以打开抽屉&#xA;package com.exam.drawerdemo; import android.app.Activity; import android.os.Bundle; import android.support.v4.widget.DrawerLayout; import android.support.v4.widget.DrawerLayout.DrawerListener; import android.view.Gravity; import android.view.View; import android.view.View.MeasureSpec; import android.view.View.OnClickListener; import android.view.ViewGroup; import android.widget.ArrayAdapter; import android.widget.Button; import android.widget.ListView; import android.widget.RelativeLayout; public class MainActivity extends Activity { DrawerLayout mDrawerLayout; Button mButton; ListView mDrawerList; String[] str={&#34;AA&#34;,&#34;BB&#34;,&#34;CC&#34;,&#34;DD&#34;,&#34;EE&#34;,&#34;FF&#34;}; RelativeLayout mRelativeLayout; int mDrawerWidth;//抽屉全部拉出来时的宽度 float scrollWidth;//抽屉被拉出部分的宽度 @Override protected void onCreate(Bundle savedInstanceState) { super.</description>
    </item>
    <item>
      <title>Android图像处理技术（实现Android中的PS）（一）</title>
      <link>https://anwangtanmi.github.io/posts/54eda999859de93b6b7f5e148f593fe5/</link>
      <pubDate>Mon, 23 Mar 2015 21:01:37 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/54eda999859de93b6b7f5e148f593fe5/</guid>
      <description>声明：本系列博客系笔记类，观看慕课网的视频教程后写下的笔记，感谢这位前辈的分享：http://blog.csdn.net/eclipsexys&#xA;1. 图像分析之RGBA模型&#xA;R: Red G : Green B: Blue A : Alpha 色调/色相：物体传递的颜色 饱和度：颜色的饱和程度 亮度/明度：颜色的明暗程度&#xA;1.如何在程序中设置RGB：&#xA;// 设置色相 ColorMatrix matrix=new ColorMatrix(); matrix.setRotate(0, 30); //0 代表 R matrix.setRotate(1, 30); //1 代表 G matrix.setRotate(2, 30); //2 代表 B // 设置饱和度 matrix.setSaturation(30); // 设置亮度 matrix.setScale(30, 30, 30, 30); 2.利用上面的知识自助制作一个PS小工具。 先上效果图: 下面我们来看看代码： 首先在MainActivity中定义一个点击时间，跳转到我们的第二个界面，第一个界面很简单，不说了，直接讲重点。 首先贴一下布局代码&#xA;&amp;lt;LinearLayout xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34; android:layout_width=&#34;match_parent&#34; android:layout_height=&#34;match_parent&#34; android:layout_marginLeft=&#34;10dp&#34; android:layout_marginRight=&#34;10dp&#34; android:orientation=&#34;vertical&#34; &amp;gt; &amp;lt;ImageView android:id=&#34;@+id/imageView&#34; android:layout_width=&#34;200dp&#34; android:layout_height=&#34;200dp&#34; android:src=&#34;@drawable/photo&#34;/&amp;gt; &amp;lt;SeekBar android:id=&#34;@+id/hueSeekBar&#34; android:layout_width=&#34;fill_parent&#34; android:layout_height=&#34;wrap_content&#34;/&amp;gt; &amp;lt;SeekBar android:id=&#34;</description>
    </item>
    <item>
      <title>Android-Lint使用后的错误解决</title>
      <link>https://anwangtanmi.github.io/posts/3379f67ce95bdf54e220183ad73e32f3/</link>
      <pubDate>Sun, 01 Feb 2015 22:16:38 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/3379f67ce95bdf54e220183ad73e32f3/</guid>
      <description>今晚看到慕课网推荐的一篇文章（http://www.imooc.com/wenda/detail/245965），讲的是使用Android lint工具进行Android代码优化。看完我便自己尝试了一下，没想到整个workspace下多个工程都出现了错误，无法运行了。&#xA;其中我遇到的错误有如下几种：&#xA;1，Description Path Resource Location Type&#xA;“app_name” is not translated in “af” (Afrikaans), “am” (Amharic), “ar” (Arabic), “bg” (Bulgarian), “ca” (Catalan), “cs” (Czech), “da” (Danish), “de” (German), “el” (Greek), “en-rGB” (English: United Kingdom), “en-rIN” (English: India), “es” (Spanish), “es-rUS” (Spanish: United States), “et-rEE” (Estonian: Estonia), “fa” (Persian), “fi” (Finnish), “fr” (French), “fr-rCA” (French: Canada), “hi” (Hindi), “hr” (Croatian), “hu” (Hungarian), “hy-rAM” (Armenian: Armenia), “in” (Indonesian), “it” (Italian), “iw” (Hebrew), “ja” (Japanese), “ka-rGE” (Georgian: Georgia), “km-rKH” (Khmer: Cambodia), “ko” (Korean), “lo-rLA” (Lao: Lao People’s Democratic Republic), “lt” (Lithuanian), “lv” (Latvian), “mn-rMN” (Mongolian: Mongolia), “ms-rMY” (Malay: Malaysia), “nb” (Norwegian Bokmål), “nl” (Dutch), “pl” (Polish), “pt” (Portuguese), “pt-rPT” (Portuguese: Portugal), “ro” (Romanian), “ru” (Russian), “sk” (Slovak), “sl” (Slovene), “sr” (Serbian), “sv” (Swedish), “sw” (Swahili), “th” (Thai), “tl” (Tagalog), “tr” (Turkish), “uk” (Ukrainian), “vi” (Vietnamese), “zh-rCN” (Chinese: China), “zh-rHK” (Chinese: Hong Kong), “zh-rTW” (Chinese: Taiwan, Province of China), “zu” (Zulu) /Demo_AutoChat/res/values strings.</description>
    </item>
    <item>
      <title>设置屏幕常亮 switch</title>
      <link>https://anwangtanmi.github.io/posts/2e5c88013fd71ec88fe9c111978e79f1/</link>
      <pubDate>Fri, 23 Jan 2015 09:33:50 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/2e5c88013fd71ec88fe9c111978e79f1/</guid>
      <description> 首先要在AndroidManifest中加权限&#xA;import android.os.BatteryStats.Uid.Wakelock; import android.os.PowerManager; import android.os.PowerManager.WakeLock; 由于 Class是Fragment ，所以用&#xA;getActivity()去获取getActivity().getSystemService public class DoovTimerFragment extends DeskClockFragment&#xA;mPowerManager = (PowerManager)getActivity().getSystemService(Context.POWER_SERVICE); mWakelock= mPowerManager.newWakeLock(PowerManager.FULL_WAKE_LOCK, &#34;My Lock&#34;); screenOn=(Switch)v.findViewById(R.id.ScreenOn); if(screenOn.isChecked()) { mWakelock.acquire(); } screenOn.setOnCheckedChangeListener(new OnCheckedChangeListener() { @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) { // TODO Auto-generated method stub if(screenOn.isChecked()) { mWakelock.acquire(); }else { mWakelock.release(); } } }); </description>
    </item>
    <item>
      <title>如何解决 unable to load library XXX 问题</title>
      <link>https://anwangtanmi.github.io/posts/47e449ead702f80078a4a354397e0c46/</link>
      <pubDate>Tue, 06 May 2014 14:46:28 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/47e449ead702f80078a4a354397e0c46/</guid>
      <description>程序有时会报上面错误。有可能是下面几个原因：&#xA;1. 相应的dll文件没有加载。可将相应的dll文件拷贝到system32下；&#xA;2. 如果不行的话，检查你的jdk看看。如果电脑室64位的请用64位jdk。或者换个新版本jdk。我的就是这个原因。我将jdk有原来1.6换位1.7之后，问题解决!</description>
    </item>
    <item>
      <title>WIFI在手机锁屏后，自动断开的问题</title>
      <link>https://anwangtanmi.github.io/posts/8a71f261526b08a522b0f16449313f9a/</link>
      <pubDate>Sat, 18 May 2013 12:30:03 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/8a71f261526b08a522b0f16449313f9a/</guid>
      <description>现象，如标题，锁屏后WIFI会自动断开。&#xA;1、来到 设置——&amp;gt;无线和网络——&amp;gt;WLAN设置——&amp;gt;点击MENU（菜单）键——&amp;gt;高级——&amp;gt;WLAN休眠策略——&amp;gt;选择 永不休眠&#xA;一般完成第一步就没有问题了。&#xA;新情况：锁屏后，QQ在别的机器上显示还在线，但发送的消息本机却不消息到来的提示音；当解除锁屏后，状态栏的WIFI小图标会闪退再重新显示，并且QQ接收到了新消息。&#xA;解决方案看第二步：&#xA;2、系统自带有个vDM client的软件，用于网络管理，对应软件包名是”vdmc.apk”。&#xA;从网上下载，或从别的ROM中拿到这个vdmc.apk，将vdmc.apk装进系统即可。&#xA;(第二步只适合：开启了 设置——》应用程序——》开发——》”保持唤醒状态”，并且该方法只在手机充电状态下适用; 若不在充电状态，则锁屏后，还是会自动断开)；&#xA;(有新方法继续补充)&#xA;(测试手机中兴v880 android 2.2.2)</description>
    </item>
    <item>
      <title>[Android]手机通过USB绑定共享电脑网络</title>
      <link>https://anwangtanmi.github.io/posts/551da905bd455af130639064d6ba2233/</link>
      <pubDate>Fri, 28 Sep 2012 17:43:58 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/551da905bd455af130639064d6ba2233/</guid>
      <description>转载请注明http://blog.csdn.net/kondykuang/article/details/8029471&#xA;一，概述&#xA;一般情况下，使用USB绑定是让电脑共享手机网络，这次我们反过来。注意只适用于linux系统，windows可以自行研究下。&#xA;二，实验环境：&#xA;通过USB绑定与PC链接成功后，我的IP配置如下：&#xA;PC： eth0 172.16.9.123 gw 172.16.9.1&#xA;usb0 192.168.42.123&#xA;Mobile： rndis0 192.168.42.234&#xA;二、启用步骤：&#xA;1，安装brctl ： apt-get install bridge-utils&#xA;2,PC操作：&#xA;（1） 添加一个网桥：brctl addbr br0&#xA;（2） 为网桥br0配置一个ip： ifconfig br0 172.16.9.123 up&#xA;（3） 将eth0和网桥绑定： brctl addif br0 eth0&#xA;（4） 将usb0和网桥绑定： brctl addif br0 usb0&#xA;（3） 为eth0配置一个ip： ifconfig eth0 0.0.0.0 up&#xA;（4） 为usb0配置一个ip： ifconfig usb0 0.0.0.0 up&#xA;（5） 将br0设置为默认路由接口： route add default gw 172.16.9.1 dev br0&#xA;此时pc上只有br0上有172.。。。。。的ip。如果不正常，请重新配置（3）或者（4）&#xA;ping baidu 能正确响应 说明pc配置成功。</description>
    </item>
    <item>
      <title>Android–Day01</title>
      <link>https://anwangtanmi.github.io/posts/9053ded286d20b5855dc2cb6f17affb3/</link>
      <pubDate>Sun, 16 Sep 2012 11:43:03 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/9053ded286d20b5855dc2cb6f17affb3/</guid>
      <description>传输协议跟传输速度&#xA;2G GPRS 20~30kB&#xA;2.5G EDGE 40~70kb&#xA;3G HSDPA 7.2M/s adsl&#xA;4G 16M/s 光纤.&#xA;95M 每个基站的速度&#xA;中国电信明推3G 暗推wifi&#xA;乐phone 乐os&#xA;阿里云 android 移动 ophone&#xA;其实上面&#xA;的都是android系统&#xA;家庭智能开发&#xA;ipv6 家庭网关:&#xA;home gateway.&#xA;dalvik 虚拟机 google 公司根据sun公司的规范&#xA;自己重新实现的java虚拟机.&#xA;jvm工作方式&#xA;.java -&amp;gt; .class -&amp;gt;.jar&#xA;dalvik 工作方式&#xA;.java -&amp;gt; .class -&amp;gt; 优化.dex -&amp;gt;&#xA;SDK : standard develope kits&#xA;JDK : java develop kits&#xA;android-sdk-windows.zip 开发包 sdk是分版本的 最新的版本 r20的版本&#xA;adt android develop kits eclipse的一个插件.</description>
    </item>
    <item>
      <title>Android ApiDemo学习（四）Views——7 Layout Animation</title>
      <link>https://anwangtanmi.github.io/posts/a8b16f9326e6be3250b04c043125b1df/</link>
      <pubDate>Wed, 22 Aug 2012 11:02:54 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/a8b16f9326e6be3250b04c043125b1df/</guid>
      <description>共有7个例子。&#xA;grid fade 效果：网格中的item从上到下、从左至右，依次从暗到亮显示出来。&#xA;代码：布局xml文件中，定义了gridview的animation属性为layout_grid_fade。上面的所有动画效果都是通过这句话添加上去的。这个属性定义了viewgroup第一次加载上去的动画，注意，这个动画是整个layout的动画。即整个gridview的动画。而不是单个item的动画。那单个item的动画效果在哪里呢？我们看这个layout_grid_fade.xml：&#xA;layout_grid_fade.xml中定义了三个属性：&#xA;rowDelay：行延迟时间比率 directionPriority：行优先还是列优先。比如这里定义这个属性值为column，那么列优先。 animation：这个animation就是grid里单个item的动画了。这里定义为fade。 fade.xml为grid的每个cell定义动画，我们看这个文件：&#xA;alpha：表示这个动画实现的是透明度的改变。即cell的明暗变化 interpolator：插值器。即变化的加速或减速。这里定义为加速显示 fromAppha toAlpha：起始透明度和结束透明度。动画的开头和结束两个关键帧 duration：动画持续的时间 list cascade 效果：listview中item从上到下依次展开。&#xA;代码：看java代码，LayoutAnimation使用LayoutAnimationController来定义一个Viewgroup里item的动画，比如本例中listview的item。在这个LayoutAnimationController中添加了两个动画，一个是AlphaAnimation，透明度从0到1；另一个是TranslateAnimation，y方向上从-1到1。可以改变duration设置其时间长一些来看到效果。&#xA;从本例和上例的比较：layout animation有两种animation，第一种是整个viewgroup的animation，在viewgroup的布局文件中使用layoutAnimition属性定义，定义layout内部item的动画之间的延迟时间、优先级和item动画id等；第二种是单个item的animation，可以在viewgroup的动画xml文件中使用animation属性定义，或者在java代码中使用LayoutAnimationController，定义单个item的动画效果。&#xA;reverse order 本例显示listview的item倒序显示。和第一个例子类似。先使用layoutAnimation定义整个listview的动画定义文件为layout_bottem_to_top_slide.xml。在这个xml文件中，定义了单个item的animation为slide_right。关键句是animationOrder属性，这个属性可以定义为normal正序、reverse倒序、random随机。&#xA;randomize 与上例一样示范item动画的显示顺序。上例是listview倒序，本例为gridview随机顺序。&#xA;grid direction 与第一例类似，区别是：定义layoutAnimation时，定义为行优先。且增加direction属性为从下向上、从右到左。&#xA;wave scale 看定义单个item动画的wave_scale文件：三个动画效果放一起，分别是alpha、scale、scale。&#xA;alpha：透明度从0到1&#xA;scale1：从0.5倍放大到1.5倍&#xA;scale2：从1.5被缩小为正常1倍&#xA;nested animation 先看整个例子的布局文件layout_animation.xml，定义table中的四行的layoutAnimation分贝为layout_animation_row_right_slide和layout_animation_row_right_slide. 注意，TalbeLayout是一个groupview，而TableLayout的子标签TableRow也是groupview，因此可以单独对TableRow定义LayoutAnimation。&#xA;layout_animation_row_left_slide：定义单个item动画为slide_left&#xA;layout_animation_row_right_slide：定义单个item动画为slide_right&#xA;这7个例子，都是view下的layoutanimation，可以看到animation下也有layoutanimation。这是两种不同的animation。读者可自行比较一下，最后animation会总结这两种layoutanimation的区别。</description>
    </item>
    <item>
      <title>基于Arduino实现Arduino控制的电灯</title>
      <link>https://anwangtanmi.github.io/posts/5fa7a4c8a57171b6e088fe98a27ef86f/</link>
      <pubDate>Tue, 01 May 2012 04:18:36 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/5fa7a4c8a57171b6e088fe98a27ef86f/</guid>
      <description>主要介绍使用Arduino做出一个可以通过Android手机控制开关的电灯。试想，当你晚上睡在床上，打开手机，关闭书房或者走廊的电灯，是不是一件很cool的事情。&#xA;一、所需部件介绍 1）Arduino UNO板&#xA;这当然是必须的。不过这里要特别说明一下，我使用是的DF-Bluetooth V3的蓝牙模块，而部分Arduino UNO板由于串口限流电阻设计存在问题，会导致蓝牙模块只能发送数据而不能接收数据，这实在是一个很大的问题。我因为这个原因，又重新购买了一块新的Arduino UNO板。所以，在购买时请注意咨询卖家，确认是否已经改造过串口电阻，支持DF-Bluetooth V3模块。在进行制作前，也请先验证你的UNO板是否能通过蓝牙模块正常接收数据。&#xA;2）蓝牙模块（BluetoothV3）及传感器扩展板&#xA;我使用的是DF-Bluetooth V3蓝牙模块及Arduino Xbee传感器扩展板V5，这两者是配套的。当然没有扩展板也没有关系，直接连线通过SoftSerial方式会更好调试。有了扩展板，在使用的时候会更清爽，一根连线都不用了。&#xA;3）继电器&#xA;由于要控制220v的电灯，所以我们需要一个继电器模块，用小电流来控制大电流设备。我使用的是Arduino兼容的JQC-3FF继电器模块，能承受277V/10A的交流设备，这对我们制作电灯来说足够用了，而且做工还挺精致的。&#xA;4）Android手机 当然，肯定还有android手机。必须android2.0以上系统的android手机，推荐2.3及以上系统，必须要有蓝牙喲（废话）。&#xA;二、电路连接 1）继电器与电灯的连接&#xA;继电器有四个接线柱：NO、NC、N/A、COM。在接通控制电源后，通过控制信号，可以控制NO/NC与COM端口的闭合。我制作了一个简单的灯，将接线的火线断开，分别接在NO口与COM口。继电器的模块引脚有三个，分别是：1脚–控制端，2脚–电源（VCC），3脚–地（GND），使用数据线直接与Arduino的数字信号端口连接（扩展板有专门的插口，很方便。），我们采用7数字引脚。接好的继电器如图所示。&#xA;2）蓝牙模块&#xA;由于是配套的扩展板，直接插上就是了。&#xA;三、Arduino程序 要实现的功能其实很简单：设备通过蓝牙接收到到数据进行判断，控制继电器的开合。&#xA;代码如下：&#xA;int LIGHT_PIN = 7; //设置继电器的控制数字引脚 char bt_command; void setup() { Serial.begin(9600); //蓝牙的波特率，默认一般是9600根据自己的蓝牙设备设置而定 pinMode(LIGHT_PIN,OUTPUT); } void loop() { bt_command = Serial.read(); //从蓝牙上读取数据 if(bt_command == &#39;1&#39;){ //如果为字符1，闭合继电器，灯亮 digitalWrite(LIGHT_PIN,HIGH); }else if(bt_command == &#39;0&#39;){ //如果为字符0，断开继电器，灯灭 digitalWrite(LIGHT_PIN,LOW); } delay(2000); //做一个保护，避免点击过快，损坏灯 } 代码很简单，相信大家理解没有问题。&#xA;四、Android代码 这块相信是大家认为比较麻烦的，的确也是最麻烦的地方。不多说了，大家自己看源码。之前是用自己蓝牙的mac地址做寻址，方便。为了方便大家用，增加了设备扫描功能，这样如果不想做Android程序的，可以直接安装apk就能用。我在我的里程碑（用的MIUI）和i9100上都试过了，没问题。Enjoy it！&#xA;代码在github.com上：https://github.com/kindlymouse/Arduino&#xA;五、效果演示 http://v.youku.com/v_show/id_XMzg5NDA1ODI4.html&#xA;说明：我玩Arduino时间很短，还是新手。不足之处，大家见谅并请多提意见！</description>
    </item>
    <item>
      <title>“电脑族”保健六项注意</title>
      <link>https://anwangtanmi.github.io/posts/ef2a56f7d0758dd00b08e4a83ef6b2e7/</link>
      <pubDate>Fri, 13 Jan 2012 09:21:27 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/ef2a56f7d0758dd00b08e4a83ef6b2e7/</guid>
      <description>目前，电脑对人体生理和心理方面的负面影响已日益受到人们的重视。为此科学使用电脑，减少电脑和网络的危害是十分必要的。 一是要增强自我保健意识 工作间隙注意适当休息，一般来说，电脑操作人员在连续工作1小时后应该休息10分钟左右。并且最好到操作室之外活动活动手脚与躯干。平时要加强体育锻炼，增强体能，要定期进行身体检查和自我心理测定。 二是注意工作环境 电脑室内光线要适宜，不可过亮或过暗，避免光线直接照射在荧光屏上而产生干扰光线，工作室要保持通风干爽，能使那些有害气体尽快排出，尽量用非击打式打印机减少噪音。 三是注意正确的操作姿势 应将电脑屏幕中心位置安装在与操作者胸部同一水平线上，最好使用可以调节高低的椅子。坐着时应有足够的空间伸放双脚，不要交叉双脚，以免影响血液循环。 四是注意保护视力 要避免长时间连续操作电脑，注意中间休息。要保持一个最适当的姿势，眼睛与屏幕的距离应在40－50厘米，使双眼平视或轻度向下注视荧光屏，这样可使颈部肌肉轻松，并使眼球暴露面积减小到最低。如果出现眼睛干涩、发红，有灼热或有异物感，眼皮沉重，看东西模糊，甚至出现眼球胀痛或头痛，那就需要到医院看眼科医生了。 五是注意补充营养 电脑操作者在荧光屏前工作时间过长，视网膜上的视紫红质会被消耗掉，而视紫红质主要由维生素A合成。因此，电脑操作者应多吃些胡萝卜、白菜、豆芽、豆腐、红枣、橘子以及牛奶、鸡蛋、动物肝脏、瘦肉等食物，以补充人体内维生素A和蛋白质。而多饮些茶，茶叶中的茶多酚等活性物质会有利于吸收与抵抗放射性物质。 六是注意保持皮肤清洁 电脑荧光屏表面存在着大量静电，其集聚的灰尘可转射到脸部和手的皮肤裸露处，时间久了，易发生斑疹、色素沉着，严重者甚至会引起皮肤病变等。 电脑族的保健 电脑族可多喝 绿茶、菊花茶 电脑族除了多接触到电磁辐射外，电脑荧光屏的闪动对眼睛也有较强的刺激作用。 长期使用电脑者，易患眼病。专家认为，平时多喝绿茶可起到一定的抗辐射作用。此外，菊花对治疗眼睛疲劳、视力模糊有很好的疗效，经常觉得眼睛干涩的电脑族，多喝些菊花茶有利无害。 许多人都知道，长期使用电脑会影响健康。 电脑族容易带来下肢静脉曲张、颈椎病 、腰椎间盘突出以及眼部疾患。 眼睛处于紧张状态 由于电脑族久坐电脑前，看东西较近，迫使眼睫状肌处于收缩紧张状态，从而使晶体变凸以适应视近物，眼睛长期处于紧张状态而得不到休息就会导致近视。视觉的过度疲劳还会引起房水运行受阻，较易导致青光眼。同时，干眼症、白内障、角膜溃疡和视网膜剥脱等，也是长期使用电脑者易患的眼病。 电脑族除了多接触到电磁辐射外，电脑荧光屏的闪动对眼睛也有较强的刺激作用，让人出现流泪、视力减退、头昏脑涨等不适征状。 绿茶抗辐射作用 专家认为，平时多喝绿茶可起到一定的抗辐射作用。《神农本草》把茶列入365种药物之中，并说“茶味苦，饮之使人益思，少卧，轻身明目。” 专家认为，绿茶中含有的维生素C、维生素E，特别是茶多酚，具有很强的抗氧化活性，可以清除人体内的氧自由基，从而起到抗辐射、增强机体免疫力的作用。 此外，茶叶中含有胡萝卜素，它在肠壁和肝脏的作用下，可以转变为维生素A。而维生素A具有滋养眼睛、缓解眼睛疲劳、预防夜盲症的作用。 使大脑更敏捷 不久前，英国科学家研究发现，喝茶可以阻止人体中一种酶的合成，这种酶会破坏脑细胞间传递信息的媒介乙酰胆碱。因此，喝茶对常用电脑的上班族来说，又多了项使大脑更敏捷的好处。 过去陆陆续续的医学报告显示，茶叶中经分离鉴定的已知化合物700多种，其中包括蛋白质、脂肪、糖类及多酚类、皂甙、生物碱、茶氨酸、色素、芳香物质等。 菊花茶呵护眼睛 此外，电脑族也可用菊花茶“呵护”眼睛。华人自古就知道菊花有保护眼睛的作用，菊花对治疗眼睛疲劳、视力模糊有很好的疗效。 菊花茶加入枸杞 《本草纲目》记载菊花“性甘、味寒，具有散风热、平肝明目之功效”。现代药理表明，菊花里含有丰富的维生素A，是维护眼睛健康的重要物质。菊花茶能让人头脑清醒、双目明亮，特别对肝火旺、用眼过度导致的双眼干涩有较好的疗效，经常觉得眼睛干涩的电脑族，多喝些菊花茶有利无害。 喝菊花茶方法简单，只要将市面上销售的，干燥后的菊花泡水或煮来喝就可以，平时可以定时泡一两杯菊花茶来喝，能达到眼睛保健的作用，如果每天喝三到四杯的菊花茶，对视力也有帮助。 也有人喜欢在菊花茶中加入枸杞，泡出来的茶就是有名的“菊杞茶”，具有更高的护眼睛作用，因为菊花与枸杞都是中药护眼的药材。 值得注意的是，菊花性凉，虚寒体质，平时怕冷，易手脚发凉的人不应该经常饮用，应该适量的喝。&#xA;Http://www.5ijk.net/list.aspx?cid=360 电脑族可多喝 绿茶、菊花茶 电脑族除了多接触到电磁辐射外，电脑荧光屏的闪动对眼睛也有较强的刺激作用。 长期使用电脑者，易患眼病。专家认为，平时多喝绿茶可起到一定的抗辐射作用。此外，菊花对治疗眼睛疲劳、视力模糊有很好的疗效，经常觉得眼睛干涩的电脑族，多喝些菊花茶有利无害。 许多人都知道，长期使用电脑会影响健康。 电脑族容易带来下肢静脉曲张、颈椎病 、腰椎间盘突出以及眼部疾患。 眼睛处于紧张状态 由于电脑族久坐电脑前，看东西较近，迫使眼睫状肌处于收缩紧张状态，从而使晶体变凸以适应视近物，眼睛长期处于紧张状态而得不到休息就会导致近视。视觉的过度疲劳还会引起房水运行受阻，较易导致青光眼。同时，干眼症、白内障、角膜溃疡和视网膜剥脱等，也是长期使用电脑者易患的眼病。 电脑族除了多接触到电磁辐射外，电脑荧光屏的闪动对眼睛也有较强的刺激作用，让人出现流泪、视力减退、头昏脑涨等不适征状。 绿茶抗辐射作用 专家认为，平时多喝绿茶可起到一定的抗辐射作用。《神农本草》把茶列入365种药物之中，并说“茶味苦，饮之使人益思，少卧，轻身明目。” 专家认为，绿茶中含有的维生素C、维生素E，特别是茶多酚，具有很强的抗氧化活性，可以清除人体内的氧自由基，从而起到抗辐射、增强机体免疫力的作用。 此外，茶叶中含有胡萝卜素，它在肠壁和肝脏的作用下，可以转变为维生素A。而维生素A具有滋养眼睛、缓解眼睛疲劳、预防夜盲症的作用。 使大脑更敏捷 不久前，英国科学家研究发现，喝茶可以阻止人体中一种酶的合成，这种酶会破坏脑细胞间传递信息的媒介乙酰胆碱。因此，喝茶对常用电脑的上班族来说，又多了项使大脑更敏捷的好处。 过去陆陆续续的医学报告显示，茶叶中经分离鉴定的已知化合物700多种，其中包括蛋白质、脂肪、糖类及多酚类、皂甙、生物碱、茶氨酸、色素、芳香物质等。 菊花茶呵护眼睛 此外，电脑族也可用菊花茶“呵护”眼睛。华人自古就知道菊花有保护眼睛的作用，菊花对治疗眼睛疲劳、视力模糊有很好的疗效。 菊花茶加入枸杞 《本草纲目》记载菊花“性甘、味寒，具有散风热、平肝明目之功效”。现代药理表明，菊花里含有丰富的维生素A，是维护眼睛健康的重要物质。菊花茶能让人头脑清醒、双目明亮，特别对肝火旺、用眼过度导致的双眼干涩有较好的疗效，经常觉得眼睛干涩的电脑族，多喝些菊花茶有利无害。 喝菊花茶方法简单，只要将市面上销售的，干燥后的菊花泡水或煮来喝就可以，平时可以定时泡一两杯菊花茶来喝，能达到眼睛保健的作用，如果每天喝三到四杯的菊花茶，对视力也有帮助。 也有人喜欢在菊花茶中加入枸杞，泡出来的茶就是有名的“菊杞茶”，具有更高的护眼睛作用，因为菊花与枸杞都是中药护眼的药材。 值得注意的是，菊花性凉，虚寒体质，平时怕冷，易手脚发凉的人不应该经常饮用，应该适量的喝。 谨防电脑危害 OFFICE里，电脑是我们最重要的一件办公用品，很难想像，如果没有了电脑，我们将如何工作。但遗憾的是，当我们享受着电脑带给我们的一切方便的同时，也不得不接受它在身心两方面对我们健康的威胁。所以，了解电脑“病”，防治电脑“病”，已经成为我们刻 不容缓的事情。为了全面了解电脑对OL身心的负面影响，我们特地组织这次策划，全面介绍缓解OL们最难逃脱的八大电脑“病”的窍门和方法。 罪状一：电磁辐射 症状：失眠、内分泌紊乱 致病原因：显示器热度过高，在工作时就会有相当多的电磁辐射，它会使空气发生电离作用，不断产生正电荷(正离子)，并不断与空气中的负离子中和，导致负离子的含量几乎为零。负离子多有益，正离子就多有害，长期处于正离子过多的环境中，它们通过呼吸进入肺，然后随血液循环被输送到人体的各个组织，使人的血液、体液呈酸性，延缓身体正常的代谢功能，使毒素囤积在体内。使人失眠、免疫力下降、女性内分泌紊乱等。 缓解方法 1.</description>
    </item>
    <item>
      <title>手,机,暗,码(未测试，用者谨慎)（转）</title>
      <link>https://anwangtanmi.github.io/posts/442ce5ea39a96104ed466d4ae11d1710/</link>
      <pubDate>Thu, 28 Jul 2011 15:41:47 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/442ce5ea39a96104ed466d4ae11d1710/</guid>
      <description>不同厂商的手机都会隐藏，独特的代码，用来查看系统及固件版本，或者进行硬件的测试，当然Android 手机也不例外，除了好像计算机一样能显示更详细的手机信息外，更可重设为原厂设定，更新相机韧体等。但部份代码要谨慎使用，因为可能令手机失去原有的功能， 笔者只是网络转载，出现问题一概恕不负责。&#xA;*#*#4636#*#* 显示手机信息、电池信息、电池记录、使用统计数据、WiFi 信息&#xA;上面这条为乐Phone经常用到的，只要在电话拨号的地方输入即可。&#xA;*#*#7780#*#* 重设为原厂设定，不会删除预设程序，及SD 卡档案。&#xA;*2767*3855# 重设为原厂设定，会删除SD 卡所有档案。&#xA;*#*#34971539#*#* 显示相机相机韧体版本，或更新相机韧体&#xA;*#*#273283*255*663282*#*#* 开启一个能让你备份媒体文件的地方，例如相片、声音及影片等&#xA;*#*#197328640#*#* 启动服务模式，可以测试手机部分设置及更改设定&#xA;*#*#232339#*#*或 *#*#526#*#* 或 *#*#528#*#* – WLAN 测试&#xA;*#*#232338#*#*– 显示WiFi MAC 地址&#xA;*#*#1472365#*#*– GPS 测试&#xA;*#*#1575#*#*– 其它GPS 测试&#xA;*#*#232331#*#*– 蓝牙测试&#xA;*#*#232337#*#– 显示蓝牙装置地址&#xA;*#*#8255#*#*-启动GTalk 服务监视器&#xA;*#*#7594#*#* 当长按关机按钮时，会出现一个切换手机模式的窗口，包括: 静音模式、飞航模式及关机，你可以用以上代码，直接变成关机按钮。&#xA;显示手机韧体的代码&#xA;*#*#4986*2650468#*#*– PDA、Phone、H/W、RFCallDate&#xA;*#*#1234#*#*– PDA 及Phone&#xA;*#*#1111#*#*– FTA SW 版本&#xA;*#*#2222#*#*– FTA HW 版本 *#*#44336#*#*– PDA 、Phone、CSC、Build Time、Changelist number&#xA;各项硬件测试&#xA;*#*#0283#*#*– Packet Loopback&#xA;*#*#0*#*#*– LCD 测试</description>
    </item>
    <item>
      <title>Android电源管理概念</title>
      <link>https://anwangtanmi.github.io/posts/f84002293a04f9bf38557ca53f3f912e/</link>
      <pubDate>Sat, 07 Aug 2010 17:35:00 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/f84002293a04f9bf38557ca53f3f912e/</guid>
      <description>Android电源管理 一、 相关概念 1. 出于节电的需要，一般应用在用户一段时间无操作的情况下屏幕变暗，然后进后休眠状态 2. 用户只能在”设置-&amp;gt;声音和显示”中设置所有应用默认的屏幕亮度和进行待机的时间 3. 电源管理的实现分内核应用两部分，通过下面介绍的接口，我们可以设置应用程序的电源管理，以控制与其休眠相关的状态（是否需要进入休眠，调整cpu频率，键盘灯的开关，屏幕的亮暗等） 二、 设置电源管理常用的几种状态 PARTIAL_WAKE_LOCK 屏幕关，键盘灯关，不休眠 SCREEN_MID_WAKE_LOCK 屏幕灰，键盘灯关，不休眠 SCREEN_BRIGHT_WEEK_LOCK 屏幕亮，键盘灯关，不休眠 FULL_WAKE_LOCK 屏幕亮，键盘灯亮，不休眠 三、 使用电源管理注意事项 1. 可在onCreate时设置该界面的电源管理，在onDestroy时取消设置 2. 可在onResume时设置该界面的电源管理，在onPause时取消设置 3. 注意设置是以Activity为单位，不是以应用为单位 4. 注意在AndroidManifest.xml中声明该应用有设置电源管理的权限 5. 注意加锁解锁要成对出现 6. 注意多个用途最好用多个锁，不要一锁多用，以免出错 7. 注意对运行在后台和异常时对锁的处理 8. 注意在网络连接或传输时最好加锁，以免传输被中断 9. 注意加锁以保证程序逻辑 四、 代码举例 1. 源码修改 1) 引入电源管理包，以使用相关类 import android.os.PowerManager; 2) 类中加入变量 PowerManager.WakeLock mWakeLock; 3) 修改onCreate public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE); mWakeLock = pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK, “XYTEST”); mWakeLock.acquire(); } 4) 修改onDestroy public void onDestroy() { super.</description>
    </item>
    <item>
      <title>Android电源管理</title>
      <link>https://anwangtanmi.github.io/posts/c6dff486ce0787bb7e75e52381634b6a/</link>
      <pubDate>Thu, 19 Nov 2009 18:36:00 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/c6dff486ce0787bb7e75e52381634b6a/</guid>
      <description>Android电源管理&#xA;一、 相关概念&#xA;1. 出于节电的需要，一般应用在用户一段时间无操作的情况下屏幕变暗，然后进后休眠状态&#xA;2. 用户只能在”设置-&amp;gt;声音和显示”中设置所有应用默认的屏幕亮度和进行待机的时间&#xA;3. 电源管理的实现分内核应用两部分，通过下面介绍的接口，我们可以设置应用程序的电源管理，以控制与其休眠相关的状态（是否需要进入休眠，调整cpu频率，键盘灯的开关，屏幕的亮暗等）&#xA;二、 设置电源管理常用的几种状态&#xA;PARTIAL_WAKE_LOCK 屏幕关，键盘灯关，不休眠&#xA;SCREEN_MID_WAKE_LOCK 屏幕灰，键盘灯关，不休眠&#xA;SCREEN_BRIGHT_WEEK_LOCK 屏幕亮，键盘灯关，不休眠&#xA;FULL_WAKE_LOCK 屏幕亮，键盘灯亮，不休眠&#xA;三、 使用电源管理注意事项&#xA;1. 可在onCreate时设置该界面的电源管理，在onDestroy时取消设置&#xA;2. 可在onResume时设置该界面的电源管理，在onPause时取消设置&#xA;3. 注意设置是以Activity为单位，不是以应用为单位&#xA;4. 注意在AndroidManifest.xml中声明该应用有设置电源管理的权限&#xA;5. 注意加锁解锁要成对出现&#xA;6. 注意多个用途最好用多个锁，不要一锁多用，以免出错&#xA;7. 注意对运行在后台和异常时对锁的处理&#xA;8. 注意在网络连接或传输时最好加锁，以免传输被中断&#xA;9. 注意加锁以保证程序逻辑&#xA;四、 代码举例&#xA;1. 源码修改&#xA;1) 引入电源管理包，以使用相关类&#xA;import android.os.PowerManager;&#xA;2) 类中加入变量&#xA;PowerManager.WakeLock mWakeLock;&#xA;3) 修改onCreate&#xA;public void onCreate(Bundle savedInstanceState) {&#xA;super.onCreate(savedInstanceState);&#xA;PowerManager pm =&#xA;(PowerManager) getSystemService(Context.POWER_SERVICE); mWakeLock = pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK, “XYTEST”); mWakeLock.acquire(); }</description>
    </item>
  </channel>
</rss>
