<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>嵌入式 on 暗网探秘</title>
    <link>https://anwangtanmi.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/</link>
    <description>Recent content in 嵌入式 on 暗网探秘</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 03 Jul 2018 11:16:48 +0800</lastBuildDate>
    <atom:link href="https://anwangtanmi.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>光敏传感器实验</title>
      <link>https://anwangtanmi.github.io/posts/72be3fdf8918744b8a21430b0989c8fc/</link>
      <pubDate>Tue, 03 Jul 2018 11:16:48 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/72be3fdf8918744b8a21430b0989c8fc/</guid>
      <description>光敏传感器实验&#xA;一、 实验目的&#xA;了解光敏传感器工作的过程，掌握针对一个光敏传感器实验的过程，深入了解其工作的机制，并且学会使用ATOS平台来进行烧录数据的操作，掌握TinyOS的基本操作方法。&#xA;二、 实验原理及基本技术路线图（方框原理图）&#xA;首先是开发平台的选择，对于传感器实验，我们选取的开发平台是ATOS。&#xA;ATOS 综合实验平台提供了一个完整的传感网实验平台，如图 1.1.1。在这个 平台中主要包括无线传感网节点、基站板、传感器模块。下面将简单介绍每个一模块的功能。&#xA;图 1.1.1 整体框架图&#xA;下面则是传感器模块以及基站板的介绍：&#xA;传感器模块是将物理世界的信息进行量化的设备，是 ATOS 实验平台中采集 数据的基本来源，传感器根据采集对象的不同，分为 A/D 式传感器及开关传感 器，ATOS 实验平台支持多达十几种传感器，使用统一连接的方式，方便使用和 替换。&#xA;基站板（或称为网关板），是 ATOS 实验平台中用于采集节点数据、烧录程 ATOS 实验平台–使用指南 4 序，以及串口通讯的多功能设备。在该平台上，在底板上已经实现每个基本节点 都可以通过基站统一烧录，不再需要用在线烧录器单独连接某个节点。 基站板上有一个射频模块连接插槽，一个传感器模块连接插槽，一个 USB 烧录线接口，USB 转串行接口以及一个标准串口。&#xA;软件：&#xA;ATOS 实验平台主要以 TinyOS 操作系统为软件平台，并在其之上扩展了许 多的应用开发中常用的组件，通过 ATOS 实验平台及其配套的组件可以快速的构 建自己的应用，而无需深入了解硬件相关的操作，这对于进行理论研究和学习原 理性知识减少了许多障碍。&#xA;下面将进行传感器原理的简介：&#xA;首先光敏传感器的核心元件就是光敏电阻，其原理如下：&#xA;光敏电阻是一种光电效应半导体器件，它能提供很经济实用的解决方案，应用于光存在 与否的感应（数字量）以及光强度的测量（模拟良）等领域。 光电效应半导体探测器可以分为两大类：结和体效应装置。结装置，工作于光电传导模 式，它利用 PN 结的反向特征。在反向偏转时，PN 结产生一个受光控制的电流信号。输出量 与触发照明成正比，而不受供应电源的影响。硅光电管就是这类的产品。而体效应光电半导 体没有结，它的体电阻系数随照明强度的增强而减小，容许更多的光电流流过。这种阻性特 征使得体效应光电半导体具有很好的品质：通过调节供应电源就可以从探测器上获得信号流， 且有着很宽的范围。为了区别，珀金埃尔默光电子将体效应光电半导体称作为光电半导体单 元，简单的说就叫光敏电阻。 光敏电阻是薄膜元件，它是由在陶瓷底衬上覆一层光电半导体材料。金属接触点盖在光 电半导体面下部。这种光电半导体材料薄膜元件有很高的电阻。所以在两个接触点之间，做 的狭小、交叉，使得在适度的光线时产生较低的阻值。&#xA;我们知道光敏电阻设计到了A/D转换的过程，因为电阻输出的是模拟量，而PC无法处理模拟量，因此为了能直接在PC端能看到数据，我们需要对于采集的数据进行A/D转换。&#xA;下面是A/D转换的原理：&#xA;A/D 转换器(Analog-to-Digital Converter)又叫模/数转换器,即是将模拟信号(电压或是电流的形式)转换成数字信号。这种数字信号可让仪表,计算机外设接口或是微处理机来加以操作或胜作使用。&#xA;A/D 转换器(ADC)的型式有很多种，方式的不同会影响测量后的精准度。</description>
    </item>
    <item>
      <title>Allegro学习笔记——调整各层颜色及可视性</title>
      <link>https://anwangtanmi.github.io/posts/f7e3a9e2c33b6e0af157e3d0e6ed4ba1/</link>
      <pubDate>Mon, 07 May 2018 21:41:55 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/f7e3a9e2c33b6e0af157e3d0e6ed4ba1/</guid>
      <description> </description>
    </item>
    <item>
      <title>嵌入式开发之STM32开发之无线控制之PT2262/2272最简单使用-带你实现一个远程控制电灯的例子</title>
      <link>https://anwangtanmi.github.io/posts/8c8ee4406107b983d89ad1b638f9053e/</link>
      <pubDate>Wed, 18 Apr 2018 23:40:50 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/8c8ee4406107b983d89ad1b638f9053e/</guid>
      <description>控制电灯？实在太简单不过了，我手动按一下不就行了，但是如果加个远程，那就难了！ 现在常用的远程有：红外，射频！ 因为我手边的PT2262/2272模块（就是一组常用的远程传数据的模块）只有射频，所以这次实现的远程就用射频模式了。 在嵌入式开发方面，我算是个新手，不过谁不是从新手开始的，那自然本篇文章也是适合新手的！ 为了简化工作，理清头绪，我把最终开发的成品分为几大模块:PT2262模块，PT2272模块，LED灯模块，STM32开发板模块，控制程序模块，继电器模块！&#xA;涉及的全部硬件和软件 1.SC2262（SC和PT兼容） 2.SC2272-M4（SC和PT兼容，M4:输出不带锁存，就是你必须一直按着按键，只要一松数据就没有了） 2.STM32F103RBT6开发板 3.核心控制程序 4.四个LED灯 5.排线 6.J-Link程序烧录器 7.u4开发软件 8.J-Link驱动软件 9.4个继电器&#xA;V4配置 https://blog.csdn.net/qq_26914291/article/details/79985663&#xA;GPIO配置 参考教程:http://blog.sina.com.cn/s/blog_537d614301019ues.html&#xA;//启动相应Port A的RCC RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Pin=GPIO_Pin_6|GPIO_Pin_7|GPIO_Pin_8|GPIO_Pin_9|GPIO_Pin_10; GPIO_InitStructure.GPIO_Speed=GPIO_Speed_2MHz; GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP; GPIO_Init(GPIOA,&amp;amp;GPIO_InitStructure);//把设置绑定到GPIOA 定时器GPIO配置:https://blog.csdn.net/qq_26914291/article/details/80141700&#xA;【注】关于相关GPIO模式详细看这:https://blog.csdn.net/l20130316/article/details/50571902&#xA;控制流程 问题 半自动学习功能：http://bbs.mydigit.cn/simple/?t245739.html 继电器驱动问题： 地址问题:即单片机如何控制浮空的问题&#xA;画图 1.画图采用DXP,&#xA;程序 https://download.csdn.net/download/qq_26914291/10388316&#xA;参考 1.学习型PT2262无线遥控开关程序 2.PT2262芯片四路学习型无线遥控开关 3315m无线遥控模块 PT2262、PT2272 4.基于PT2262,PT2272实用无线遥控照明灯报告书 5.基于PT2262PT2272无线遥控彩灯与液晶屏的设计与实现 6.PT2262-PT2272无线收发讲解 7.基于PT2262的无线灯控设备设计毕业论文 8.PT2272无线遥控灯315/433MHZ设计，附原理图/PCB/BOM清单 9.PT2262遥控器的单片机软件解码(省去PT2272) 10.用你的手机去控制家里的电灯（demo）</description>
    </item>
    <item>
      <title>POJ-1222-尺取法，开关灯</title>
      <link>https://anwangtanmi.github.io/posts/4e85c32e7a14fdf7a8f56e3a50a865c0/</link>
      <pubDate>Sat, 15 Apr 2017 15:28:18 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/4e85c32e7a14fdf7a8f56e3a50a865c0/</guid>
      <description> 题目大意：有一个5*6的网格图，每个格子都是一个灯，按灯的时候会使这个灯周围其余4个灯改变状态，给出初始状态，问最后按灯的结果；&#xA;题目解析：先暴力出第一行所有按灯的情况，然后从第一行到第五行，如果i，j是亮的话，只能按i+1，j，最后判断最后一行是否全为暗的即可；&#xA;AC代码：&#xA;#include #include #include #include #include #include using namespace std; typedef long long ll; const int maxn = 110; int grid[maxn][maxn],ans[maxn][maxn]; int dx[4]={-1,1,0,0},dy[4]={0,0,1,-1}; int n,t[maxn][maxn],c; void push(int x,int y) { t[x][y]^=1; for(int i=0;i&amp;lt;4;i++) { int u=x+dx[i]; int v=y+dy[i]; if(u&amp;lt;=0||u&amp;gt;5||v&amp;lt;1||v&amp;gt;6) continue; t[u][v]^=1; } } bool ok() { memcpy(t,grid,sizeof(grid)); for(int i=1;i&amp;lt;=6;i++) { if(ans[1][i]) { push(1,i); } } for(int i=1;i&amp;lt;5;i++) { for(int j=1;j&amp;lt;=6;j++) { if(t[i][j]) { ans[i+1][j]=1; push(i+1,j); } else { ans[i+1][j]=0; } } } for(int i=1;i&amp;lt;=6;i++) { if(t[5][i]==1) return false; } return true; } void solve() { for(int i=0;i&amp;lt;(1&amp;lt;&amp;lt;6);i++) { for(int j=0;j&amp;lt;6;j++) { if(i&amp;amp;(1&amp;lt; </description>
    </item>
    <item>
      <title>设置-wifi-高级设置，选择仅充电时保持WLAN开启/睡眠期间不保持wlan的开启状态，手机锁屏休眠几分钟后，再点亮屏幕，wifi一直显示开启状态</title>
      <link>https://anwangtanmi.github.io/posts/baef10b22b9a2de9a54b94edf7e25a5f/</link>
      <pubDate>Wed, 07 Jan 2015 09:56:36 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/baef10b22b9a2de9a54b94edf7e25a5f/</guid>
      <description>解决方法：缩短响应的时间；&#xA;具体方法：&#xA;路径：frameworks/base/services/java/com/android/server/wifi/WifiController.java&#xA;代码： class WifiController extends StateMachine {&#xA;* being enabled but not active exceeds the battery drain caused by&#xA;* re-establishing a connection to the mobile data network.&#xA;*/&#xA;– private static final long DEFAULT_IDLE_MS = 15 * 60 * 1000; /* 15 minutes */&#xA;+ private static final long DEFAULT_IDLE_MS = 1 * 60 * 1000; /* 1 minutes */</description>
    </item>
    <item>
      <title>Altium designer手工布线技巧 边总结别更新</title>
      <link>https://anwangtanmi.github.io/posts/c0e577417e26a7d889cfe6f3ce92e480/</link>
      <pubDate>Thu, 07 Nov 2013 10:04:22 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/c0e577417e26a7d889cfe6f3ce92e480/</guid>
      <description>本人小菜鸟，布线都是用的自动布线然后手动修改，今天被公司里面的大神们跟教育了。。。为啥呢？ 自动布线的产品80%都不能通过静电等测试~~我也不知为啥，然后开始手工布线。。。。&#xA;技巧我也不知道，就是边使用边总结，边写边更新吧。&#xA;1.善用Ctrl+鼠标左键。 这个组合键的功能就是 让相同网络口的接线口或者线高亮，其他部分变暗（比只是鼠标移动到线或者端口上的对比要明显很多，方便布局布线）&#xA;2.善用鼠标右键和CTRL+滚轮 为啥有事CTRL键呢，当你按住CTRL滚动鼠标滚轮的时候，会缩放或者放大当前的图，配合鼠标右键拖放，会使你的图纸在你的手里非常灵活（视角）。&#xA;11.07&#xA;3.布局顺序（先大后小，先核心后次，先难后易，先特殊后一般原则）&#xA;4.走线的时候 按shift+space可以改变走线方式，如电源等大电流部分 应该使用弧形角&#xA;11.07&#xA;暂时这些，待发现和更新，有什么我不知道的望csdn或者同行的高手们指点一二，共同进步~~&#xA;5.n-show-all 可以选择显示全部网络口和隐藏&#xA;6.敷铜的时候经常明明选着了连接到某个网络，但是敷铜的时候不能连接， 在设计–规则-Plan-Polygon Connect Style 中 PolygonConnect 项中约束这关联类型选择Direct Connect就可以了</description>
    </item>
    <item>
      <title>YUV422转BGR888（海思3516平台）</title>
      <link>https://anwangtanmi.github.io/posts/3bb21b9141514cdbf080b538b9bfe0c3/</link>
      <pubDate>Fri, 15 Mar 2013 09:14:55 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/3bb21b9141514cdbf080b538b9bfe0c3/</guid>
      <description>#include &#34;hi_comm_ive.h&#34; #include &#34;mpi_ive.h&#34; #pragma pack(1) typedef struct{ short type; int size; short reserved1; short reserved2; int offset; } BMPHeader; typedef struct{ int size; int width; int height; short planes; short bitsPerPixel; unsigned compression; unsigned imageSize; int xPelsPerMeter; int yPelsPerMeter; int clrUsed; int clrImportant; } BMPInfoHeader; #pragma pack() int saveBMPFile(unsigned char* src, int width, int height, const char* name){ BMPHeader hdr; BMPInfoHeader infoHdr; int ret = 0; FILE* fp = NULL; if(NULL == src) { return (-1); } fp = fopen(name,&#34;</description>
    </item>
  </channel>
</rss>
