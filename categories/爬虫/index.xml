<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>爬虫 on 暗网探秘</title>
    <link>https://anwangtanmi.github.io/categories/%E7%88%AC%E8%99%AB/</link>
    <description>Recent content in 爬虫 on 暗网探秘</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 22 Jan 2019 09:36:24 +0800</lastBuildDate>
    <atom:link href="https://anwangtanmi.github.io/categories/%E7%88%AC%E8%99%AB/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>awesome-spider</title>
      <link>https://anwangtanmi.github.io/posts/063d57c51c9afe356132b4e0f4c45aea/</link>
      <pubDate>Tue, 22 Jan 2019 09:36:24 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/063d57c51c9afe356132b4e0f4c45aea/</guid>
      <description>awesome-spider 收集各种爬虫 （默认爬虫语言为 python）, 欢迎大家 提 pr 或 issue, 收集脚本见此项目 github-search&#xA;A 暗网爬虫(Go) 爱丝APP图片爬虫 B Bilibili 用户 Bilibili 视频 Bilibili 小视频 Bing美图爬虫 B站760万视频信息爬虫 博客园(node.js) 百度百科(node.js) 北邮人水木清华招聘 百度云网盘 琉璃神社爬虫 Boss 直聘 C cnblog caoliu 1024 D 豆瓣读书 豆瓣爬虫集 豆瓣害羞组 豆瓣图书广度爬取 DNS记录和子域名 DHT网络磁力种子爬虫 抖音 E E绅士 G Girl-atlas girl13 github trending Github 仓库及用户分析爬虫 H HDOJ爬虫 I Instagram INC500 世界5000强爬虫 J 京东 京东搜索+评论 京东商品+评论 机票 煎蛋妹纸 煎蛋妹纸selenium版本 今日头条，网易，腾讯等新闻 计算机书籍控图书 K 看知乎 课程格子校花榜 konachan L 链家 链家成交在售在租房源 拉勾 炉石传说 leetcode 领英销售导航器爬虫 LinkedInSalesNavigator M 马蜂窝 用户足迹 MyCar 漫画喵 一键下载漫画~ MM131性感美女写真图全爬取 美女写真套图爬虫 （一）（二）（三） 妹子图 猫眼网电影评分 N 新闻监控 你好污啊 O ofo共享单车爬虫 P Pixiv PornHub packtpub 91porn Q QQ空间 QQ 群 清华大学网络学堂爬虫 去哪儿 前程无忧Python招聘岗位信息爬取分析 R 人人影视 RSS 爬虫 rosi 妹子图 reddit 壁纸 reddit S soundcloud Stackoverflow 100万问答爬虫 Shadowsocks 账号爬虫 spider163 网易云音乐爬虫 时光网电影数据和海报爬虫 T tumblr 下载tumblr喜欢内容 TuShare 天猫双12爬虫 Taobao mm Tmall 女性文胸尺码爬虫 淘宝直播弹幕爬虫(node) 天涯论坛文章 V Youtube字幕下载 视频信息爬虫 电影网站 W 乌云公开漏洞 微信公众号 “代理”方式抓取微信公众号文章 网易新闻 网易精彩评论 微博主题搜索分析 网易云音乐 新.</description>
    </item>
    <item>
      <title>爬虫系列（四）–全站爬取</title>
      <link>https://anwangtanmi.github.io/posts/151fedb0562137bae1ce00364bd4e1b7/</link>
      <pubDate>Mon, 17 Sep 2018 14:49:39 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/151fedb0562137bae1ce00364bd4e1b7/</guid>
      <description>爬虫系列（四）–全站爬取 全站爬取需要的数据基于一个这样的假设：某网站的页面上存在该网站其他页面的连接，通过这些连接跳转的新的页面进行数据的爬取。在开始这个之前，要先明白栈和队列。本篇中介绍的是单线程的实现方式，大规模的爬取需要多线程，分布式爬取。&#xA;1.实现步骤 （1）准备几个起始链接加入待队列Q中，例如Q=[“http://www.xxx.com/aaa/”,”http://www.xxx.com/bbb/”,”http://www.xxx.com/ccc/”]&#xA;（2）并将这几个链接加入一个入队集合S中,S={“http://www.xxx.com/aaa/”,”http://www.xxx.com/bbb/”,”http://www.xxx.com/ccc/”}这个集合作用是保证一个网页只爬取一次。&#xA;（3）从Q中取出一个链接url（出队，取出队首元素，并从队列中删除该元素），如果Q中没有链接，结束爬取。如果有链接url=”http://www.xxx.com/aaa/”，进行（4）步骤。&#xA;（4）对url爬取，保存需要的数据（写到文件中，建议使用json格式保存，一行一个页面），找出该页面上的所有链接urls&#xA;（5）把符合我们要求的连接（例如以http://www.xxx.com 开头的链接）找出来，判断每一个连接urli是否在S中。如果不在S中，把urli加入S，urli入队&#xA;（6）继续执行（3）步骤&#xA;注意1：这个是广度优先爬取，如果把队换成栈，会变成深度优先爬取。如果没有特殊的需求，一般都是使用广度优先爬取。&#xA;注意2：对于一个小网站来说，这样操作没有什么问题，但是有些网站页面很多，Q和S中存储的连接太多直接撑爆内存，这时可以实现一个硬盘队列（栈）和硬盘集合，本系列文章不实现这些功能。&#xA;注意3：有些网站的连接到站内的url形如”/aaa?a=1&amp;amp;b=2″,需要改写成”http://域名/aaa?a=1&amp;amp;b=2″&#xA;注意4：有些网站会根据短时间内一个ip访问大量页面制定反爬虫策略，可以爬取一个页面后，休眠一段时间接着爬取&#xA;2.代码实现(代码仅对于代码中要爬取的网站有效，其他网站需要重新配置规则) import time import os import json from urllib import request from lxml import etree header_dict = { &#34;Accept&#34;:&#34;application/json, text/javascript, */*; q=0.01&#34;, &#34;Accept-Language&#34;:&#34;zh-CN,zh;q=0.9&#34;, &#34;User-Agent&#34;:&#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36&#34;, } def get_http(load_url,header=None): res=&#34;&#34; try: req = request.Request(url=load_url,headers=header)#创建请求对象 coonect = request.urlopen(req)#打开该请求 byte_res = coonect.read()#读取所有数据，很暴力 try: res=byte_res.decode(encoding=&#39;utf-8&#39;) except: try: res=byte_res.decode(encoding=&#39;gbk&#39;) except: res=&#34;</description>
    </item>
    <item>
      <title>python爬虫之反爬虫情况下的煎蛋网图片爬取初步探索</title>
      <link>https://anwangtanmi.github.io/posts/86ecec2863a5322d364162559d421c4b/</link>
      <pubDate>Wed, 06 Dec 2017 19:04:02 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/86ecec2863a5322d364162559d421c4b/</guid>
      <description>本次爬虫网址：http://jandan.net/ooxx&#xA;前言： 前段时间一直在折腾基于qqbot的QQ机器人，昨天用itchat在微信上也写了一个机器人，相比webqq，微信的web端功能比较丰富，图片、文件等都可以传输。今天闲来无事准备给写个爬虫丰富微信机器人的功能，就想到了爬煎蛋网上面的图片。&#xA;说做就做，打开浏览器一看，渲染前的源码里是没有图片地址的。这个很正常，首先想到的就是异步请求去获取例如json格式的图片地址，然后渲染在页面上。于是用Chrome的全局搜索功能尝试搜了一下某一张图片的地址，结果居然是没有搜到。早就耳闻煎蛋被爬虫弄得苦不堪言，看来也开始采取一些措施了。于是去GitHub上搜了一下jiandan关键词，按时间排序，发现靠前的几个项目要不就没意识到煎蛋的反爬从而还是在用原来的方式直接处理源码，要不就是在用selenium（web自动化框架，可参考我的这篇文章：点击打开链接）进行爬虫。看来这个简单的这个反爬机制是最近一个月才用上的，很不凑巧被我撞上了。用selenium确实是一种万能、省力的方式，但实在太耗费性能。我在我阿里云的服务器上放了一个selenium+chromeheadless的微博爬虫，每次爬虫运行的时候服务器都非常卡。加上对煎蛋的反爬机制挺好奇的，于是我就准备通过分析js来找出图片的请求地址。&#xA;正文： 首先查看js渲染前的html源码，发现放图片的位置是这样的&#xA;本该放地址的地方赫然放着blank.gif，并且在onload属性上绑定了一个jandan_load_img函数。这个jandan_load_img就成为本次爬虫的突破所在了。继续ctrl+shift+F全局搜索，找到这个函数&#xA;function jandan_load_img(b) { var d = $(b); var f = d.next(&#34;span.img-hash&#34;); var e = f.text(); f.remove(); var c = f_K1Ft7i9UekcAhptpgQlLRFFKpzH6gOr0(e, &#34;n8DpQLgoyVr2evbxYcQyFzxk9NRmsSKQ&#34;); var a = $(&#39;[查看原图]&#39;); d.before(a); d.before(&#34;&#xA;&#34;); d.removeAttr(&#34;onload&#34;); d.attr(&#34;src&#34;, location.protocol + c.replace(/(\/\/\w+\.sinaimg\.cn\/)(\w+)(\/.+\.gif)/, &#34;$1thumb180$3&#34;)); if (/\.gif$/.test(c)) { d.attr(&#34;org_src&#34;, location.protocol + c); b.onload = function() { add_img_loading_mask(this, load_sina_gif) } } } 果然就是这个函数在处理图片相关的标签，写在一个单独的js文件里。容易看到，第7、8行将a标签插入到img之前，查看源码看到a标签就是是查看原图的链接，也就是我们接下来爬取的时候用到的地址了。第6行f_后跟着一长串字母的这个函数(简称f函数)返回的就是图片地址。第7行中replace函数的作用是当图片为gif时替换中间的一个字符串为large。&#xA;那么接下来的任务就是分析f函数到底是怎么获取图片的地址的。首先看参数，第一个参数e为img-hash标签的text，第二个参数则是一个常量。这个常量我实测是会变化的，所以需要我们去请求这个js文件然后用正则去匹配到该常量。js文件的地址则写在了html源码里，文件名应该也是会变化的，也是用正则去匹配到。拿到常量之后接下来仍然使用chrome全局搜索（注：最好是打上断点跳过去，同一个js文件里的第605行和第943行有两个f函数可能会造成干扰，参见本文评论区），找到f函数，我发现此函数只是在做一些md5、base_64加密等操作，并不算复杂，可以将js代码转为python运行。当然也可以选择直接运行js，不过应该也是比较耗费性能的。我在转化成python代码的过程中，在base64解码上耗费了较长时间，也说明了自己在字符编码方面的知识比较薄弱。&#xA;下面是我对转换的一点解释，把一些无意义的ifelse等代码精简掉，再把代码分成五块之后，f函数长这样：&#xA;var f_K1Ft7i9UekcAhptpgQlLRFFKpzH6gOr0 = function(m, r, d) { var q = 4; r = md5(r); var o = md5(r.</description>
    </item>
    <item>
      <title>python爬虫代理IP池(proxy pool)</title>
      <link>https://anwangtanmi.github.io/posts/c400ee992726fc5efc4e9cfef47ef0e8/</link>
      <pubDate>Thu, 14 Sep 2017 10:51:18 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/c400ee992726fc5efc4e9cfef47ef0e8/</guid>
      <description>1.今天我们来讲下一个非常有用的东西，代理ip池，结果就是一个任务每隔一定时间去到 目标ip代理提供网站（www.bugng.com）去爬取可用数据存到mysql数据库，并且检测数据库已有数据是否可用，不可用就删除。&#xA;2. 编写 提取代理ip到数据库 的爬虫&#xA;2.1准备mysql表&#xA;CREATE TABLE `t_ips` ( `id` int(10) NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;, `ip` varchar(15) COLLATE utf8_unicode_ci DEFAULT NULL COMMENT &#39;ip&#39;, `port` int(10) NOT NULL COMMENT &#39;port&#39;, `type` int(10) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;0:http 1:https&#39;, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=421 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci COMMENT=&#39;ip表&#39;; 2.2创建爬虫工程，编写items.py(对应数据库的字段)&#xA;import scrapy class IpsItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() ip = scrapy.</description>
    </item>
    <item>
      <title>从信息泄密谈到爬虫</title>
      <link>https://anwangtanmi.github.io/posts/607ad3eee6d5d93ceac5a6f340befa4e/</link>
      <pubDate>Mon, 20 Mar 2017 09:33:50 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/607ad3eee6d5d93ceac5a6f340befa4e/</guid>
      <description>转载地址：http://www.hackbase.com/article-216889-1.html 从信息泄密谈到爬虫 2017-3-17 11:16|投稿: xiaotiger|来自: 互联网&#xA;摘要: 2016年8月，一位自称“Peace”的黑客声称盗取了2亿雅虎用户账户和密码，并寻求在暗网(dark web)上进行售卖。黑客所声称的2亿条信息的泄露似乎盗取自2012年，同时发生的还有MySpace（3.6亿条）和Linkedln（1亿条）两 … 2016年8月，一位自称“Peace”的黑客声称盗取了2亿雅虎用户账户和密码，并寻求在暗网(dark web)上进行售卖。黑客所声称的2亿条信息的泄露似乎盗取自2012年，同时发生的还有MySpace（3.6亿条）和Linkedln（1亿条）两家网站的信息泄露。&#xA;有趣的是 Linkedln 的泄露事件还间接导致了扎克伯格的推特账号被黑。因为扎克伯格在两个网站都使用了同一个密码：“dadada”……&#xA;在信息化时代，数据泄露无处不在，这种风险可能来自于我们上网的每一个步骤。下面笔者将介绍一种批量获取信息的方式——爬虫。编程语言基于Python，如果对这门语言不是很熟悉可以先了解下它的语法结构。本文将对于爬虫做一个简单入门介绍。&#xA;关于爬虫 我们一直在说的爬虫究竟是个什么鬼？&#xA;网络爬虫（web crawler），是一个自动提取网页的程序，它为搜索引擎从网路上下载网页。传统爬虫从一个或若干初始网页的URL开始，获得初始网页上的URL，在抓取网页的过程中，不断从当前页面上抽取新的URL放入队列，直到满足系统的一定停止条件。另外，所有被爬虫抓取的网页将会被系统存贮，进行一定的分析、过滤，并建立索引，以便之后的查询和检索。&#xA;（摘自百度百科）&#xA;简单来讲，爬虫是通过程序或者脚本获取网页上的一些文本、图片、音频的数据。&#xA;从笔者的经验来看，做一个简单的爬虫程序有以下几个步骤：确立需求、网页下载、网页分析与解析、保存。接下来大家可以跟随笔者的流程，我们来写个抓取豆瓣书籍信息的爬虫。&#xA;1、需求&#xA;以豆瓣读书为例，我们爬取豆瓣的书籍信息，需要获取的信息包括：图书名称，出版社，作者，年份，评分。&#xA;2、网页下载&#xA;页面下载分为静态和动态两种下载方式。&#xA;静态主要是纯 html 页面，动态是网页会使用 javascript 处理，并通过Ajax 异步获取的页面。在这里，我们下载的是静态页面。&#xA;在下载网页的过程中我们需要用到网络库。在 Python 中有自带的 urllib、urllib2 网络库，但是我们一般采用基于 urllib3 的第三方库Requests ，这是一个深受 Pythoner 喜爱的更为高效简洁的网络库，能满足我们目前的 web 需求。&#xA;3、网页分析与解析&#xA;1）网页分析：&#xA;选好网络库后我们需要做的是：分析我们要爬取的路径——也就是逻辑。&#xA;这个过程中我们要找到爬取的每一个入口，例如豆瓣读书的页面。已知图书标签的 url，点击每个 url 能得到图书列表，在图书列表中存放需要的图书信息，求解如何获得图书信息。&#xA;所以很简单！我们的爬取路径就是：图书标签 url —&amp;gt; 图书列表—&amp;gt;图书信息。&#xA;2）网页解析：&#xA;网页解析主要就是通过解析网页源代码获取我们需要的数据，网页解析的方式有很多种，如：正则表达式， BeautifulSoup， XPath 等等，在这里我们采用的是 XPath。Xpath 的语法很简单，是根据路径来进行定位。&#xA;举个栗子：上海的位置是 地球—中国—上海，语法表达为 //地球/中国[@城市名=上海]&#xA;接下来我们需要解析网页获取到图书的 tag 标签的url。打开网页，右击选择审查元素，然后就会出现调试工具，左上角点击获取我们需要的数据，下面的调试窗口就会直接定位到其所在代码。</description>
    </item>
    <item>
      <title>爬虫第二弹——隐网爬虫指南，AcFun评论爬取教程</title>
      <link>https://anwangtanmi.github.io/posts/8ea97b0b63d81fffe86ab31c027ded51/</link>
      <pubDate>Sun, 03 Jul 2016 17:38:05 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/8ea97b0b63d81fffe86ab31c027ded51/</guid>
      <description>爬虫第一弹：利用Scrapy爬取1905电影网&#xA;啊啊啊！！！！写完没保存！！！！还得重新写一遍！！！！！好气啊！！！！！！&#xA;前言 AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。 通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 AJAX）如果需要更新内容，必须重载整个网页页面。 因此现在有很多网站都是用Ajax进行前后端数据交互的。&#xA;然而正是因为很多网站使用Ajax导致网络爬虫无法跟进。 这时就需要我们针对不同的网站定制爬虫。&#xA;AcFun 评论数据传输分析 页面分析 首先测试爬去使用Ajax传输数据的网站的效果，我们以AcFun视频为例。&#xA;打开页面http://www.acfun.tv/v/ac2860882，下图所示是当前页面是直接在浏览器打开的效果，可以看到红色框内的就是当前页面的评论。&#xA;下图是通过爬虫爬去该网页的结果，可以看到红色框内并没有评论，因为当前评论没有传过来。 寻找数据 我们现在利用Chrome浏览器的Developer Tools寻找数据。 打开原页面，在当前页面上邮件选择检查，进入到Developer Tools后选择Network。在Network中选择XHR(数据)，再刷新当前页面，从左侧列表中寻找评论数据（注意：数据需要从右侧栏需选择Preview栏才可以看到） 构建评论url 我们发现评论是通过comment_list_json.aspx页面发送过来的。 这时我们点开该页面的Query String Parameters查看参数&#xA;这个json请求一共有两个参数，且其含义也不难理解&#xA;contentId(2860882)：当前页面编号，与当前页面URL（http://www.acfun.tv/v/ac2860882）相同 currentPage(1)：评论页号 于是这个json请求的url如下所示： http://www.acfun.tv/comment_list_json.aspx?contentId=%1&amp;amp;currentPage=%2&#xA;得知url的形式后就可以开始写爬虫了！&#xA;程序 理论上所有图灵完备的语言都可以写爬虫，但为了效率与保持心情愉悦我推荐用Python。&#xA;我平时喜欢用Scrapy或urllib2写，Scrapy适合中到大规模且爬取逻辑简单的爬虫，如果遇到非常复杂或者是非常简单的爬虫，那么就需要用urllib2定制了，想学Scrapy可以看我的爬虫第一弹&#xA;本文致力于一切从简的思想，使用urllib2写一个小的Demo.&#xA;#encoding=utf-8 import urllib2 import json def get_page(url): try: timeout = 5 request = urllib2.Request(url) #伪装HTTP请求 request.add_header(&#39;User-agent&#39;, &#39;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36&#39;) request.add_header(&#39;connection&#39;,&#39;keep-alive&#39;) request.add_header(&#39;referer&#39;, url) # request.</description>
    </item>
  </channel>
</rss>
