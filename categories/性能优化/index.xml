<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>性能优化 on 暗网探秘</title>
    <link>https://anwangtanmi.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
    <description>Recent content in 性能优化 on 暗网探秘</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 17 Jan 2019 13:21:35 +0800</lastBuildDate>
    <atom:link href="https://anwangtanmi.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>(wake_lock)后台任务 – 保持设备唤醒状态</title>
      <link>https://anwangtanmi.github.io/posts/914d0118d767db49f9d6be4c2571edc6/</link>
      <pubDate>Thu, 17 Jan 2019 13:21:35 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/914d0118d767db49f9d6be4c2571edc6/</guid>
      <description>(wake_lock)后台任务 – 保持设备唤醒状态&#xA;代码中植入：https://blog.csdn.net/wdx_1136346879/article/details/86522768&#xA;当Android设备空闲时，屏幕会变暗，然后关闭屏幕，最后会停止CPU的运行，这样可以防止电池电量掉的快。在休眠过程中自定义的Timer、Handler、Thread、Service等都会暂停。但有些时候我们需要改变Android系统默认的这种状态：比如玩游戏时我们需要保持屏幕常亮，比如一些下载操作不需要屏幕常亮但需要CPU一直运行直到任务完成。&#xA;保持屏幕常亮&#xA;最好的方式是在Activity中使用FLAG_KEEP_SCREEN_ON 的Flag。&#xA;public class MainActivity extends Activity {&#xA;@Override&#xA;protected void onCreate(Bundle savedInstanceState) {&#xA;super.onCreate(savedInstanceState);&#xA;setContentView(R.layout.activity_main);&#xA;getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);&#xA;}&#xA;}&#xA;这个方法的好处是不像唤醒锁（wake locks），需要一些特定的权限（permission）。并且能正确管理不同app之间的切换，不用担心无用资源的释放问题。&#xA;另一个方式是在布局文件中使用android:keepScreenOn属性：&#xA;… android:keepScreenOn = ” true “的作用和FLAG_KEEP_SCREEN_ON一样。使用代码的好处是你允许你在需要的地方关闭屏幕。&#xA;注意：一般不需要人为的去掉FLAG_KEEP_SCREEN_ON的flag，windowManager会管理好程序进入后台回到前台的的操作。如果确实需要手动清掉常亮的flag，使用getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)&#xA;保持CPU运行&#xA;需要使用PowerManager这个系统服务的唤醒锁(wake locks)特征来保持CPU处于唤醒状态。唤醒锁允许程序控制宿主设备的电量状态。创建和持有唤醒锁对电池的续航有较大的影响，所以，除非是真的需要唤醒锁完成尽可能短的时间在后台完成的任务时才使用它。比如在Acitivity中就没必要用了。如果需要关闭屏幕，使用上述的FLAG_KEEP_SCREEN_ON。&#xA;只有一种合理的使用场景，是在使用后台服务在屏幕关闭情况下hold住CPU完成一些工作。 要使用唤醒锁，如果不使用唤醒锁来执行后台服务，不能保证因CPU休眠未来的某个时刻任务会停止，这不是我们想要的。 (有的人可能认为我以前写的后台服务就没掉过链子呀运行得挺好的，1.可能是你的任务时间比较短；2.可能CPU被手机里面很多其他的软件一直在唤醒状态。)。下面是很多网友有同样的问题：&#xA;唤醒锁可划分为并识别四种用户唤醒锁：&#xA;标记值 CPU 屏幕 键盘&#xA;PARTIAL_WAKE_LOCK&#xA;开启 关闭 关闭&#xA;SCREEN_DIM_WAKE_LOCK&#xA;开启 变暗 关闭&#xA;SCREEN_BRIGHT_WAKE_LOCK&#xA;开启 变亮 关闭&#xA;FULL_WAKE_LOCK&#xA;开启 变亮 变亮&#xA;请注意，自 API 等级 17 开始，FULL_WAKE_LOCK 将被弃用。 应用应使用 FLAG_KEEP_SCREEN_ON。</description>
    </item>
    <item>
      <title>性能优化十六之Wake_Lock唤醒锁以及JobScheduler使用</title>
      <link>https://anwangtanmi.github.io/posts/fd0780c8b40ca90d8d767d760ec3d41f/</link>
      <pubDate>Fri, 14 Apr 2017 20:57:05 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/fd0780c8b40ca90d8d767d760ec3d41f/</guid>
      <description>前言 上一篇博客记录了电量优化中的第一种优化，把一些不需要及时和用户交互的一些操作，放到当用户插上电源的时候。根据自己目前的知识了解，只知道三种优化方式，第二种和第三种方式接下来进行介绍。&#xA;第二种方式：网络类型选择优化 目前大部分手机都支持4G网络，殊不知蜂窝移动信号是在所有的网络类型中是最消耗电量的，很多人在使用手机的过程中，发现如果一直在使用4G移动网络，电量会持续不了多久就没电了，而相对来说WIFI会比蜂窝移动信号的电量消耗会小很多，所以我们在开发过程中可以将某些操作放在连接WIFI后进行操作。如何去判读网络类型的代码例子，网上都有。&#xA;第三种方式：wake_lock wakelock是个什么东西呢？查了很多资料了解到它是一个唤醒锁，什么是唤醒锁？它主要是相对系统的休眠而言的，意思就是我的程序给CPU加了这个锁那系统就不会休眠了，这样做的目的是为了全力配合我们程序的运行。有的情况如果不这么做就会出现一些问题，比如微信等及时通讯的心跳包会在熄屏不久后停止网络访问等问题。所以微信里面是有大量使用到了wake_lock锁(可以利用WLD进行测试)。&#xA;使用场景一：保持屏幕常亮 当Android设备空闲时，屏幕会变暗，然后关闭屏幕，最后会停止CPU的运行，这样可以防止电池电量掉的快。在休眠过程中自定义的Timer、Handler、Thread、Service等都会暂停。但有些时候我们需要改变Android系统默认的这种状态：比如玩游戏时我们需要保持屏幕常亮，比如一些下载操作不需要屏幕常亮但需要CPU一直运行直到任务完成。&#xA;1、保持屏幕常亮，最好的方式是在Activity中使用FLAG_KEEP_SCREEN_ON 的Flag。 public class MainActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); } } 优点：这个方法的好处是不像唤醒锁（wake locks），需要一些特定的权限（permission）。并且能正确管理不同app之间的切换，不用担心无用资源的释放问题(唤醒锁如何使用下面介绍)。 注意：一般不需要人为的去掉flag，WindowManager会管理好程序进入后台回到前台的操作。如果确实需要手动清掉常亮的flag，使用 getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON) 2、布局文件中设置屏幕常亮： 另一个方式是在布局文件中使用android:keepScreenOn属性：&#xA;&amp;lt;RelativeLayout xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34; android:layout_width=&#34;match_parent&#34; android:layout_height=&#34;match_parent&#34; android:keepScreenOn=&#34;true&#34;&amp;gt; &amp;lt; /RelativeLayout&amp;gt; android:keepScreenOn = ” true “的作用和FLAG_KEEP_SCREEN_ON一样。但是使用代码的好处是你允许你在需要的地方关闭屏幕。&#xA;使用场景二：保持CPU运行 需要使用PowerManager这个系统服务的唤醒锁(wake locks)特征来保持CPU处于唤醒状态。唤醒锁允许程序控制宿主设备的电量状态。创建和持有唤醒锁对电池的续航有较大的影响，所以，除非是真的需要唤醒锁完成尽可能短的时间在后台完成的任务时才使用它。比如在Acitivity中就没必要用了。如果需要关闭屏幕，使用上述FLAG_KEEP_SCREEN_ON。&#xA;只有一种合理的使用场景，就是在使用后台服务需要在屏幕关闭情况下hold住CPU完成一些工作。这时就需要使用唤醒锁，如果不使用唤醒锁来执行后台服务，当CPU在未来的某个时刻休眠导致某个时刻任务会停止，这是我们不想看到的。 (有的人可能认为我以前写的后台服务运行得挺好的，1.可能是你的任务时间比较短；2.可能CPU被手机里面很多其他的软件一直在唤醒状态。)。下面是很多网友有同样的问题：&#xA;唤醒锁可划分为并识别四种用户唤醒锁：&#xA;标记值 CPU 屏幕 键盘 PARTIAL_WAKE_LOCK 开启 关闭 关闭 SCREEN_DIM_WAKE_LOCK 开启 变暗 关闭 SCREEN_BRIGHT_WAKE_LOCK 开启 变亮 关闭 FULL_WAKE_LOCK 开启 变亮 变亮 请注意，自 API 等级 17 开始，FULL_WAKE_LOCK 将被弃用，应用应使用FLAG_KEEP_SCREEN_ON 使用方法一： 第一步就是添加唤醒锁权限：</description>
    </item>
  </channel>
</rss>
