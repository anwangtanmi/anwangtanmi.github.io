<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数字图像处理 on 暗网探秘</title>
    <link>https://anwangtanmi.github.io/categories/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</link>
    <description>Recent content in 数字图像处理 on 暗网探秘</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 17 Jan 2017 17:53:19 +0800</lastBuildDate>
    <atom:link href="https://anwangtanmi.github.io/categories/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>图像对比度增强算法</title>
      <link>https://anwangtanmi.github.io/posts/cb79f6f17562c7263cce9005c5e4191e/</link>
      <pubDate>Tue, 17 Jan 2017 17:53:19 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/cb79f6f17562c7263cce9005c5e4191e/</guid>
      <description>一、全局对比度增强&#xA;1&#xA;1. 直方图均衡化 Histogram Equalization a. 基本思想 对于图像中的灰度点做映射，使得整体图像的灰度大致符合均匀分布。增强图像的对比度。 – 对于灰度值连续的情况，使用灰度的累积分布函数CDF做转换函数，可以使得输出图像的灰度符合均匀分布。 – 对于灰度值不连续的情况，存在舍入误差，得到的灰度分布大致符合均匀分布。 – 直观地理解，如果某一个灰度范围（如200-201）的像素点很少，那么它的概率密度值就会很小，所以CDF在200-201附近的增长变化就会很小；反之，如果某一个灰度范围（如100-101）的像素点很多，CDF在100-101附近的增长变化会很大。总体来看，以灰度为横轴，CDF为纵轴画曲线。这种向上凸的曲线，很像gamma变换: s=crγ&#xA;中&#xA;γ&amp;lt;1&#xA;的情形。将灰度集中的部分拉伸，而将灰度不集中的部分压缩，达到提高对比度的效果。 – 直方图均衡可以看做自适应的gamma变换或者分段变换。前者的优势在于，不需要指定任何参数，所有运算都是基于图像本身的。&#xA;b. 算法 根据图像灰度计算灰度概率密度函数&#xA;PDF&#xA;计算累积概率分布函数&#xA;CDF&#xA;将&#xA;CDF&#xA;归一化到原图灰度取值范围，如[0,255]。 之后&#xA;CDF&#xA;四舍五入取整，得到灰度转换函数&#xA;sk=T(rk)&#xA;将&#xA;CDF&#xA;作为转换函数，将灰度为&#xA;rk&#xA;的点转换为&#xA;sk&#xA;灰度 c. matlab实验 代码&#xA;2&#xA;：&#xA;%% 直方图均衡 clear all;clc;close all; ImgFile=&#39;E:\图像处理\冈萨雷斯图片库\DIP3E_Original_Images_CH03\Fig0310(b)(washed_out_pollen_image).tif&#39;; ImgIn=imread(ImgFile); ImgHistEq=histeq(ImgIn,256); figure;subplot(121);imshow(uint8(ImgIn));title(&#39;原图&#39;); subplot(122);imshow(ImgHistEq);title(&#39;全局灰度增强 - 直方图均衡&#39;); figure;subplot(121);imhist(ImgIn,256); axis([0 255 0 1e5]);title(&#39;原图的直方图&#39;); subplot(122);imhist(ImgHistEq,256);axis([0 255 0 1e5]);title(&#39;直方图均衡化后的直方图&#39;); % 自定义直方图均衡 [counts,x]=imhist(ImgIn,256); cum_counts=cumsum(counts); cum_counts=uint8(cum_counts/max(cum_counts)*255);% 转化函数 figure;plot(x,cum_counts);axis([0 255 0 255]); xlabel(&#39;原图灰度&#39;);ylabel(&#39;转换后灰度&#39;);title(&#39;原图CDF转化的灰度映射函数&#39;); ImgOut=nan(size(ImgIn)); for i=1:length(x) ImgOut(ImgIn==x(i))=cum_counts(i); end ImgOut=uint8(ImgOut); figure;imshow(uint8(ImgOut));title(&#39;自定义直方图均衡&#39;) figure;imhist(ImgOut,256);axis([0 255 0 1e5]);title(&#39;自定义直方图均衡的直方图&#39;) 输出： 图1.</description>
    </item>
    <item>
      <title>RGB图像之灰度级和通道的理解</title>
      <link>https://anwangtanmi.github.io/posts/ffdd28e4d0627cb4cb69026df007d861/</link>
      <pubDate>Wed, 21 Dec 2016 18:58:24 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/ffdd28e4d0627cb4cb69026df007d861/</guid>
      <description>最近刚开始学数字图像处理，在看到灰度级时候以为灰度只是表示黑白/深浅色图像，其实灰度级指黑白显示器中显示像素点的亮暗差别，在彩色显示器中表现为颜色的不同，灰度级越多，图像层次越清楚逼真。&#xA;注意，灰度值只是表征单色的亮暗程度。&#xA;在彩色图像/RGB图像中，图像是一个三维矩阵，如4003003，其中400表示列数，300表述行数，3代表三个分量，也就是R,G,B。&#xA;每一层矩阵（4003001/2/3）分别对应R/G/B的灰度值，此处的矩阵仅仅表示对应单色光灰度值，不是彩色的图像。&#xA;数字图像的本质是一个多维矩阵&#xA;我们先为以一个RGB色彩空间的400*300的图片为例：&#xA;这幅图的本质是一个4003003的一个矩阵&#xA;PI[ 400, 300, 3 ]&#xA;列 行 分量&#xA;说明这个图像有400列，300行，以及在色彩上有三个分量，分别是：&#xA;每个分量单独拿出来都是一个400*300（*1）的矩阵&#xA;如你所见，它们并不是彩色的，而是一幅灰度图像&#xA;对于一副8bit的图像来说，矩阵元素的取值范围是从0-255（0 – 2^8-1）&#xA;矩阵中的元素对应我们所说的像素（pixel），其值即该像素的灰度值，数值越大，像素的颜色越‘白/浅’；数值越小，像素的颜色越’黑/深‘&#xA;对于图像每个分量来说，它只是灰度，谈论色彩没有意义，它是“黑白”的！（用黑白来描述灰度图像并不准确，用深浅可能更准确一些，但也不严谨。所以我加上了引号。你要愿意把通道设成红色绿色紫色黄色都行）&#xA;在图像显示时，我们把图像的R分量放进红色通道里，B分量放进蓝色通道里，G分量放进绿色通道里。经过一系列处理，显示在屏幕上的就是我们所看到的彩色图像了。&#xA;所以说，通道和一幅图像根本就没关系！数字图像是矩阵，矩阵只描述其空间位置和在色彩上的分量，哪有通道了？通道是什么？CHANNEL！图片中有channel这个概念吗？有个回答说通道类似颜料，这个意思就有点接近了。&#xA;想要什么颜色，对应的通道里的灰度值就大一点就行了&#xA;回到上面那幅图，先看彩色的，两人坐的椅子是红色的（有点偏色，不过不重要）&#xA;再看下面的RGB三分量。R分量的图上，椅子对应的部分比较浅（灰度值高），而在G分量和了B分量上很深。&#xA;随便在椅子上取一个样点，其灰度值分别是（R:179,G:45,B:9）。所以在显示的时候，红色通道里灰度值大，绿色通道和蓝色通道里的灰度值小，显示出来的就是红色（绿色通道里的灰度值又比蓝色大一些，所以最终显示的结果有点接近橘红色）&#xA;再看乔帮主的牛仔裤，蓝色通道的灰度值大，绿色其次，红色最少，所以显示为蓝青色。&#xA;如果我们交换一下分量放置的顺序，把G分量放进红色通道里，把R分量放进绿色通道里，B分量放进蓝色通道里，会怎么样呢&#xA;此时绿通道中的灰度值最大，红色通道和蓝色通道中的灰度值都较低&#xA;于是就变成了这样&#xA;[外链图片转存失败(img-jgutNY7F-1568455078494)(https://img-blog.csdn.net/20161221185547020?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2lsZW5jZTIwMTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)]&#xA;还可以这样变成蓝色了&#xA;能理解这种交换通道的原理，就基本能够理解通道的含义了&#xA;网上很多人把通道和选区混为一谈，这是错误的，不利于对图像处理更深一步的理解。当然在ps中有个通道混合器，不仅仅是交换通道这么简单，玩法更加丰富&#xA;这里只介绍了RGB模式下的通道。&#xA;这些所谓的xxx模式，其实就是把我们看到的颜色，用不同的方式表达出来。我们熟知的RGB色彩空间，就是把一种颜色，用RGB三个分量表达出来。此外还有CMYK（四个分量）、Lab（三个）、HSV（三个）等等。不同色彩空间之间的关系，类似于空间直角坐标系(x,y,z)，球坐标系(r,φ,θ)或柱坐标(r,φ,z)之间的关系。&#xA;此外还有一些特殊的通道，如alpha通道（存放透明度）等&#xA;上面的例子引自知乎 嗜睡者知乎原链接</description>
    </item>
    <item>
      <title>数字图像处理编成入门笔记——第四章图象的半影调和抖动技术</title>
      <link>https://anwangtanmi.github.io/posts/b8421dd4d27316d3ae9cfbd6ac66805e/</link>
      <pubDate>Thu, 05 Aug 2010 15:31:00 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/b8421dd4d27316d3ae9cfbd6ac66805e/</guid>
      <description>1. 黑白二值图：只由黑点和白点组成，表现出灰色图象的效果。黑点越多，图像就暗点，反之，图像就亮点。&#xA;2. 半影调技术：由二值图象显示出灰度效果的方法。它的一个主要用途就是在只有二值输出的打印机上打印图象。主要的两种方法：图案法和抖动法。&#xA;4.1 图案法&#xA;1. 图案法是指灰度可以用一定比例的黑白点组成的区域表示，从而达到整体图象的灰度感。黑白点的位置选择称为图案化。&#xA;2. 分辨率，单位是dpi(dot per inch)，即每英寸点数，点数越多，分辨率就越高，图象就越清晰。显示器的尺寸（英寸）是指对角线。&#xA;3. 像素点灰度的表示方法（图案）：如果这16×16的方块中一个黑点也没有，就可以表示灰度256；有一个黑点，就表示灰度255；依次类推，当都是黑点时，表示灰度0。这样，16×16的方块可以表示257级灰度。&#xA;4. 图案的构成：有规则的图案和随机的图案。一般情况下，有规则的图案比随即图案能够避免点的丛集，但有时会导致图象中有明显的线条。&#xA;5. 标准图案：一个整数矩阵。例如要表示256级灰度，则其中的每个值从0到255。图象的实际灰度和阵列中的每个值比较，当该值大于等于灰度时，对应点打一黑点。&#xA;6. 设计标准图案的算法：（由Limb在1969年提出的）&#xA;先以一个2×2的矩阵开始：设M1= ，通过递归关系有Mn+1= ，其中Mn和Un均为2n×2n的方阵，Un的所有元素都是1。根据这个算法，可以得到M2= ，为16级灰度的标准图案。&#xA;M3(8×8阵)比较特殊，称为Bayer抖动表。M4是一个16×16的矩阵。&#xA;7. 在不改变原图的大小下，使用利用图案化技术：设原图是256级灰度，利用Bayer抖动表，做如下处理：&#xA;if (g[y][x]&amp;gt;&amp;gt;2) &amp;gt; bayer[y&amp;amp;7][x&amp;amp;7] then 打一白点 else 打一黑点&#xA;其中，x,y代表原图的象素坐标，g[y][x]代表该点灰度。首先将灰度右移两位，变成64级，然后将x，y做模8运算，找到Bayer表中的对应点，两者做比较，根据上面给出的判据做处理。模8运算使得原图分成了一个个8×8的小块，每个小块和8×8的Bayer表相对应。&#xA;4.2 抖动法&#xA;1. 规则抖动：如上面提到Bayer表算法。优点是算法简单；缺点是图案化有时很明显，这是因为取模运算虽然引入了随机成分，但还是有规律的。&#xA;2. Floyd-Steinberg算法：&#xA;假设灰度级别的范围从b(black)到w(white)，中间值t为(b+w)/2，对应256级灰度，b=0,w=255,t=127.5。设原图中象素的灰度为g，误差值为e，则新图中对应象素的值用如下的方法得到：&#xA;if g &amp;gt; t then&#xA;打白点&#xA;e=g-w&#xA;else 打黑点&#xA;e=g-b&#xA;3/8 × e 加到右边的象素&#xA;3/8 × e 加到下边的象素&#xA;1/4 × e 加到右下方的象素&#xA;但在这个算法中，因为e有可能是负数，为了防止得到的值超出char能表示的范围，我们使用了一个int类型的缓冲区存储新值。&#xA;要注意的是，误差传播有时会引起流水效应，即误差不断向下，向右累加传播。解决的办法是：奇数行从左到右传播，偶数行从右到左传播。&#xA;4.3 将bmp文件转换为txt文件</description>
    </item>
  </channel>
</rss>
