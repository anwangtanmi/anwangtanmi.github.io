<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>统计搜索 on 暗网探秘</title>
    <link>https://anwangtanmi.github.io/categories/%E7%BB%9F%E8%AE%A1%E6%90%9C%E7%B4%A2/</link>
    <description>Recent content in 统计搜索 on 暗网探秘</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 16 Oct 2019 11:12:40 +0800</lastBuildDate>
    <atom:link href="https://anwangtanmi.github.io/categories/%E7%BB%9F%E8%AE%A1%E6%90%9C%E7%B4%A2/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Deferred Deep Linking in iOS</title>
      <link>https://anwangtanmi.github.io/posts/a239cde5df7a9ae1aa489cb8798e2454/</link>
      <pubDate>Wed, 16 Oct 2019 11:12:40 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/a239cde5df7a9ae1aa489cb8798e2454/</guid>
      <description>Deep Linking 其实 deep linking 并不是一个新名词，在 web 开发领域，区别于指向首页的链接（http://tech.glowing.com/），deep linking 是指向具体内容页的链接（http://tech.glowing.com/cn/advices-to-junior-developers/）。在移动开发领域，deep linking 则是指 mobile app 在 handle 特定 URI 的时候可以直接跳转到对应的内容页或触发特定逻辑，而不仅仅是启动 app。比如 dianping://shopinfo?id=1859284，如果你的手机上装了大众点评的话点击这个链接可以直接跳转到商铺页面。这样做的好处主要有：&#xA;在 web 和 app 的切换过程中保留上下文 App 间带上下文切换（用于实现 app 间参数的传递，如授权协议，分享 API 等） Web 页可以被搜索引擎索引，可以通过 SEO 增加访问量从而提高 app 下载量和开启率 目前处理 deep linking，主要有两种方式：&#xA;Custom URL Scheme 在 universal links 出现之前的很长一段时间里，iOS 上主要通过 custom URL scheme 来实现 deep linking，以及 app 间的通信。&#xA;在 info plist 里设置了自定义 URL 后，handle URL 的入口是 app delegate 方法 application:openURL:sourceApplication:annotation:（iOS 9 开始被 deprecate）或 application:openURL:options:（iOS 9 引入，但如果没有实现这个方法，在 iOS 9 上还是会向前兼容 call 老方法，所以一般还是实现老方法）。</description>
    </item>
    <item>
      <title>《Learning Deep Structured Semantic Models for Web Search using Clickthrough Data 》论文总结</title>
      <link>https://anwangtanmi.github.io/posts/019e8f7496190591ea3208fbc0562fbd/</link>
      <pubDate>Tue, 12 Mar 2019 22:14:10 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/019e8f7496190591ea3208fbc0562fbd/</guid>
      <description>1.背景 DSSM是Deep Structured Semantic Model的缩写，即我们通常说的基于深度网络的语义模型，其核心思想是将query和doc映射到到共同维度的语义空间中，通过最大化query和doc语义向量之间的余弦相似度，从而训练得到隐含语义模型，达到检索的目的。DSSM有很广泛的应用，比如：搜索引擎检索，广告相关性，问答系统，机器翻译等。&#xA;2. DSSM 2.1简介&#xA;DSSM [1]（Deep Structured Semantic Models）的原理很简单，通过搜索引擎里 Query 和 Title 的海量的点击曝光日志，用 DNN 把 Query 和 Title 表达为低纬语义向量，并通过 cosine 距离来计算两个语义向量的距离，最终训练出语义相似度模型。该模型既可以用来预测两个句子的语义相似度，又可以获得某句子的低纬语义向量表达。&#xA;DSSM 从下往上可以分为三层结构：输入层、表示层、匹配层&#xA;典型的DNN结构是将原始的文本特征映射为在语义空间上表示的特征。DNN在搜索引擎排序中主要是有下面2个作用：&#xA;将query中term的高维向量映射为低维语义向量 根据语义向量计算query与doc之间的相关性分数 通常， x用来表示输入的term向量， y表示输出向量， l_{i}，i=1,…,N-1 表示隐藏层， Wi表示第 i层的参数矩&#xA;阵， bi表示 第 i个偏置项。&#xA;我们使用 tanh作为输出层和隐藏层的激活函数，有下列公式。&#xA;在搜索排序中，我们使用 Q来表示一个query， D来表示一个doc，那么他们的相关性分数可以用下面的公式衡量：&#xA;其中， yQ与 yD是query与doc的语义向量。在搜索引擎中，给定一个query，会返回一些按照相关性分数排序的文档。&#xA;通常情况下，输入的term向量使用最原始的bag of words特征，通过one-hot进行编码。但是在实际场景中，词典的大小将会非常大，如果直接将该数据输入给DNN，神经网络是无法进行训练和预测的。因此，在DSSM中引入了word hashing的方法，并且作为DNN中的第一层。&#xA;2.2 word hashing&#xA;word hashing方法是用来减少输入向量的维度，该方法基于字母的 -gram。给定一个单词（good），我们首先增加词的开始和结束部分（#good#），然后将该词转换为字母 -gram的形式（假设为trigrams：#go，goo，ood，od#）。最后该词使用字母 -gram的向量来表示。&#xA;这种方法的问题在于有可能造成冲突，因为两个不同的词可能有相同的 -gram向量来表示。下图显示了word hashing在2个词典中的统计。与原始的ont-hot向量表示的词典大小相比，word hashing明显降低了向量表示的维度。&#xA;2.3 DSSM的学习&#xA;点击日志里通常包含了用户搜索的query和用户点击的doc，可以假定如果用户在当前query下对doc进行了点击，则该query与doc是相关的。通过该规则，可以通过点击日志构造训练集与测试集。&#xA;首先，通过softmax 函数可以把query 与样本 doc 的语义相似性转化为一个后验概率：</description>
    </item>
    <item>
      <title>leaflet地图概念框架图</title>
      <link>https://anwangtanmi.github.io/posts/7c52b2ceb3e7e2096bce55c9121171a4/</link>
      <pubDate>Tue, 26 Feb 2019 16:44:40 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/7c52b2ceb3e7e2096bce55c9121171a4/</guid>
      <description>很多计算机接触地图开发的时候觉得很苦恼各种概念，leaflet官网的关系图已经写得很清楚了&#xA;各人经过理解后再次精简，写一些通俗易懂的话以供初学者理解。</description>
    </item>
    <item>
      <title>面对大量的用户数据泄露事件，普通用户该如何保护个人的网络信息安全？</title>
      <link>https://anwangtanmi.github.io/posts/899d251d7aa06f127b482f29f0a30910/</link>
      <pubDate>Tue, 11 Sep 2018 21:49:52 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/899d251d7aa06f127b482f29f0a30910/</guid>
      <description>我们经常会在新闻里看到或听到关于用户数据泄露的事件，这些用户数据的泄露会对网站或服务的使用者产生非常严重的安全威胁。作为一个网络用户，您对用户数据泄露的严重程度和这些用户数据泄露事件背后的具体细节，又了解多少呢？&#xA;谈到数据泄露，就不得不介绍一下与之相关的几个常用的黑客术语。在与数据泄露事件相关的报道中，经常可以听到拖库，洗库和撞库这几个词。拖库指的是黑客入侵有价值的网站，把注册用户的资料数据库全部盗走的行为。洗库是指在取得大量的用户数据之后，黑客会通过一系列的技术手段和黑色产业链将有价值的用户数据变现。撞库是黑客通过收集互联网已泄露的用户和密码信息，生成对应的字典表，尝试批量登陆其他网站后，得到一系列可以登录的用户信息列表。由于很多用户习惯在不同网站使用相同的帐号密码，因此黑客可以通过获取用户在A网站的账户信息去尝试登录B网址，这就可以理解为撞库攻击。&#xA;黑客获取用户数据的手段（拖库/data breaches） 黑客获取用户数据的手段主要分为社工手段和技术手段。社工手段主要是利用人的心理学特点，通过欺骗或冒充等手段获取信息，比如利用邮件、钓鱼网站等手段获取用户信息。技术手段则是指利用系统本身的漏洞直接侵入目标系统获取用户信息。在实际攻击过程中，黑客往往会混合使用这两种方法。 为了说明拖库，洗库和撞库这三者之间的关系，以下选用了启明星辰安星web 安全运维团队在总结2011大规模数据泄露研究报告中的一张图。这张图非常清楚地说明了这三个环节之间的相互关系。&#xA;那么，到底目前网络用户信息泄露问题有多严重呢？&#xA;在国内，2016年以前有一个专门曝光用户数据泄露事件的网站叫乌云网。如果留意看新闻的人应该还记得，在2016年之前经常有关于在乌云网上报出的用户数据泄露事件。乌云网曾经曝光的携程支付漏洞和12306网站用户数据泄露事件，目前在百度百科上还可以搜到。但这个由“白帽子们”发起的可以用来衡量网络安全程度的安全问题曝光网站，在2016年被强制关闭了。对于这一事件的评价有着非常极端的两面性，赞同关闭的人认为数据泄露事件曝光后，会有更多的黑客利用被曝光的漏洞进行攻击。反对的人则认为，没有这样的网站，服务提供商不会那么重视网络服务的安全，在提供更多服务的同时，会产生更多的系统漏洞，从而会给网络用户带来更多的危险。但不管怎样，乌云网被关闭的事件说明，黑客使用技术手段大量获取用户资料不是偶发事件，而几乎是网络安全的常态。&#xA;当失去乌云网后，网络用户是否真的无法知道当前的用户数据泄露问题有多严重了呢？&#xA;其实不然，在这方面比乌云网更出名的类似网站还有”Have I been Pwned?”（HIBP）。2013年底，网络安全专家Troy Hunt意识到当时的用户数据泄露已经达到了无法控制的地步，所以他决定与其让黑客独享这些数据，不如把所能获取到的数据制作成可以搜索的数据库，让普通用户也可以很容易地知道自己的资料是否已经泄露了。如果您还没有听说过这个网站，建议您可以去这个网站上检查一下自己账号的安全性。HIBP网站的网址是：https://haveibeenpwned.com。如下图HIBP网首页站所显示，到目前为止HIBP所记录的被泄露的用户数已高达50多亿。&#xA;除了可以自行去HIBP网站查找自己的用户名和密码是否被泄露以外，目前很多网络服务其实也在使用HIBP的数据来帮助用户提高账号的安全程度。比如，作者本人就曾在登陆GitHub时收到过下图所示的警告信息。&#xA;这个警告信息是说，您的账号目前已经可以在HIBP的数据库中找到了，建议更改和使用更高强度的密码。 当您去HIBP中查找后，若发现资料已被泄露，HIBP还能很贴心地告诉您，您的资料是在哪次数据泄露事件中被搜集的，您的什么资料可以在HIBP数据库中找到，如下图所示。&#xA;用户数据的利用（洗库） 前面我们谈到的是用户数据是如何被泄露的，以及目前用户数据的泄露问题有多严重。那么，当黑客获取到某个网站的用户数据后，这些数据是如何被利用的呢？基本上，被盗取的数据分成两部分：第一部分是以明文形式存储的用户信息，比如，姓名、电话号码、邮件地址等，更严重的可能还包括身份证号码、信用卡、银行账号等敏感信息。黑客可以把这些信息打包出售给不同的非法使用者。第二部分就是加密过的用户密码。为了最大程度地保护用户信息安全，大多数网站一般都是采用加密方式来存储用户密码，而不是明文存储。前面提到的HIBP网站上已泄露的用户密码就是存储的密码Hash值而不是明文。如果您想了解更多关于Hash算法的介绍，可以参考另一篇文章网络信息安全领域中常见的几个概念。黑客需要破解经Hash算法加密后的密码才能使用这一部分数据。用于破解密码Hash值的主要方法是碰撞攻击（Collision attack），维基百科上对Collision attack有非常详细的介绍。当黑客利用Collision attack将破解了的用户密码和用户名配对制成一张表格后，黑客就可以利用这张表来进行第二轮攻击了。&#xA;用户数据的再次利用（撞库） 如果不考虑社工手段，黑客使用技术手段获取的用户数据，主要是利用系统漏洞攻击那些防护措施薄弱的网站所得到的。当黑客把用户数据整理成一张可以再次使用的表格时，非常多的网站都可能被攻陷了。这主要是由于用户往往会使用同样的用户名和密码来注册不同的网络服务，这样黑客就可以利用已知的用户信息来获取其他网站同一用户的资料。这也就是为什么很多的用户数据泄露是通过撞库攻击所得到的。&#xA;如何保护自己的网络信息安全 所谓道高一尺，魔高一丈。网络上的攻防战争是永远没有结束那一天的。信息安全是服务提供方和用户本身双方的责任。做为网络用户，我们应该怎么办？其实，有很多方法是可以提高网络信息安全水平的，但讲多了，大多数人无法做到。这里只提最重要的三点供参考： 1. 不要使用同一用户名和密码来注册所有的网络服务。这无疑是最不安全的做法； 2. 提高密码的复杂程度。建议使用8位以上，数字、字母和符号的组合密码； 3. 对于重要的账号开启多重验证方法，如密码加短信，密码加OTP验证等。&#xA;以上第一、第二点，相信大家已经听过无数遍了。如果做到这两点，就会极大程度地增加黑客的工作量。要知道，黑客的时间也是很宝贵的，当您的防范措施比其他人复杂得多时，黑客可能就会选择放弃，而去尝试下一条数据了。&#xA;对于第三点多重验证，这本来是用于对安全性要求很高的网络服务所提供的安全措施，但随着用户数据泄露问题越来越严重，多重验证也逐渐被主流的网络服务所采用了。&#xA;什么是多重验证？多重验证是指，当用户在使用网络服务时，需要通过两种以上的认证机制之后才可以使用网络服务。这里讲的认证机制是指相互独立的验证手段。比如，当用户输入了用户名和密码后，系统提示还需要输入短信验证码。通常，当用户在陌生或新设备上登陆账户时，系统就会要求两种以上的认证机制。多重验证能更有效地保护用户账号安全。&#xA;多重验证根据复杂程度可以分成很多种，比如安全性最高的基于不对称加密算法的U盾，被广泛应用在银行业中。在一般的多重验证手段中，更常用的是邮件、短信、密码器、软件密码器或基于常用设备的应用推送等。这些常用的验证手段多数是基于一次性密码（OTP）的验证方法。随着国内互联网行业的飞速发展，一些具有创新性的多重验证方法也逐渐在国内流行开来。比如基于常用设备的二维码识别，这本来是微信和支付宝率先使用的验证和支付手段，目前很多国内银行的网银登陆也开始支持二维码扫描登陆了。除了二维码外，比较特别的验证方法还有，微信支持声纹验证，支付宝和百度支持面部识别等。由于多重验证方法种类繁多，无法逐一介绍，下表例举了一些常用网络服务所支持的多重验证方法供参考。&#xA;随着多重验证的使用和用户账号管理的复杂程度越来越高，国内的领先互联网服务提供商开始使用一站式的安全应用来专门用作账户管理。其中具有代表性的有QQ安全中心、百度账号管家和网易账号管家等。这些应用通常要求用户将应用与常用设备绑定，然后通过绑定后的应用来管理用户的账户设置。这样的一站式应用可以提供更多元的账户管理功能，比如账户功能的开启和关闭，被盗账号的找回等等。 现在，您一定对互联网账户的安全有了进一步的了解。是否很想去HIBP网站上查一下自己的资料有没有被泄露？如果在HIBP的数据库里能查找到您的账号，以上提及的三点就是您必须要立即采取的防范措施，否则理论上说，所有人都可能通过HIBP找到您的用户名和密码，登录您的账号了。&#xA;PassXYZ是一款跨平台的密码管理软件，可以运行在安卓和苹果手机以及Windows 10上。 PassXYZ基于著名的开源软件KeePass开发，所以兼容KeePass数据格式。PassXYZ的核心代码可以在开源社区GitHub上获取。PassXYZ最大的特点是通过提供大量的个人信息记录模板来分享和传递良好的使用习惯。PassXYZ个人信息管理软件和PassXYZ公众号的目标是通过两者的结合来推动和提高公众的个人信息管理水平。&#xA;您可以通过苹果应用商店，微软应用商店，Google Play和华为应用商店搜索关键字PassXYZ来下载该应用。如果您想获得更多模板或对个人信息安全及管理有兴趣，可以搜索关键字PassXYZ关注公众号。您也可以通过微信号passxyz_kpclib来添加此公众号。PassXYZ公众号专注于个人信息安全及管理的相关知识。</description>
    </item>
    <item>
      <title>黑暗搜素引擎工具—shodan</title>
      <link>https://anwangtanmi.github.io/posts/83f1e9d235bb04b9661ca010ed6095e0/</link>
      <pubDate>Tue, 14 Aug 2018 18:29:52 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/83f1e9d235bb04b9661ca010ed6095e0/</guid>
      <description>简介 shodan是互联网上最强大的一个搜索引擎工具，该工具不是在网上搜索网址，而是直接搜索服务器，相当于一款“黑暗”谷歌，一直不停的在寻找着所有和互联网连接的服务器、摄像头、打印机、路由器等。 官网：https://www.shodan.io/ 如搜索思科路由器 在该界面可以单击任何IP地址，直接找到该设备。 可以使用过滤器通过缩小搜索范围快速的查询需要的东西。 过滤器命令 -city和country命令(缩小搜索的地理位置） 表示从美国进行搜索&#xA;country:US 从孟菲斯城市搜索&#xA;city:Memphis&#xA;结合使用&#xA;country:US city：Memphis&#xA;-hostname命令（通过指定主机名来扫描整个域名） 搜索google主机&#xA;hostname:google -net命令（扫描单个ip或一个网络范围） 扫描主机192.168.1.10&#xA;net：192.168.1.10 扫描192.168.1.0/24网络内所有主机&#xA;net：192.168.1.0/24 -title命令（搜索项目） 搜索服务器机房信息&#xA;title：&#34;Server Romm&#34; -关键字搜索（如果知道目标系统使用得服务器类型或嵌入式服务器名，来搜索一个web页面也比较容易 搜索所有apache服务器正在运行得2.2.8版本，且仅搜索打开的站点&#xA;apache/2.2.8 200 ok 跳过显示401的非法页或302删除页&#xA;apache/2.2.8 -401 -302 -组合搜索 搜索在波士顿所有正在运行IIS/7.0的Microsoft服务器&#xA;IIS/7.0 hostname:YourCompany.com city:Boston 在某台主机中标题为camera的信息&#xA;Title:camera hostname:YourComany.com 使用坐标轴（经度33.5，纬度36.3）的形式搜索Linux操作系统&#xA;geo:33.5.36.3 os:Linux -其他搜索术语 通过端口号搜索&#xA;Port 通过操作系统搜索&#xA;OS 使用时间搜索服务&#xA;After或Before -使用Metasploit实现Shodan搜索 (1)在shodanhq.com网站注册一个免费的账户 (2)登录，获取API key。 (3)启动MSF终端 (4)选择auxiliary/gather/shodan_search模块 ，查看该模块下可配置的选项参数&#xA;&amp;gt;use auxiliary/gather/shodan_search &amp;gt;show options (5)配置QUERY和SHODAN_APIKEY选项参数&#xA;&amp;gt;set SHODAN_APIKEY duV9vwgCmo0oDfWqfWafax8sj0ZUa5BU（你账户的APIkey） &amp;gt;set QUERY iomega (6)启动搜索引擎</description>
    </item>
    <item>
      <title>ArcGIS教程之DEM(高程)的应用（坡度坡向、提等高线）</title>
      <link>https://anwangtanmi.github.io/posts/6fd7fb1c321a43a3f4b114f6b212e3d2/</link>
      <pubDate>Fri, 03 Aug 2018 16:56:19 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/6fd7fb1c321a43a3f4b114f6b212e3d2/</guid>
      <description>ArcGIS教程之DEM(高程)的应用（坡度坡向、提等高线） 发布时间：2018-01-17 版权：&#xA;相关教程：&#xA;DEM水文分析（一）&#xA;Arcgis下DEM水文分析（二）&#xA;DEM的应用包括：坡度：Slope、坡向：Aspect、提取等高线、算地形表面的阴影图、可视性分析、地形剖面、水文分析等，其中涉及的知识点有：&#xA;a)掌握根据DEM 计算坡度、坡向的方法。&#xA;b)理解基于DEM数据进行水文分析的基本原理。&#xA;c)利用ArcGIS的提供的水文分析工具进行水文分析的基本方法和步骤。&#xA;第一步：需要的工具&#xA;1. BIGEMPA地图下载器（全能版已授权） 下载地址：http://download.bigemap.com/bmsetup.rar&#xA;2. Global Mapper 14. 下载地址：Global Mapper 14.1汉化版.rar&#xA;3. ARCGIS下载地址：http://www.bigemap.com/helps/doc2018011754.html&#xA;第二步骤：通过BIGEMAP下载高程数据&#xA;1. 启动BIGEMAP地图下载器软件，查看左上角是否显示【已授权：所有地图】，如果没有该显示，请联系我们的客服人员。如下图所示：&#xA;2. 选择左上角属性选项，选择【高程】，如下图：&#xA;3. 选在你要的区域，双击下载，如下图所示：&#xA;4. 选择下载的级别，建议尽量下载16级的，16级为最好级别。如果16级不能勾选，请选择下载小一点的范围，高程为矢量数据，超过20M大小，一般电脑都很难处理生成的等高线。下载之后的数据为tiff格式，实际为dem高程数据。&#xA;6. 启动安装好的Global Mapper软件，启动中文版在安装好的目录下有个chs或则chinese的启动图标，如下图所示：&#xA;7. 将下载好的高程数据（下载目录下的后缀为tiff格式）拖入到global mapper中，如下图所示：&#xA;修改下载的高程数据的投影为【UTM】&#xA;在Global mapper中选择：工具-&amp;gt;设置，弹出对话框，如下：&#xA;然后另存为【DEM】格式，如下图：&#xA;在弹出的对话框中选择【DEM】格式，如下图:&#xA;点击【确定】，保存。&#xA;DEM应用之坡度：Slope&#xA;打开ArcMap软件，选择添加按钮，将刚才保存的DEM文件打开，如下图：&#xA;在ArcMap中，需要打开【扩展模块】功能，如下图：&#xA;弹出的对话框中勾选所有选项，如下图：&#xA;点击【关闭】。&#xA;2) 在【ArcToolbox】中，执行命令[3D Analyst工具]——[栅格表面]——[坡度]， 如下图所示，指定各参数：&#xA;执行后，得到坡度栅格Slope_tingri1：坡度栅格中，栅格单元的值在[0 -82] 度间变化，如下图：&#xA;右键点击图层[Slope_TinGrid]，执行[属性命令]，设置图层[符号系统]，重新调整坡度分级。将类别调整为5，点[分类]按钮，用手动分级法，将中断值调整为：8，15，25，35，90。&#xA;确定后，如下：&#xA;【下面计算剖面曲率】&#xA;在【ArcToolbox】中，执行命令[3D Analyst工具]——[栅格表面]————[坡度]。按如下所示，指定各参数。得到剖面曲率栅格：[Slope _Slope]，如下图：&#xA;DEM应用之坡向：Aspect&#xA;打开【ArcToolbox】，执行命令[3D Analyst工具]——[栅格表面]——[坡向]，按下图所示，指定各参数：&#xA;执行结果为（得到坡向栅格：[Aspect_tgrid]）：&#xA;【以下计算平面曲率】：&#xA;在【ArcToolbox】中，执行命令[3D Analyst工具]——&amp;gt;[栅格表面]——&amp;gt;[坡度]，按下图所示，指定各参数，按下图所示指定各参数：</description>
    </item>
    <item>
      <title>Multi-Segment应用——VTEP位于TOR交换机上</title>
      <link>https://anwangtanmi.github.io/posts/8e7b16873b3c6c1e86fa68d9c0d078de/</link>
      <pubDate>Wed, 30 May 2018 19:55:56 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/8e7b16873b3c6c1e86fa68d9c0d078de/</guid>
      <description> VXLAN的实现模型如下图： 在这个实现模型中，VTEP（VXLAN Tunnel End Point）是位于计算节点的br-tun上，但是在实际应用中，VTEP也有位于TOR交换机的情形。 VTEP位于TOR上，而不是Host内的br-tun。我们把这一段组网抽象成下图： 从用户视角，这是一个VXLAN网络，所以Neutron对外暴露的接口（模型）仍然是Network。但是在具体实现时，VTEP位于TOR上，而且，TOR还需要做VNI（VXLAN ID）到VLAN ID的映射（VLAN1、VLAN2、VLAN3、VLAN4）。这个映射并不能随意映射，因为TOR交换机上的VLAN ID，也不能任意取值，需要经过规划。所以Neutron就有了如下模型： segment实际上是一个列表，这个列表的元素是[provider:physical_network,provider:network_type,provider:segmentation_id],Neutron正是通过这三个字段描述了需要描述的信息（比如VLAN ID，即provider:segmentation_id）。 说到这里，你可能会问，那个VXLAN网络的VNI，在哪里输入？这个VNI的赋值，由Neutron内部自动生成，而它生成的方法是根据配置文件的规则。 通过上述的这个场景（VTEP位于TOR上），我们可以总结出Network模型中的segments字段的用途： 1 使用场景：主要是VTEP位于TOR上。 2 用户体验：用户感觉到的只是一个普通租户，感觉不到实现细节。 3 字段用途：由于VTEP位于TOR上，Neutron内部还需要做一个网络ID的二次转换。TOR的VLAN ID是一个提前规划好的值，不能任意取值。此时，segments字段就承担这个作用，它的取值表达的就是这些提前规划好的值。 在这里，Network模型本身的网络ID相对于外部网络ID，segment字段里的网络ID相当于内部网络ID。Network本身的网络类型是VXLAN，segments字段里的网络类型是VLAN。 </description>
    </item>
    <item>
      <title>VTk显示样式设置</title>
      <link>https://anwangtanmi.github.io/posts/449fe2dc7f5216786aea14ca514e603e/</link>
      <pubDate>Tue, 04 Apr 2017 11:15:16 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/449fe2dc7f5216786aea14ca514e603e/</guid>
      <description>显示样式 在vtk中，显示样式是通过vtkProperty来控制的。这里介绍三种基本的属性设置方式：点方式，网格方式和面方式。其设置方法为&#xA;actor-&amp;gt;GetProperty()-&amp;gt;SetRepresentationToPoints() actor-&amp;gt;GetProperty()-&amp;gt;SetRepresentationToWireframe() actor-&amp;gt;GetProperty()-&amp;gt;SetRepresentationToSurface() 示例说明 CMakeLists.txt文件代码如下： CMAKE_MINIMUM_REQUIRED(VERSION 2.6) PROJECT( Representation ) FIND_PACKAGE(VTK REQUIRED) INCLUDE(${VTK_USE_FILE}) ADD_EXECUTABLE(Representation Representation.cpp) TARGET_LINK_LIBRARIES(Representation ${VTK_LIBRARIES}) Representation.cpp文件代码如下： #include #include #include #include #include #include #include #include #include #include int main(int argc, char *argv[]) { vtkSmartPointer coneSource = vtkSmartPointer::New(); coneSource-&amp;gt;Update(); vtkSmartPointer cone = coneSource-&amp;gt;GetOutput(); int nPoints = cone-&amp;gt;GetNumberOfPoints(); int nCells = cone-&amp;gt;GetNumberOfCells(); std::cout&amp;lt;&amp;lt;&#34;Points number:&#34;&amp;lt;std::endl; std::cout&amp;lt;&amp;lt;&#34;Cells number:&#34;&amp;lt;std::endl; vtkSmartPointer mapper = vtkSmartPointer::New(); mapper-&amp;gt;SetInputData(cone); vtkSmartPointer actor = vtkSmartPointer::New(); actor-&amp;gt;SetMapper(mapper); actor-&amp;gt;GetProperty()-&amp;gt;SetColor(1.0, 0, 0); //设置颜色属性 actor-&amp;gt;GetProperty()-&amp;gt;SetRepresentationToPoints(); //点方式 //actor-&amp;gt;GetProperty()-&amp;gt;SetRepresentationToWireframe(); //网格方式 //actor-&amp;gt;GetProperty()-&amp;gt;SetRepresentationToSurface(); //默认设置，面方式 vtkSmartPointer renderer = vtkSmartPointer::New(); renderer-&amp;gt;AddActor(actor); renderer-&amp;gt;SetBackground(0.</description>
    </item>
  </channel>
</rss>
