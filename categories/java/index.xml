<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on 暗网探秘</title>
    <link>https://anwangtanmi.github.io/categories/java/</link>
    <description>Recent content in java on 暗网探秘</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 27 May 2019 22:20:31 +0800</lastBuildDate>
    <atom:link href="https://anwangtanmi.github.io/categories/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>解决maven库里有jar包但是pom文件里依赖报错的问题</title>
      <link>https://anwangtanmi.github.io/posts/28707b8785196de95724ba26d74a46f3/</link>
      <pubDate>Mon, 27 May 2019 22:20:31 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/28707b8785196de95724ba26d74a46f3/</guid>
      <description>pom文件报错如下：&#xA;但是maven库里有这个包：&#xA;解决办法如下：&#xA;1、打开setting文件，检查mirror的id：&#xA;2、打开maven库中刚才的文件夹，找到_maven.repositories文件：&#xA;3、把nexus=改成跟上面setting文件里的mirror的id值nexus-aliyun：&#xA;最后记得maven—update一下，于是就不报错了。</description>
    </item>
    <item>
      <title>使用 IntelliJ IDEA 运行及调试 Java程序</title>
      <link>https://anwangtanmi.github.io/posts/d30cabf41934dd9b2e4558cb7726b48d/</link>
      <pubDate>Wed, 17 Apr 2019 15:22:39 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/d30cabf41934dd9b2e4558cb7726b48d/</guid>
      <description>1、运行：选择菜单栏上面的Run按钮下的Run，或是快捷键Shift+Alt+F10，然后选择类名cal 2、调试：选择菜单栏上面的Run按钮下的Run，或是快捷键Shift+Alt+F10，然后选择类名cal a、设置断点：选定要设置断点的行，在行号的区域后面单击鼠标左键（如行号5的后面那个大红点点）&#xA;b、开始调试&#xA;c、调试说明&#xA;来自博客：https://www.cnblogs.com/chiangchou/p/idea-debug.html ，写的很详细&#xA;Step Over (F8)：步过，一行一行地往下走，如果这一行上有方法不会进入方法。 Step Into (F7)：步入，如果当前行有方法，可以进入方法内部，一般用于进入自定义方法内，不会进入官方类库的方法，如第25行的put方法。 Force Step Into (Alt + Shift + F7)：强制步入，能进入任何方法，查看底层源码的时候可以用这个进入官方类库的方法。 Step Out (Shift + F8)：步出，从步入的方法内退出到方法调用处，此时方法已执行完毕，只是还没有完成赋值。 Drop Frame (默认无)：回退断点，后面章节详细说明。 IntelliJ IDEA的使用教程 及 可下载的电子文档 http://www.runoob.com/w3cnote/intellij-idea-usage.html</description>
    </item>
    <item>
      <title>网不好的时候尽量不要写maven工程了！！！</title>
      <link>https://anwangtanmi.github.io/posts/3f4877d04d4ac0360d18ae0a429bc714/</link>
      <pubDate>Thu, 04 Apr 2019 17:13:28 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/3f4877d04d4ac0360d18ae0a429bc714/</guid>
      <description> 今天上午写一个springmvc的maven工程 但是我不知道网不好 一直不能进行自动的进行对JavaBean的自动json化&#xA;调了好长时间 jackson的依赖也导入了 但是就是转化不了 真是焦头烂额&#xA;最后我无意间点开了maven的依赖 表面上一面平静&#xA;实则暗藏杀机&#xA;这就是我们在导入maven依赖的时候失败了 这样的情况 建议直接新复制一份工程吧 好气哦 竟然是jar包的问题 而且表面看不出来 错误 </description>
    </item>
    <item>
      <title>git错误: failed to push some refs to ‘xxx’</title>
      <link>https://anwangtanmi.github.io/posts/1ed0bb94527c7bcd68a8fc1e41f22be6/</link>
      <pubDate>Thu, 13 Dec 2018 22:25:16 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/1ed0bb94527c7bcd68a8fc1e41f22be6/</guid>
      <description>error: failed to push some refs to ‘[email protected]:zhengjinjun/payou.git’&#xA;hint: Updates were rejected because the remote contains work that you do&#xA;hint: not have locally. This is usually caused by another repository pushing&#xA;hint: to the same ref. You may want to first integrate the remote changes&#xA;hint: (e.g., ‘git pull …’) before pushing again.&#xA;hint: See the ‘Note about fast-forwards’ in ‘git push –help’ for details.&#xA;出现问题及解决办法:&#xA;原因: github中的README.</description>
    </item>
    <item>
      <title>java集合容器至 Comparable/tor 的笔记</title>
      <link>https://anwangtanmi.github.io/posts/cb96a958ec13bb1bec58fcfde33b96b3/</link>
      <pubDate>Tue, 11 Dec 2018 14:52:34 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/cb96a958ec13bb1bec58fcfde33b96b3/</guid>
      <description>================ ArrayList 查的快========================&#xA;主要的索引的方法： index对应元素的&#xA;1： 存取的是一致：&#xA;2： 有索引&#xA;3： 可存取重复&#xA;注意：就是 关于 索引的 越界的异常&#xA;———-。主要的方法&#xA;add（加一个） addAll（全加）&#xA;remove 删除指定一个的 removeAll（删除指定全部的）&#xA;get（获取 ） set（替换） 返回的是以替换的 位置&#xA;ArrayList 的底层 是 数组扩容的&#xA;######list集合的几个遍历的方法&#xA;1：普通for、 2：增强 for 3：迭代器Iteration&#xA;====linkdeList 增删改的快&#xA;lastAdd（）lastAddAll（）&#xA;endAdd（）endAddAll（）&#xA;linkdeList：底层是 双循环 链表结构&#xA;节点的原因：看源码—– 数组转 链表&#xA;add linkedlast类里的 函数&#xA;—遍历慢— 每次 都是&#xA;加速的功能 的 —》在里面找get方法 里nodenode方法 里&#xA;在 长度大于二分之一的就 会 从头往后找 往 小于 ， 就从后往头找&#xA;现在问的都是 1.7 的 hashMap 1.8 的就会很少的</description>
    </item>
    <item>
      <title>SpringBoot使用WebSocket实现服务端推送—单机实现（1）</title>
      <link>https://anwangtanmi.github.io/posts/baf7ba7ecefbafa69a26cd8f704fcb25/</link>
      <pubDate>Sun, 14 Oct 2018 15:07:47 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/baf7ba7ecefbafa69a26cd8f704fcb25/</guid>
      <description>[![star](https://gitee.com/xxssyyyyssxx/websocket-springboot-starter/badge/star.svg?theme=dark)](https://gitee.com/xxssyyyyssxx/websocket-springboot-starter/stargazers)&#xA;最近开发中需要实现服务端的推送，经过一段时间的资料查询最终锁定使用websocket来实现。JavaEE本身就支持WebSocket。我们只需要开发一个EndPoint来处理连接、消息等即可。但是WebSocket的session管理是开发中的重中之重和难点，因为你需要知道推送给谁，就需要保存代表其连接的Session。&#xA;1.首先设计管理WebSocket的session的接口WebSocketManager。&#xA;/** * 管理websocket的session,可以使用Map * @author xiongshiyan at 2018/10/10 , contact me with email [email protected] or phone 15208384257 */ public interface WebSocketManager { /** * 在容器中的名字 */ String WEBSOCKET_MANAGER_NAME = &#34;webSocketManager&#34;; /** * 根据标识获取websocket session * @param identifier 标识 * @return WebSocket */ WebSocket get(String identifier); /** * 放入一个 websocket session * @param identifier 标识 * @param webSocket websocket */ void put(String identifier , WebSocket webSocket); /** * 删除 * @param identifier 标识 */ void remove(String identifier); /** * 获取当前机器上的保存的WebSocket * @return WebSocket Map */ Map localWebSocketMap(); /** * 统计所有在线人数 * @return 所有在线人数 */ default int size(){ return localWebSocketMap().</description>
    </item>
    <item>
      <title>Android TCP真正有效的断链检测方法</title>
      <link>https://anwangtanmi.github.io/posts/2c64061f0928c1258f6d1b539727b4e5/</link>
      <pubDate>Thu, 30 Aug 2018 21:30:47 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/2c64061f0928c1258f6d1b539727b4e5/</guid>
      <description>1. 利用socket提供的isConnected()与isClosed()方法来判断。但这种方式只是本地判断，只是本地操作connect()或close()方法后保存的一个状态，对于远程服务器主动断开就没有用了。&#xA;2. 利用socket中的sendUrgentData()来判断。这种方法不管是客户端主动断开还是服务器主动断开，亦或者是异常断开都是有用的。但这种方法有一个明显的缺点，它得向服务器发送数据，相当于使用OutputStream,这就会影响正常通信的速度，并且会影响另一端的运行。&#xA;3. 利用BufferedReader中的readLine()来判断。当服务器主动断开时，readLine()方法会返回null。注意这种方式要求发送的信息中必须有换行符’\r\n’、’\r’或’\n’。如果服务器发送信息中不含换行符的话，那就唯有等到socket关闭时才有机会读到。&#xA;4. 利用InputStream.read()或BufferedReader.read()来判断。当服务器主动断开时，read()会返回-1&#xA;2018-08-30实际验证:在Socket.connect()成功后，设置全局变量bConnect=true；并另开一个线程：循环调用InputStream.read()直到返回-1或异常时设置全局变量bConnect=false；在网络发送的线程中判断全局变量bConnect==true再调用OutputStream.write()。</description>
    </item>
    <item>
      <title>算法刷题（18）_逆时针打印矩阵学习记录</title>
      <link>https://anwangtanmi.github.io/posts/8817c767310876b8497cb1edb036507e/</link>
      <pubDate>Sun, 29 Jul 2018 05:12:15 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/8817c767310876b8497cb1edb036507e/</guid>
      <description>算法刷题（18）_逆时针打印矩阵学习记录&#xA;【说明】&#xA;题目：输入一个矩阵，按照从外向里以顺时针顺序依次打印出每一个数字，例如：如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1, 5，9，13，14，15，16，12，8，4，3，2，6，10，11，7.&#xA;【算法实现】&#xA;package p4; /** * 逆时针打印矩阵 * @author Guozhu Zhu * @date 2018/7/29 * @version 1.0 * */ public class Test02 { public static void main(String[] args) { int[][] arr = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}, {10, 11, 12}}; int[] res = Solution01(arr, 4, 3); for (int i : res) { System.</description>
    </item>
    <item>
      <title>jenkins安装及启动</title>
      <link>https://anwangtanmi.github.io/posts/85601540c2343d1d0f93e936e9cefa30/</link>
      <pubDate>Wed, 04 Jul 2018 17:29:21 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/85601540c2343d1d0f93e936e9cefa30/</guid>
      <description>Jenkins是一个功能强大的应用程序，允许持续集成和持续交付项目，无论用的是什么平台。这是一个免费的源代码，可以处理任何类型的构建或持续集成。集成Jenkins可以用于一些测试和部署技术。Jenkins是一种软件允许持续集成。&#xA;官网：https://jenkins.io/&#xA;一、前期准备&#xA;1、需要开放8080端口，jenkins默认监听8080端口&#xA;2、需要安装java8，jenkins是java开发，需用java运行&#xA;二、下载，以下载war包运行为例，前提&#xA;wget -P /home/jenkins http://mirrors.jenkins.io/war-stable/latest/jenkins.war&#xA;三、启动&#xA;cd /home/jenkins/&#xA;nohup java -jar /home/jenkins/jenkins.war &amp;amp;&#xA;相关启动错误信息可通过vim /home/jenkins/nohup.out查看&#xA;1、出现错误&#xA;Jenkins requires Java 8, but you are running 1.7.0_181-mockbuild_2018_05_22_02_25-b00 from /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.181.x86_64/jre&#xA;解决：&#xA;升级java版本，安装至java8&#xA;2、出现错误：&#xA;警告: Could not intialize the host network interface on nullbecause of an error: ecs-90d5: ecs-90d5: 未知的名称或服务&#xA;java.net.UnknownHostException: ecs-90d5: ecs-90d5: 未知的名称或服务&#xA;解决：&#xA;vim /etc/hosts&#xA;添加一行映射即可&#xA;127.0.0.1 ecs-90d5&#xA;四、查看安装秘钥&#xA;1、vim /home/jenkins/nohup.out&#xA;2、查看字样&#xA;Jenkins initial setup is required.</description>
    </item>
    <item>
      <title>Ubuntu 16.04 手动安装 Oracle JDK</title>
      <link>https://anwangtanmi.github.io/posts/6d8d6d21e82670d9bc4668915d73c44a/</link>
      <pubDate>Mon, 04 Jun 2018 19:56:14 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/6d8d6d21e82670d9bc4668915d73c44a/</guid>
      <description> Ubuntu 16.04 手动安装 Oracle JDK的步骤：&#xA;去 Oracle 官网下载，链接点此 解压到当前目录下&#xA;tar -zxvf jdk-8u111-linux-x64.tar.gz 移动解压后的文件夹到自己想要放的位置&#xA;mkdir /usr/lib/jdk mv jdk1.8.0_111 /usr/lib/jdk/jdk1.8 设置环境变量&#xA;方案一： 修改全局配置文件，作用于所有用户： vim /etc/profile 将下面的代码放在文件的末尾： export JAVA_HOME=/usr/lib/jdk/jdk1.8 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=.:${JAVA_HOME}/bin:$PATH 方案二： 修改当前用户配置文件，只作用于当前用户： vim ~/.bashrc 将下面的代码放在文件的末尾： export JAVA_HOME=/usr/lib/jdk/jdk1.8 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=.:${JAVA_HOME}/bin:$PATH 使我们修改的配置立刻生效&#xA;source /etc/profile 或者 source ~/.bashrc 检查是否安装成功&#xA;java -version </description>
    </item>
    <item>
      <title>eclipse主题颜色的下载与设置</title>
      <link>https://anwangtanmi.github.io/posts/a5247504feb818af94497fe722f7e892/</link>
      <pubDate>Fri, 01 Jun 2018 20:29:20 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/a5247504feb818af94497fe722f7e892/</guid>
      <description>在网找了一下，发现相关的内容不多，所以自己在学会之后就分享一下。&#xA;首先到eclipse主题颜色官网当中去&#xA;网址为:http://www.eclipsecolorthemes.org/&#xA;可以看到在下面有许多不同种类的主题颜色，然后选择一个自己所喜欢的然后点击&#xA;比如这个主题是我所喜欢的一个，然后在右边download当中会有两种不同格式的下载方式一种是xml，另一种是EPF。xml形式没有试过，所以只说一下emf的。&#xA;点击对文件进行下载之后，然后找到指定的文件。&#xA;这些都是我下载的，&#xA;然后打开eclipse，点击import，类是与到入项目文件那样。&#xA;选中perferences&#xA;然后找到所下载的主题将之进行导入就行&#xA;最后附一张导入后的主题样式：</description>
    </item>
    <item>
      <title>webView中导入百度地图和设置样式</title>
      <link>https://anwangtanmi.github.io/posts/35d0ae49abd57cf5f72c1164eea6670c/</link>
      <pubDate>Sat, 28 Apr 2018 12:15:33 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/35d0ae49abd57cf5f72c1164eea6670c/</guid>
      <description>首先看效果图：&#xA;####怎样获取百度地图api&#xA;第一种方式：找到“百度地图api”&#xA;第二种方式：”百度地图生成器“&#xA;注意此方式生成的地图使用的是百度地图api1.1&#xA;####设置地图样式&#xA;博主使用的是用百度地图生成器生成的地图，可以先保存成html格式，查看地图是否需要改进&#xA;– 消除百度地图的logo 方法：使用Google浏览器打开刚刚保存的HTML，打开开发者模式（或者按F12）&#xA;添加样式消除logo&#xA;.BMap_cpyCtrl { display: none; } .anchorBL { display: none; } #####设置背景色&#xA;因为这个样式在百度地图api1.0中不起效，所以我把JavaScript换成了3.0&#xA;原js: 换成api3.0 #####设置地图的大小&#xA;这里设置充满屏幕，需要改动三个地方，是否还有其他方法不太清楚，但是博主是这样做的（可能我太菜了）&#xA;暂时博主就只设置这几个样式，最终效果图如下：&#xA;####使用webView加载百度地图&#xA;这里我使用Javafx中的webView组件，详情可见：WebView组件概览&#xA;目录结构：&#xA;package work.javaee.maptest; import javafx.application.Application; import javafx.scene.Scene; import javafx.scene.layout.BorderPane; import javafx.scene.web.WebEngine; import javafx.scene.web.WebView; import javafx.stage.Stage; public class Main extends Application{ @Override public void start(Stage primaryStage) throws Exception { //设置窗体布局 BorderPane borderPane = new BorderPane(); //创建scene Scene scene = new Scene(borderPane); //创建WebView和WebEngine对象 WebView webView = new WebView(); WebEngine webEngine = webView.</description>
    </item>
    <item>
      <title>Eclipse 暗黑主题风格</title>
      <link>https://anwangtanmi.github.io/posts/695fd3d11e17c4b83a2bd31f6352a2ef/</link>
      <pubDate>Mon, 16 Apr 2018 14:47:31 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/695fd3d11e17c4b83a2bd31f6352a2ef/</guid>
      <description>Eclipse市场下载、拖动到Eclipse下载插件处安装&#xA;http://marketplace.eclipse.org/marketplace-client-intro?mpc_install=3274405&#xA;版本1.8 Eclipse JDK打包&#xA;链接：https://pan.baidu.com/s/1eNYSU7_FSo-Hyyd6fEc4Fg 密码：qwm4</description>
    </item>
    <item>
      <title>eclipse在主题商城下载安装黑色主题</title>
      <link>https://anwangtanmi.github.io/posts/c5274d4e72f67fe1027b6c2ee01e85e9/</link>
      <pubDate>Wed, 11 Apr 2018 20:20:41 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/c5274d4e72f67fe1027b6c2ee01e85e9/</guid>
      <description>Eclipse配置黑色主题方法：&#xA;1、 借用国外一个Elipse主题网站分享的主题配置文件来配置一个黑色的主题.&#xA;主题网址&#xA;2、 在这个网站下载自己喜欢的主题,单击主题进入下载页面,建议大家选择EPF格式的进行下载.&#xA;3、 下载好之后打开Eclipse,单击File菜单下的Import选项&#xA;4、 在弹出的窗口中,点击General下面的Preferences选项,然后点击Next&#xA;5、 单击Browse选择你下载的EPF配置文件,然后点击Finish&#xA;6、 这个时候如果你如果之前选择的是Eclipse默认的主题的话,那么只有代码区变成了黑色,那么你就需要再单击windos下的Preferences选项,然后再打开General下面的Appearance,在Theme选择那个Dark主题,然后点确定就可以了.&#xA;#我的个人博客主页，欢迎访问&#xA;#我的CSDN主页，欢迎访问&#xA;#我的简书主页，欢迎访问&#xA;#我的GitHub主页，欢迎访问</description>
    </item>
    <item>
      <title>spring batch demo[极简版]</title>
      <link>https://anwangtanmi.github.io/posts/b7f822db4bcedc47b06b8b63ac4fb32c/</link>
      <pubDate>Wed, 07 Mar 2018 16:39:37 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/b7f822db4bcedc47b06b8b63ac4fb32c/</guid>
      <description>1. maven&#xA;org.springframework.batch spring-batch-core 3.0.8.RELEASE org.springframework.batch spring-batch-infrastructure 3.0.8.RELEASE 2. BatchTest类&#xA;public class BatchTest { @Test public void test() throws Exception { ResourcelessTransactionManager transactionManager = new ResourcelessTransactionManager(); MapJobRepositoryFactoryBean jobRepositoryFactoryBean = new MapJobRepositoryFactoryBean(); jobRepositoryFactoryBean.setTransactionManager(transactionManager); JobRepository jobRepository = jobRepositoryFactoryBean.getObject(); SimpleJobLauncher jobLauncher = new SimpleJobLauncher(); jobLauncher.setJobRepository(jobRepository); SyncTaskExecutor taskExecutor = new SyncTaskExecutor(); jobLauncher.setTaskExecutor(taskExecutor); StepBuilderFactory stepBuilderFactory = new StepBuilderFactory(jobRepository,transactionManager); Step step = personStep(stepBuilderFactory,reader(&#34;person.csv&#34;) ,new PersonWriter(), new PersonItemProcessor()); JobBuilderFactory jobBuilderFactory = new JobBuilderFactory(jobRepository); Job job = jobBuilderFactory.</description>
    </item>
    <item>
      <title>Cannot complete the install because one or more required items could not be found解决办法</title>
      <link>https://anwangtanmi.github.io/posts/50fcd1ea3f8f61bb8f3b63b2762938e5/</link>
      <pubDate>Thu, 07 Dec 2017 10:15:08 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/50fcd1ea3f8f61bb8f3b63b2762938e5/</guid>
      <description>Eclipse安装springide，出现如下所示的错误：&#xA;Cannot complete the install because one or more required items could not be found. Software being installed: Spring IDE Security Extension (optional) 3.7.3.201602250914-RELEASE (org.springframework.ide.eclipse.security.feature.feature.group 3.7.3.201602250914-RELEASE) Missing requirement: Spring IDE Live Beans Graph 3.7.3.201602250914-RELEASE (org.springframework.ide.eclipse.beans.ui.livegraph 3.7.3.201602250914-RELEASE) requires &#39;bundle org.eclipse.zest.core [1.0.0,2.0.0)&#39; but it could not be found Cannot satisfy dependency: From: Spring IDE Core (required) 3.7.3.201602250914-RELEASE (org.springframework.ide.eclipse.feature.feature.group 3.7.3.201602250914-RELEASE) To: org.springframework.ide.eclipse.beans.ui.livegraph [3.7.3.201602250914-RELEASE] Cannot satisfy dependency: From: Spring IDE Security Extension (optional) 3.</description>
    </item>
    <item>
      <title>Android踩坑日记：点击变暗效果的ImageView实现原理</title>
      <link>https://anwangtanmi.github.io/posts/11632a52aec06530048dec9875ea2084/</link>
      <pubDate>Sat, 21 Oct 2017 10:00:57 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/11632a52aec06530048dec9875ea2084/</guid>
      <description>很多时候我们使用ImagView显示图片，无论是Gilde，Fresco等图片显示框架，比如设置中心更换头像，网格相册点击预览，选择等情况，会遇到点击变暗的交互需求。&#xA;源码分析 我们想的办法是自定义一个ImageView，当点击图片时，是不是有回调方法来同时改变图片的滤镜或者蒙版等。 特意去看了View.java的源码（ImageView继承View），想看看View被点击之后是是否有回调函数可用。 View的onTouchEvent()方法 case MotionEvent.ACTION_DOWN: mHasPerformedLongPress = false; if (performButtonActionOnTouchDown(event)) { break; } // Walk up the hierarchy to determine if we&#39;re inside a scrolling container. boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for // a short period in case this is a scroll. if (isInScrollingContainer) { mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) { mPendingCheckForTap = new CheckForTap(); } postDelayed(mPendingCheckForTap, ViewConfiguration.</description>
    </item>
    <item>
      <title>全新体验—Eclipse更换代码颜色与风格！</title>
      <link>https://anwangtanmi.github.io/posts/3e47259e6e3a7984e8c463fbba36ff91/</link>
      <pubDate>Wed, 20 Sep 2017 22:42:08 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/3e47259e6e3a7984e8c463fbba36ff91/</guid>
      <description>Eclipse Color Themes&#xA;一个eclipse插件，可以简单方便地实现eclipse下的代码配色。另外插件作者还专门为此插件做了一个eclipse配色网站，有很多开发者在此网站分享了自己的配色方案。当然，你也可以在网站配置自己想要的颜色和风格。 官网：http://eclipsecolorthemes.org/</description>
    </item>
    <item>
      <title>通过身份证号码查询个人身份信息</title>
      <link>https://anwangtanmi.github.io/posts/270068a1b828cc38a9be9ae3144def1a/</link>
      <pubDate>Thu, 17 Aug 2017 11:59:48 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/270068a1b828cc38a9be9ae3144def1a/</guid>
      <description>package com.qb.modules.interfaces.befloan.common.util; import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import java.util.HashMap; import java.util.Map; import java.util.Set; public class IdcardInfoExtractor { // 省份 private String province; // 城市 private String city; // 区县 private String region; // 年份 private int year; // 月份 private int month; // 日期 private int day; // 性别 private String gender; // 出生日期 private Date birthday; //年龄 private int age; private Map cityCodeMap = new HashMap() { { this.</description>
    </item>
    <item>
      <title>Socket TCP协议 实时通信的粘包处理 Java与C&#43;&#43;实现</title>
      <link>https://anwangtanmi.github.io/posts/ba2bd66cfe1bcd48bac243612f20c952/</link>
      <pubDate>Sat, 12 Aug 2017 09:46:45 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/ba2bd66cfe1bcd48bac243612f20c952/</guid>
      <description>原理： （经典）tcp粘包分析&#xA;场景： 此项目是处理实时监测数据，一旦tcp socket建立连接，会不间断实时发送数据，峰值输数据量在3M/秒，这样的数据量必然会造成数据粘包。&#xA;目的： TCP连接面向流，读取网络的一包数据不一定正好是协议里定义的完整的一包，有可能是多包，有可能是半包，也有可能是一包半，现在要将每次读取的数据进行分包，也就是粘包处理，提取出完整的一包数据供上层使用，上层需要将完整的一包数据里的数据根据协议定义的格式提取出来。&#xA;实现： 将收到的数据copy到缓存区，在缓存区里循环从起始位按照协议找出完整的一包数据提取出来。 关键点在于根据协议找出完整一包数据的长度。&#xA;从网络读取数据后拷贝到缓存区 判断：缓存区里数据占位，长度小于某个值n，return再次读取网络数据。这个值n长度的数据内要能解析出单个完整包的长度，以便后续处理 循环：如果缓存区长度大于解析出来的完整一包的长度 执行： 取出完整一包数据后，然后剔除这包，将缓存区剩余数据放置起始位 循环里再次判断： 长度小于某个值n，return再次读取网络数据。 这个值n长度的数据内要能解析出单个完整包的长度，以便后续处理 如果协议定义了帧头，可以在取包的长度之前校验帧头，确保数据正确。&#xA;这里说明定义缓冲区buffer的长度大小：必须要大于可能收到的最大数据包的长度加上read读取一次网络最大数据长度 原因是缓冲区里可能剩下不到一包数据，下一次读取网络数据后要将数据copy至缓冲区，如果超过缓冲区大小就无法进行处理。可在copy时加一层判断，如果超过缓存区，就直接返回，断开连接。代表这种数据包不能进行处理。如果缓存区设计合理，不会出现此种情况。read读取一次网络最大数据长度是在read到的buffer定义的长度。缓冲区的buffer不要设置过大，占用太多内存。 数据源说明：第一位固定#。第二位表示之后有几位代表了之后的数据的长度，比如第一条数据的第二位4，代表之后的四位3350是从0：开始共有3350个字节长度的数据。之后的数据跟业务相关。&#xA;主要代码： Java实现： 不可用于生产环境，理解思想后根据业务数据处理粘包&#xA;private static int MAXDATALEN = 500000; //处理数据缓冲池的长度 private static int RECEIVEDATALEN = 200000;//读取网络数据包最大长度 private int SiglePackageLen = 0;//提取出包的长度 private int SequenceLen = 0;//当前缓冲区内数据长度 private byte BuffSequencePackage[] = new byte[MAXDATALEN];//数据缓冲池 public void readData() { //读取网络数据长度 int RecvLen; //缓存区 byte ReceiveData[] = new byte[RECEIVEDATALEN]; try { while (AdapterManager.</description>
    </item>
    <item>
      <title>log日志记录</title>
      <link>https://anwangtanmi.github.io/posts/2cc325c2418cdf9403d57aca7099dfcd/</link>
      <pubDate>Mon, 05 Jun 2017 10:38:54 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/2cc325c2418cdf9403d57aca7099dfcd/</guid>
      <description>http://www.cnblogs.com/wangwanchao/p/5310096.html&#xA;在项目开发中，记录错误日志是一个很有必要功能。&#xA;一是方便调试&#xA;二是便于发现系统运行过程中的错误&#xA;三是存储业务数据，便于后期分析&#xA;日志的实现方式：&#xA;1、自己写类，将日志数据，以io操作方式，写数据到文本文件。或者是写到数据库中。&#xA;2、使用log4j。log4j，这也是此文要记录的。log4j，以前在用.Net做web form时，用log4net。平台通吃。而且，log4j可以将日志，输出到console窗口，输出到文本文件，输出到数据库&#xA;等，功能还是很强大的！&#xA;3、使用jdk自带的logging.jar中的方法。&#xA;4、使用slfj。slfj，是也是一个很强大的功能。slfj旨在一统天下，也就是slfj提供了logging.jar 和 log4j的接口，可以通过slfj来调用log4j，也可以调用jdk的logging。&#xA;Log4j三个主要的组件，它们分别是 Logger、Appender和Layout，&#xA;Log4j 允许开发人员定义多个Logger，每个Logger拥有自己的名字，Logger之间通过名字来表明隶属关系。有一个Logger&#xA;称为Root，它永远存在，且不能通过名字检索或引用，可以通过Logger.getRootLogger（）方法获得，其它Logger通过&#xA;Logger.getLogger（String name）方法。&#xA;Appender则是用来指明将所有的log信息存放到什么地方，Log4j中支持多种appender，如 console、files、GUI&#xA;components、NT Event Loggers等，一个Logger可以拥有多个Appender，也就是你既可以将Log信息输出到屏幕，同时&#xA;存储到一个文件中。&#xA;Layout的作用是控制Log信息的输出方式，也就是格式化输出的信息。&#xA;log日志级别&#xA;trace： 是追踪，就是程序推进以下，你就可以写个trace输出，所以trace应该会特别多，不过没关系，我们可以设置最低日志级别不让他输出。&#xA;debug： 调试么，我一般就只用这个作为最低级别，trace压根不用。是在没办法就用eclipse或者idea的debug功能就好了么。&#xA;info： 输出一下你感兴趣的或者重要的信息，这个用的最多了。&#xA;warn： 有些信息不是错误信息，但是也要给程序员的一些提示，类似于eclipse中代码的验证不是有error 和warn（不算错误但是也请注意，比如以下depressed的方法）。&#xA;error： 错误信息。用的也比较多。&#xA;fatal： 级别比较高了。重大错误，这种级别你可以直接停止程序了，是不应该出现的错误么！不用那么紧张，其实就是一个程度的问题。&#xA;log4j的配置文件&#xA;%p: 输出日志信息优先级，即DEBUG，INFO，WARN，ERROR，FATAL,&#xA;%d: 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921 %r: 输出自应用启动到输出该log信息耗费的毫秒数 %c: 输出日志信息所属的类目，通常就是所在类的全名 %t: 输出产生该日志事件的线程名 %l: 输出日志事件的发生位置，相当于%C.%M(%F:%L)的组合,包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10) %x: 输出和当前线程相关联的NDC(嵌套诊断环境),尤其用到像java servlets这样的多客户多线程的应用中。 %%: 输出一个”%”字符 %F: 输出日志消息产生时所在的文件名称 %L: 输出代码中的行号 %m: 输出代码中指定的消息,产生的日志具体信息 %n: 输出一个回车换行符，Windows平台为”\r\n”，Unix平台为”\n”输出日志信息换行 可以在%与模式字符之间加上修饰符来控制其最小宽度、最大宽度、和文本的对齐方式。如： 1)%20c：指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，默认的情况下右对齐。 2)%-20c:指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，”-”号指定左对齐。 3)%.</description>
    </item>
    <item>
      <title>eclipse中文字体小、主题背景以及中文乱码</title>
      <link>https://anwangtanmi.github.io/posts/174119fa038803bbf8121d1da22b44b2/</link>
      <pubDate>Wed, 05 Apr 2017 14:32:20 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/174119fa038803bbf8121d1da22b44b2/</guid>
      <description>一些eclipse的小功能，做个备忘 1、eclipse中文字体小 Window-preferences-general-apperance-colors and fonts-basic-text font-courier new 2、主题背景 eclipse 默认的背景全白，在晚上的时候刺眼，可改成dark主题：Window-preferences-general，右边有个theme，选择dark，visual studio既视感。eclipse 自带的主题推荐这个，网上有很多自制的，可以自己下载。 3、中文乱码 如果eclipse里所有工程里都有这种问题，那么设置整个工作空间：Window-preferences-workspace-text file encoding，默认是GBK，可以在other里选择自己想要的（中文支持比较好的就是GBK和UTF8这两种，UTF8是国际通用的中文编码标准，切换试试）； 如果只是个别项目出现乱码，只需要修改项目的编码即可：选中项目-右键-Properties（属性）-Resource（资源）-Other（其他），然后选择你想要的编码格式。 如果是单个文件出现乱码，跟上一个处理步骤相同。</description>
    </item>
    <item>
      <title>java中try 与catch的使用</title>
      <link>https://anwangtanmi.github.io/posts/21a1b5d557983f3868efcf6777699b1a/</link>
      <pubDate>Sun, 05 Mar 2017 16:21:10 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/21a1b5d557983f3868efcf6777699b1a/</guid>
      <description>try{&#xA;//代码区&#xA;}catch(Exception e){&#xA;//异常处理&#xA;}&#xA;代码区如果有错误，就会返回所写异常的处理。&#xA;首先要清楚，如果没有try的话，出现异常会导致程序崩溃。&#xA;而try则可以保证程序的正常运行下去，比如说：&#xA;try{&#xA;int i = 1/0;&#xA;}catch(Exception e){&#xA;……..&#xA;}&#xA;一个计算的话，如果除数为0，则会报错，如果没有try的话，程序直接崩溃。用try的话，则可以让程序运行下去，并且输出为什么出错！&#xA;try catch 是捕捉try部分的异常，当你没有try catch的时候，如果出现异常则程序报错，加上try catch，出现异常程序正常运行，只是把错误信息存储到Exception里，所以catch是用来提取异常信息的，你可以在Catch部分加上一句System.out.println(e.ToString());，如果出现异常可以把异常打印出来&#xA;Java的异常处理机制(try…catch…finally)&#xA;1 引子&#xA;try…catch…finally恐怕是大家再熟悉不过的语句了，而且感觉用起来也是很简单，逻辑上似乎也是很容易理解。不过，我亲自体验的“教训”告诉我，这个东西可不是想象中的那么简单、听话。不信？那你看看下面的代码，“猜猜”它执行后的结果会是什么？不要往后看答案、也不许执行代码看真正答案哦。如果你的答案是正确，那么这篇文章你就不用浪费时间看啦。&#xA;public class TestException { public TestException() { } boolean testEx() throws Exception { boolean ret = true; try { ret = testEx1(); } catch (Exception e) { System.out.println(&#34;testEx, catch exception&#34;); ret = false; throw e; } finally { System.out.println(&#34;testEx, finally; return value=&#34;</description>
    </item>
    <item>
      <title>Ubuntu16.04 LTS的Java环境配置总结</title>
      <link>https://anwangtanmi.github.io/posts/ac8221d09bcf430ef161f5b14ea37080/</link>
      <pubDate>Thu, 23 Feb 2017 17:57:14 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/ac8221d09bcf430ef161f5b14ea37080/</guid>
      <description>* Linux* 这几天刚刚折腾linux(刚刚正式接触使用的linux小白)，而我安装好系统后的第一件事就是配置Java环境。此篇文章用于记录安装过程以作为备忘，如有疑问或者错误欢迎指正，一起交流，共同成长。 步骤&#xA;1.官网下载jdk http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 本人的版本是：jdk-8u121-linux-x64.tar.gz 2.安装jdk 解压缩包 .tar.gz命令：dpkg zxvf 包名 绝对路径(不指定路径则默认为当前目录)&#xA;(比较详细，我是小白…..捂脸.jpg)当然，首先要做的是通过命令行进入该包所在目录或者通过绝对路径进行解压也行。我是在包所在目录解压： 相关命令行&#xA;dpkg zxvf jdk-8u121-linux-x64.tar.gz 得到下面的文件jdk1.8.0_121 将此文件用命令行移动到指定文件夹 我的是/usr/lib/Java ，Java文件夹需要自己建立&#xA;sudo mv jdk1.8.0_121 /usr/lib/Java 3.用/etc/profile文件配置环境变量及修改系统默认Java以解决配置好环境变量后仍显示未设置Java环境问题&#xA;命令行打开gedit编辑/etc/profile 注：去掉sudo，则为只读模式&#xA;sudo gedit /etc/profile 添加以下代码到profile文件末尾&#xA;export JAVA_HOME=/usr/lib/Java/jdk1.8.0_121 export JRE_HOME=$JAVA_HOME/jre export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/lib export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin 命令行使得/etc/profile文件生效&#xA;source /etc/profile 问题来了： 到此步为止，当时我就立即测试命令java , javac 。然而，显示没有设置java环境！！！于是我网上搜资料，查明的原因是:Ubuntu下默认调用的是自带的java版本,因此需要修改默认版本设置。Ok，代码如下：&#xA;sudo update-alternatives --install /usr/bin/java java /usr/lib/Java/jdk1.8.0_121/bin/java 300 sudo update-alternatives --install /usr/bin/javac javac /usr/lib/Java/jdk1.8.0_121/bin/javac 300 sudo update-alternatives --install /usr/bin/jar jar /usr/lib/Java/jdk1.8.0_121/bin/jar 300 sudo update-alternatives --install /usr/bin/javah javah /usr/lib/Java/jdk1.</description>
    </item>
    <item>
      <title>eclipse-jee 如何修改黑色主题</title>
      <link>https://anwangtanmi.github.io/posts/a84f1acdd87ddaca5ff3720c7a6a9cea/</link>
      <pubDate>Thu, 19 Jan 2017 18:16:02 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/a84f1acdd87ddaca5ff3720c7a6a9cea/</guid>
      <description>我们用eclipse时，可以选择黑色主题，使软件整体变成暗色调，看起来比较舒服，有保护眼睛的作用&#xA;但是，当我们使用eclipse-jee时，就没有这么方便了，只能通过自己修改背景颜色，随便修改字体颜色，以便看起来比较舒服…&#xA;其实eclipse官网已经给我们提供多个主题选项，我们可以通过预览，下载自己所需的主题，然后导入自己的eclipse-jee&#xA;1、eclipse-color-theme 链接页面&#xA;http://marketplace.eclipse.org/content/eclipse-color-theme&#xA;根据自己的喜好下载相应主题epf文件&#xA;2、导入epf文件&#xA;3、OK啦&#xA;【然后根据自己的喜好稍微修改就行，美美哒 O(∩_∩)O】</description>
    </item>
    <item>
      <title>Java 和 HTTP 的那些事（一） 模拟 HTTP 请求</title>
      <link>https://anwangtanmi.github.io/posts/19778ae7d6de8652d14d99f83770e258/</link>
      <pubDate>Wed, 14 Sep 2016 13:36:54 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/19778ae7d6de8652d14d99f83770e258/</guid>
      <description>最新在学习使用 Java 来写网络爬虫，模拟浏览器发送 HTTP 请求，并抓取返回页面中的信息。由于对 Java 刚接触，以前用 .Net 写的一些网络请求相关的工具类都派不上用场，于是对如何使用 Java 模拟 HTTP 请求潜心研究了一番，在此写下这个《Java 和 HTTP 的那些事》系列的博客，并记录一些我中途遇到了明坑和暗坑，供后来人参考。此为第一篇。&#xA;一、使用 HttpURLConnection 发送 HTTP 请求 Java 自带的 java.net 这个包中包含了很多与网络请求相关的类，但是对于我们来说，最关心的应该是 HttpURLConnection 这个类了。&#xA;1.1 创建 HTTP 连接对象 要得到一个 HttpURLConnection HTTP 连接对象，首先需要一个 URL，代码如下：&#xA;1 2 URL obj =&#xA;new&#xA;URL(url); HttpURLConnection con = (HttpURLConnection) obj.openConnection(); 1.2 添加 HTTP 请求头 得到 HTTP 连接对象之后，我们就可以进行 HTTP 操作了，我们可以添加任意的 HTTP 请求头，然后执行我们需要的 GET 或者 POST 请求。我们像下面这样，添加两个 HTTP 头（User-Agent 和 Accept-Language）：&#xA;1 2 con.</description>
    </item>
    <item>
      <title>解决java 图片压缩图片图片变色问题</title>
      <link>https://anwangtanmi.github.io/posts/ca59d5f21772fea42bc3f2be549af991/</link>
      <pubDate>Tue, 26 Jul 2016 16:51:25 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/ca59d5f21772fea42bc3f2be549af991/</guid>
      <description>最近有人遇到在处理在用Java进行图片压缩的时候，压缩后图片的背景色发生了变色，如图所示：&#xA;压缩前：&#xA;压缩后：&#xA;经查阅相关资料后发现可以用阿里巴巴的SImpleImage可以解决这个问题。&#xA;主要依赖以下jar包：commons-io-2.4.jar、commons-lang.jar、commons-logging-1.1.1.jar、jai_codec-1.1.3.jar、jai_core-1.1.3.jar&#xA;SimpleImage github地址：https://github.com/alibaba/simpleimage&#xA;相关jar包下载：http://download.csdn.net/detail/asd1231510/8911263&#xA;测试代码：&#xA;import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import org.apache.commons.io.IOUtils; import com.alibaba.simpleimage.ImageRender; import com.alibaba.simpleimage.SimpleImageException; import com.alibaba.simpleimage.render.ReadRender; import com.alibaba.simpleimage.render.ScaleParameter; import com.alibaba.simpleimage.render.ScaleRender; import com.alibaba.simpleimage.render.WriteRender; public class Example { public static void main(String[] args) { File in = new File(&#34;E:/20111014111307895.jpg&#34;); //原图片 File out = new File(&#34;E:/testImage.jpg&#34;); //目的图片 ScaleParameter scaleParam = new ScaleParameter(400, 400); //将图像缩略到1024x1024以内，不足1024x1024则不做任何处理 FileInputStream inStream = null; FileOutputStream outStream = null; WriteRender wr = null; try { inStream = new FileInputStream(in); outStream = new FileOutputStream(out); ImageRender rr = new ReadRender(inStream); ImageRender sr = new ScaleRender(rr, scaleParam); wr = new WriteRender(sr, outStream); wr.</description>
    </item>
    <item>
      <title>java实现为图片添加水印</title>
      <link>https://anwangtanmi.github.io/posts/cadcf5b3bca1995f108bcf685d306ea3/</link>
      <pubDate>Thu, 25 Feb 2016 11:47:49 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/cadcf5b3bca1995f108bcf685d306ea3/</guid>
      <description>这个水印功能是看的慕课网的视频自己跟着学的，视频连接如下：http://www.imooc.com/learn/482&#xA;图片文件的上传界面、上传功能以及页面展示，这里就不再写了，可以去struts2环境下实现文件上传看，也可以去慕课网看视频。这里就记录下生成水印的代码。&#xA;先说说实现水印功能的思路：&#xA;1、创建图片缓存对象&#xA;2、创建绘图工具对象(有点类似于画布)&#xA;3、使用绘图工具对象将原图绘制到缓存图像对象中&#xA;4、使用绘图工具对象将水印（文字/图片）绘制到缓存图片对象中&#xA;5、创建图像编码工具类&#xA;6、使用图像编码工具类输出缓存图像到目标文件中&#xA;以下为水印功能的具体实现：&#xA;1、用来集中处理业务逻辑的Action（这里用的例子是一次性为多张图片添加水印）：&#xA;public class WaterMarkAction extends ActionSupport{ private File[] image; private String[] imageFileName; private String uploadPath; private List picInfo = new ArrayList(); public String waterMark() throws Exception{ String realUploadPath = ServletActionContext.getServletContext().getRealPath(uploadPath); if(image!=null &amp;amp;&amp;amp; image.length&amp;gt;0){ PicInfo pic=null; UploadService uploadService = new UploadService();//该service用来上传文件 //MarkService markService = new TextMarkService();//文字水印 //MarkService markService = new ImageMarkService();//图片水印 //MarkService markService = new MoreTextMarkService();//多文字水印 MarkService markService = new MoreImageMarkService();//多图片水印 for(int i=0;i 2、定义实现水印功能的接口：添加的水印包括四种情况：单一文字水印、单一图片水印、多文字水印、多图片水印。所以这里将实现水印的功能定义成了一个抽象类（除了有需要子类实现的方法外还有子类需要用到的公用方法），抽象类代码如下：</description>
    </item>
    <item>
      <title>有向图闭环检测值java代码实现</title>
      <link>https://anwangtanmi.github.io/posts/44c8bde8a6171bf68cf41674f85d4a2b/</link>
      <pubDate>Wed, 12 Aug 2015 21:53:54 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/44c8bde8a6171bf68cf41674f85d4a2b/</guid>
      <description>本文有向图闭环检测算法和实现由文章《如何检测节点网络中是否存在闭环之java实现》中的无向图闭环检测算法的基础上修改得到，其中修改点如下：&#xA;1.修改了数据结构，在原来无向图闭环检测算法的数据结构的基础上，增加了”isFrozen”和”isRoot”属性；其中”isFrozen”属性用于员无向图闭环检测算法中，在多父节点的场景下，由于相同的子节点要遍历两次而造成闭环检测判断的逻辑性错误，同时可以减少算法的开销，默认为false；”isRoot”属性用标识某一节点是否为根节点，默认为fasle。具体数据结构如下表：&#xA;属性名 值类型 nodeName String curRelIndex int beforeNode String relList List isFrozen boolean isRoot boolean 2.修改了获取算法起始点的方法，将在无向图闭环算法中随机获取起始点的方式修改为符合有向图的特点的方式—–如果节点集合中有给定根节点，即集合中某个节点的”isFrozen”属性值为true,则选择该属性为根节点，事先给定根节点的方式有助于减少算法开销；若无给定根节点，则算法默认给定一个根节点，该根节点的元素为该集合中的所有的节点，这种方式增加算法的开销&#xA;3.修改了进入闭环检测方法的条件—-将count &amp;gt; 1 改为 count &amp;gt;= 1 ，其实在无向图中 count &amp;gt;= 1 也无妨。&#xA;4.修改了获取从一个节点的关系列表中获取下一节点索引的方法。取消掉了对节点关系列表中与上一节点相同的节点的过滤。&#xA;5.修改了back()方法，在back()中增加了对”isFrozen”属性的修改，修改规则是，当一个节点后退时，将改节点的”isFrozen”属性修改为”true”。&#xA;6.对traverse()做了一些修改，对调用head()和back()方法的判断中增加了一个判断条件—即若当前节点的isFrozen属性值为true，则后退，不再前进；因为若”isFrozen”属性的值为true，则说明该节点的所有子节点都已经遍历完，而且没有出现闭环的情况，所以可以不用再遍历。&#xA;源码如下：&#xA;/** * * 功能：判断有向图中是否存在闭环 * 作者：EugeneJao * @param nodeCollections * @return * @throws Exception */ public boolean isContainLoopInDigraph(Map&amp;gt; nodeCollections) throws Exception{ //用map的hash码计算，速度更快 Map visitedList = new HashMap(); /** * 初始化&#34;起点 */ String startNode = getOriginInDigraph(nodeCollections); boolean containLoop = false ; /** * 初始化&#34;</description>
    </item>
    <item>
      <title>一道逻辑题 房间里有100盏电灯</title>
      <link>https://anwangtanmi.github.io/posts/1bfd5f913ec685481beeba343063fb1f/</link>
      <pubDate>Sun, 12 Apr 2015 16:41:51 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/1bfd5f913ec685481beeba343063fb1f/</guid>
      <description> 在&#xA;博客园看到的这个问题，也想做一下。题目是这样的 房间里有100盏电灯，编号为1，2，3……100，每盏灯上有一个按钮，初始时灯全都是关的。编好号的100位同学由房间外依次走进去，将自己编号的倍数的灯的按钮全部按一次，例如第一位同学把编号是1的倍数的灯的按钮按一下（此时100盏灯全亮），第二位同学把编号是2的倍数的灯的按钮按一下（此时只有50盏灯亮着，50盏被这个人按灭了）……第100位同学把编号是100的倍数的灯（即编号为100的灯）的按钮按一下，请问依次走完后，还有多少盏灯亮着？&#xA;最简单的做法就是模拟一下100个同学进入房间的情景，从1号同学开始每个人都去按一遍开关，最后看一下哪些灯亮着，这个方法最简单也最容易想到，可是效率有点低。其实可以计算一下每个开关被按下的次数，因为刚开始的时候所有的灯泡都是关着的，所以如果某个灯泡的开关被按了奇数次，那么这个灯泡最终就是开着的，否则就是关着的。那怎么计算每个灯泡开关被按下的次数呢？因为每个同学都会按下自己编号倍数的开关，即如果灯泡编号是同学编号的倍数，他就会按下开关，也就是说如果同学编号是灯泡编号的约数，他就会按下开关（这不是废话么）。那么统计一下灯泡编号约数的个数就可以了，约数个数为计数的灯泡最后开着，约数个数为偶数的灯泡最后关着。下边是代码：&#xA;public class Lamp { public static void main(String[] args){ int result = 0; for(int i=1;i&amp;lt;=100;i++){ if(isOdd(getFactorNum(i))){ result += 1; } } System.out.println(result); } //求n约数的个数 public static int getFactorNum(int n){ int result = 0; for(int i=1;i&amp;lt;=n;i++){ if(n%i == 0){ result += 1; } } return result; } //判断n是否为奇数 public static boolean isOdd(int n){ return (n&amp;amp;1) == 1; } } ——————————–更新——————————&#xA;又想了一下还有更简单的算法，因为一个数的约数都成成对出现的，也就是说如果n存在一个约数p，那么一定有一个q与之相对应且满足n=pq，所以n约数的个数一定是偶数，但是有一种情况例外，那就是p=q，所以只有编号为完全平方数的灯泡亮着。按着这个方法计算就简单多了，直接return (int)Math.sqrt(100); </description>
    </item>
    <item>
      <title>web网页直接触发发邮件办法（Email）</title>
      <link>https://anwangtanmi.github.io/posts/e4ab4a1476c25e728c24452f99b7ce6f/</link>
      <pubDate>Wed, 10 Dec 2014 15:36:01 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/e4ab4a1476c25e728c24452f99b7ce6f/</guid>
      <description>关键字：web网页直接触发发邮件办法（Email） [email protected]</description>
    </item>
    <item>
      <title>JavaMail发送带多个附件的邮件，多个收件人，多个抄送人</title>
      <link>https://anwangtanmi.github.io/posts/f3e145f7070a0a69c86a330faf83db27/</link>
      <pubDate>Fri, 14 Mar 2014 23:00:36 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/f3e145f7070a0a69c86a330faf83db27/</guid>
      <description>/** * 方法描述：发送带附件的邮件 * * @throws UnsupportedEncodingException */ public static boolean sendEmailWithAttachment(Email email) throws UnsupportedEncodingException { Properties prop = new Properties(); prop.put(&#34;mail.smtp.host&#34;, mailServer); prop.put(&#34;mail.smtp.auth&#34;, &#34;true&#34;); Authenticator auth = new MailAuthenticator(); Session session = Session.getDefaultInstance(prop, auth); Message message = new MimeMessage(session); boolean flag = false; try { message.setSubject(email.getEmail_subject());// 设置邮件主题 message.setHeader(&#34;Header:&#34;, email.getEmail_header()); // 设置邮件标题 message.setSentDate(new Date()); // 设置发送时间 Address addressFrom = new InternetAddress(mailAddress, mailAccount); // 设置发信人地址 message.setFrom(addressFrom); BodyPart messageBodyPart = new MimeBodyPart(); messageBodyPart.</description>
    </item>
    <item>
      <title>多年前的一款页游《倾城》服务器源码分析</title>
      <link>https://anwangtanmi.github.io/posts/005a301a5634198cb61ba53797f607e6/</link>
      <pubDate>Thu, 19 Dec 2013 19:26:18 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/005a301a5634198cb61ba53797f607e6/</guid>
      <description>未完结版。业务逻辑代码 有点看不下去了，于是就放弃了。&#xA;1.网络层：&#xA;游戏代码中，网络服务器端 提供了两套实现，一套是SimpleNetServer，基于BIO（阻塞IO）的ServerSocket；另一套是NIONetServer，基于NIO（即非阻塞IO） selector模式的ServerSocketChannel。前者应该是用于开发期间的调试和测试；而后者用于实际生产环境。&#xA;比较两者关闭服务器的方式，前者是直接中断线程的，比较粗暴；后者是通过设置轮训字段字段（running）的状态来关闭的，更优雅、可靠。&#xA;其他细节，详见代码。&#xA;心跳消息：NIONetServer.run() -&amp;gt; NetConnection.update() NetConnection对client连接，以及收发消息的操作做了封装。并有两个子类继承之，其中SimpleConnection对应于SimpleNetServer，是BIO服务器端的网络连接对象；NIOConnection对应于NIONetServer，是NIO服务器端的网络连接对象。&#xA;消息解码器/编码器：&#xA;Request消息NIO处理流程：&#xA;2.数据层&#xA;游戏把数据持久层和数据缓存层 合并为同一层了。所以这里就并为一层来一起讲解。&#xA;如果非要分数据持久层和cache层，DataAccessor算是主要提供了cache的实现。持久层提供了2种实现：LocalFileAccessor是将用户数据存放在本地文件系统中，以文本文件的形式存在，详见localdata\*或data\*,貌似data目录下的更齐全。目前源码中用到的是localdata。DatabaseAccessor是将用户数据存放到数据库中，读了GameServer.init()中提供了mysql和mssql两种数据库可选，而配置文件config\server.cfg中配置的是mssql数据库的数据源信息，而且还提供了mssql的驱动包。&#xA;DatabaseAccessor中，写数据库是异步的：创建一个包含jdbc sql语句和参数的job，放入队列中等待运行。对于插入操作，是先插入name，然后获取数据库生成的id，赋值到内存中，然后创建一个update job放入异步队列中等待更新。&#xA;这一层的源代码没有太多可圈可点之处，问题却是比较多，比如sql语句硬编码到源代码中，jdbc代码充斥于各个角落，导致代码冗余且难以维护；数据持久层仅仅使用了单个队列、单个线程处理，在某些情况下风险很高，例如单个job处理时间过长导致后续job没有机会及时运行，尤其是当队列严重阻塞、断电或宕机时后果最为严重；不能充分利用多核cpu的资源。</description>
    </item>
    <item>
      <title>java 里面出现的 premGen space 的错误</title>
      <link>https://anwangtanmi.github.io/posts/25cb917d637dd97527ffe33cd0c9ac87/</link>
      <pubDate>Sat, 14 Dec 2013 13:36:20 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/25cb917d637dd97527ffe33cd0c9ac87/</guid>
      <description>http://www.cnblogs.com/xwdreamer/archive/2011/11/21/2296930.html&#xA;1.参考： http://blog.csdn.net/fox009/article/details/5633007&#xA;http://hi.baidu.com/like_dark/blog/item/19c1948b3292b0799f2fb468.html&#xA;http://anyeeye.iteye.com/blog/444624&#xA;Tomcat6性能调优 出现java.lang.OutOfMemoryError: PermGen space&#xA;http://www.mkyong.com/tomcat/tomcat-javalangoutofmemoryerror-permgen-space/&#xA;2.报错： Exception in thread &#34;DispatcherThread&#34; java.lang.OutOfMemoryError: PermGen space Exception in thread &#34;ContainerBackgroundProcessor[StandardEngine[Catalina]]&#34; java.lang.OutOfMemoryError: PermGen space Exception in thread &#34;State Saver&#34; java.lang.OutOfMemoryError: PermGen space Exception in thread &#34;AWT-Windows&#34; java.lang.OutOfMemoryError: OutOfMemoryError 3.原因： PermGen space的全称是Permanent Generation space,是指内存的永久保存区域,这块内存主要是被JVM存放Class和Meta信息的,Class在被Loader时就会被放到PermGen space中,它和存放类实例(Instance)的Heap区域不同,GC(Garbage Collection)不会在主程序运行期对PermGen space进行清理，所以如果你的应用中有很多CLASS的话,就很可能出现PermGen space错误,这种错误常见在web服务器对JSP进行pre compile的时候。如果你的WEB APP下都用了大量的第三方jar, 其大小超过了jvm默认的大小(4M)那么就会产生此错误信息了。&#xA;4.解决方法1： 手动设置MaxPermSize大小，如果是linux系统，修改TOMCAT_HOME/bin/catalina.sh，如果是windows系统，修改TOMCAT_HOME/bin/catalina.bat，&#xA;在“echo “Using CATALINA_BASE: $CATALINA_BASE””上面加入以下行：&#xA;JAVA_OPTS=”-server -XX:PermSize=64M -XX:MaxPermSize=128m&#xA;建议：将相同的第三方jar文件移置到tomcat/shared/lib目录下，这样可以达到减少jar 文档重复占用内存的目的。&#xA;5.解决方法2 修改eclipse.ini文件，修改如下：&#xA;-vmargs -Dosgi.requiredJavaVersion=1.5 -Xms128m -Xmx512m -XX:PermSize=64M -XX:MaxPermSize=128M 如果还报错，可以考虑如下修改</description>
    </item>
    <item>
      <title>PermGen space错误解决方法</title>
      <link>https://anwangtanmi.github.io/posts/5b4f76ed251614a7fb75bb84fb0cc5fa/</link>
      <pubDate>Mon, 21 Nov 2011 16:17:29 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/5b4f76ed251614a7fb75bb84fb0cc5fa/</guid>
      <description>1.参考： http://blog.csdn.net/fox009/article/details/5633007&#xA;http://hi.baidu.com/like_dark/blog/item/19c1948b3292b0799f2fb468.html&#xA;http://anyeeye.iteye.com/blog/444624&#xA;Tomcat6性能调优 出现java.lang.OutOfMemoryError: PermGen space&#xA;http://www.mkyong.com/tomcat/tomcat-javalangoutofmemoryerror-permgen-space/&#xA;2.报错： Exception in thread &#34;DispatcherThread&#34; java.lang.OutOfMemoryError: PermGen space Exception in thread &#34;ContainerBackgroundProcessor[StandardEngine[Catalina]]&#34; java.lang.OutOfMemoryError: PermGen space Exception in thread &#34;State Saver&#34; java.lang.OutOfMemoryError: PermGen space Exception in thread &#34;AWT-Windows&#34; java.lang.OutOfMemoryError: OutOfMemoryError 3.原因： PermGen space的全称是Permanent Generation space,是指内存的永久保存区域,&#xA;这块内存主要是被JVM存放Class和Meta信息的,Class在被Loader时就会被放到PermGen space中,&#xA;它和存放类实例(Instance)的Heap区域不同,GC(Garbage Collection)不会在主程序运行期对&#xA;PermGen space进行清理，所以如果你的应用中有很多CLASS的话,就很可能出现PermGen space错误,&#xA;这种错误常见在web服务器对JSP进行pre compile的时候。如果你的WEB APP下都用了大量的第三方jar, 其大小&#xA;超过了jvm默认的大小(4M)那么就会产生此错误信息了。&#xA;4.解决方法1： 手动设置MaxPermSize大小，如果是linux系统，修改TOMCAT_HOME/bin/catalina.sh，如果是windows系统，修改TOMCAT_HOME/bin/catalina.bat，&#xA;在“echo “Using CATALINA_BASE: $CATALINA_BASE””上面加入以下行：&#xA;JAVA_OPTS=”-server -XX:PermSize=64M -XX:MaxPermSize=128m&#xA;建议：将相同的第三方jar文件移置到tomcat/shared/lib目录下，这样可以达到减少jar 文档重复占用内存的目的。&#xA;5.解决方法2 修改eclipse.ini文件，修改如下：&#xA;-vmargs -Dosgi.</description>
    </item>
    <item>
      <title>jfreechart 自定义饼图颜色</title>
      <link>https://anwangtanmi.github.io/posts/f172878c23784ebef221cefdeb2242c4/</link>
      <pubDate>Thu, 09 Jun 2011 18:52:03 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/f172878c23784ebef221cefdeb2242c4/</guid>
      <description>关键代码：&#xA;private static class PieRenderer {&#xA;private static final Paint[] COLORS = { Color.RED, Color.YELLOW,&#xA;Color.GRAY, Color.MAGENTA, Color.ORANGE, Color.GREEN,&#xA;Color.DARK_GRAY, Color.CYAN, Color.PINK, Color.BLUE,&#xA;Color.LIGHT_GRAY };&#xA;public void setColor(PiePlot plot, CategoryDataset dataset) {&#xA;List keys = dataset.getRowKeys();&#xA;for (int i = 0; i &amp;lt; keys.size(); i++) {&#xA;plot.setSectionPaint(keys.get(i).toString(), COLORS[i&#xA;% COLORS.length]);&#xA;}&#xA;}&#xA;}&#xA;PieRenderer renderer = new PieRenderer();&#xA;renderer.setColor(localPiePlot, paramCategoryDataset);&#xA;参考网站[url]http://balajinatarajan.blogspot.com/2008/04/customizing-jfreechart-pie-chart.html[/url]&#xA;Introduction&#xA;Dynamic representation of data in picture format is inevitable in this programming era.</description>
    </item>
    <item>
      <title>网络爬虫当中暗网爬取初探</title>
      <link>https://anwangtanmi.github.io/posts/b6b8ee97b19d4cea827adcf05cdd81ee/</link>
      <pubDate>Wed, 02 Dec 2009 19:21:17 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/b6b8ee97b19d4cea827adcf05cdd81ee/</guid>
      <description>众所周知，网络爬虫的最基本原理就是模拟HTTP协议向指定网站发送请求，从而从服务器端返回的网页源代码中抽取具有实用价值的信息（也可能下一次任务队列的地址）。这中间涉及到很多算法，根据网站不同域名，网站网页更新速度，网站结构深度，设定爬虫不同的爬取策略。爬虫可以从一些简单的网站上直接获取网页源代码，从而对网页源代码进行分析。但是对于一些需要用户登录的网站，要抓取网站当中被保护的数据具有一定的困难。今天要说就是一个从需要登录的网站上获取收保护数据的方法。&#xA;按照现实生活中的方法，需要获取这些数据，我们首先需要登录这个网站，然后才能访问这个网站当中受保护的数据。好了，话题回来，我们想想，在服务器端网站是如何记录当前用户是否合法（是否已经登录了呢），很简单撒，session，这个我想是大家肯定都知道的方法了。原理很简单，我们访问一个网站，网站在我们首次访问的时候，会返回一个cookies信息。这个信息相当于我们在这个网站的一个登录信息。我们每次访问该网站的时候需要带上这个cookies信息，以便让该网站很容易的识别我们先前已经登录该网站了。&#xA;其实步骤很简单，我们需要访问该网站，获取和这个网站会话的cookies信息。然后带这个这个合法的cookies信息重新登录该网站，登录成功后，会在服务器端产生一个保存用户信息的session。以后我们只需每次访问该网站带上合法的cookies信息，服务器端会根据cookies来判别我们是否是合法用户（当前用户信息是否存在session当中）。如果合法我们就可以顺利获取该受保护的网站内容。&#xA;用java来实现一个简单的代码。从指定网站当中获取需要的cookies信息&#xA;URL url_con; HttpURLConnection http_con = null; try { url_con = new URL(url); http_con = (HttpURLConnection) url_con.openConnection(); //构造请求信息，对于安全性稍微高一些的网站，构造此类的请求头信息是必须的，第一次请求不带正确的cookies信息 http_con.setRequestProperty(&#34;User-Agent&#34;, &#34;Mozilla/5.0 (Windows; U; Windows NT 6.0; zh-CN; rv:1.9.1.5) Gecko/20091102 Firefox/3.5.5 (.NET CLR 3.5.30729)&#34;); http_con.setRequestProperty(&#34;Accept&#34;, &#34;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#34;); http_con.setRequestProperty(&#34;Accept-Charset&#34;, &#34;GB2312,utf-8;q=0.7,*;q=0.7&#34;); http_con.setRequestProperty(&#34;Accept-Language&#34;, &#34;zh-cn,zh;q=0.5&#34;); http_con.setRequestProperty(&#34;Host&#34;, &#34;search.cnipr.com&#34;); http_con.setRequestProperty(&#34;Accept-Encoding&#34;, &#34;gzip,deflate&#34;); http_con.setRequestProperty(&#34;Keep-Alive&#34;, &#34;300&#34;); http_con.setRequestProperty(&#34;Connection&#34;, &#34;keep-alive&#34;); http_con.setRequestProperty(&#34;Cookie&#34;, &#34;cizi=2&#34;); http_con.setRequestProperty(&#34;Referer&#34;,&#34;http://www.cnipr.com/top_js.htm&#34;); //设置请求方式为get请求 http_con.setDoInput(true); http_con.setDoOutput(true); http_con.setRequestMethod(&#34;GET&#34;); //建立和服务器之间的连接。 http_con.connect(); String cookieVal = http_con.getHeaderField(&#34;Set-Cookie&#34;); //获取服务器端传回的jsessionId(对于使用tomcat内核的服务器一般传回此类值)值 if (cookieVal != null) { cookiesId = cookieVal.</description>
    </item>
  </channel>
</rss>
