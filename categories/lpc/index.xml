<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LPC on 暗网探秘</title>
    <link>https://anwangtanmi.github.io/categories/lpc/</link>
    <description>Recent content in LPC on 暗网探秘</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 01 Sep 2018 09:56:42 +0800</lastBuildDate>
    <atom:link href="https://anwangtanmi.github.io/categories/lpc/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[Unity][特效][Shader]模型材质马赛克方块</title>
      <link>https://anwangtanmi.github.io/posts/bcbbcbd1cf18661d0029c407cf1e937c/</link>
      <pubDate>Sat, 01 Sep 2018 09:56:42 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/bcbbcbd1cf18661d0029c407cf1e937c/</guid>
      <description>参考资料2，在Asset Store里面搜索 Mosaix，免费的那个。个人遇到一个问题，对摄像头 配置了 mosaix.cs 和 MayaCamera.cs组件后，game视图的场景会变暗。&#xA;2.1在线演示&#xA;导入后 DEMO的演示&#xA;参考资料6 是该插件 的工作室主页，在AssetStore里面搜索censor effect，免费的，也可以达到同样的效果&#xA;马赛克方块&#xA;把censor effect 材质给予 3D 方块，也有同样马赛克的效果。&#xA;参考资料：&#xA;1.&#xA;UnityShader实例12:屏幕特效之马赛克（Mosaic）材质&#xA;2.&#xA;Mosaix, a better Unity mosaic&#xA;2.1http://noisefloordev.s3-website-us-east-1.amazonaws.com/mosaix/unity-chan-demo/index.html&#xA;2.2noisefloordev/mosaix&#xA;3.Shader2D: 一些2D效果的Shader实现&#xA;4.unity shader – 马赛克效果&#xA;5.Unity3D Shader 马赛克后期效果&#xA;6.http://staggart.xyz/&#xA;7.&#xA;8.</description>
    </item>
    <item>
      <title>DL框架之darknet：darknet的简介、安装、使用方法的详细攻略</title>
      <link>https://anwangtanmi.github.io/posts/6961676722ffb5c2aab99d3a60e08075/</link>
      <pubDate>Fri, 13 Apr 2018 09:00:12 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/6961676722ffb5c2aab99d3a60e08075/</guid>
      <description>DL框架之darknet：darknet的简介、安装、使用方法的详细攻略&#xA;目录&#xA;darknet的简介&#xA;darknet的安装&#xA;darknet的使用方法&#xA;１、YOLO: Real-Time Object Detection&#xA;2、ImageNet Classification&#xA;3、Nightmare&#xA;4、RNNs in Darknet&#xA;5、DarkGo: Go in Darknet&#xA;6、Train a Classifier on CIFAR-10&#xA;7、Hardware Guide: Neural Networks on GPUs (Updated 2016-1-30)&#xA;darknet的简介 Darknet is an open source neural network framework written in C and CUDA. It is fast, easy to install, and supports CPU and GPU computation.&#xA;For more information see the Darknet project website. For questions or issues please use the Google Group.</description>
    </item>
    <item>
      <title>LXDE桌面初始设置，Fedora27系统。</title>
      <link>https://anwangtanmi.github.io/posts/2aa402263c39dca93e40339ff158ae83/</link>
      <pubDate>Sun, 08 Apr 2018 09:21:49 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/2aa402263c39dca93e40339ff158ae83/</guid>
      <description> 一、主题&#xA;安装主题：&#xA;方法1、通过软件源安装主题，默认xfce安装的主题有限不一定符合我们的口味。 [root@Fedora ~]# dnf search themes #搜索可用主题&#xA;通过上面的搜索会列出很多软件，有选择的进行进行安装。&#xA;[root@Fedora ~]# dnf install mint-themes.noarch #如mint主题安装&#xA;方法2、&#xA;在&#xA;https://www.box-look.org/网站的Openbox Themes标签页选择喜欢的主题下载解压到/usr/share/themes/目录下，最重要的是窗口边框主题，因为我个人觉得系统自带的边框实在是太丑了，个人比较喜欢&#xA;https://www.box-look.org/p/1017533/下的Arc-Openbox 窗口边框主题,在这个页面下载的是arc-openbox-master.zip文解压后不能将这个文件（目录）直接复制到主题目录，需要将里面的Arc Arc-Dark Arc-Darker 三个文件（目录）复制过去，因为这三个文件里都有openbox-3这个目录，有这个目录的父目录才可以直接负责到主题目录从而生效。&#xA;二、图标&#xA;方法1、&#xA;[root@Fedora ~]# dnf search icon #搜索可用主题&#xA;通过上面的搜索会列出很多软件，有选择的进行进行安装。&#xA;[root@Fedora ~]# dnf install faience-icon-theme.noarch #faience 图标，个人比较喜欢&#xA;方法2、去 https://www.box-look.org/ 网站选择喜欢的主题文件下载解压到/usr/share/icons/目录下&#xA;三、安装Xfce电源管理器，LXDE默认安装没有电源管理，笔记电脑没有电源管理怎么行，Xfce电源管理器是一个强大的小应用程序，允许用户配置电源管理工作。它提供了用于常规配置的选项卡以及显示系统和设备的选项卡。Xfce电源管理器还会在系统托盘中显示一个图标，以便用户可以快速读取设备的电池状态。&#xA;安装：[root@Fedora ~]# dnf install xfce4-power-manager.x86_64 </description>
    </item>
    <item>
      <title>Shader屏幕后處理效果</title>
      <link>https://anwangtanmi.github.io/posts/d844a2c33dd602339d2f498f111546df/</link>
      <pubDate>Sat, 23 Dec 2017 20:08:17 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/d844a2c33dd602339d2f498f111546df/</guid>
      <description>Shader屏幕后處理效果 邊緣檢測： 边缘检测的原理是利用一些边缘检测算子对图像进行卷积操作（卷积操作就是使用一个卷积核对一张图像的每一个像素进行一系列的操作，倦急核通常是一个四方形网格结构，例如2×2，3×3的方形区域，该区域内每个方格都有一个权重值。当对图像中的某个像素进行卷积时，我们会把卷积核的中心放置在该像素上，如下图，翻转之后再依次进行计算核中的每个元素和其覆盖的图像像素值的乘积并求和，得到的结果就是改为只的新像素值） 常见的边缘检测算子 卷积操作的神奇指出 在于选择的卷积核，用于边缘检测的卷积核（边缘检测算子）是什么？ 首先想一下 如果相邻像素之间存在差别明显的颜色，亮度等属性，那么他们之间应该有一条边界。这种相邻像素之间的差值可以用梯度来表示，边缘处的梯度绝对值比较大，所以，就出现下面几种边缘检测算子； 下面请看注释： Shader &#34;MyShader/OutLine&#34; { Properties{ _MainTex(&#34;MainTexture&#34;,2D) = &#34;White&#34;{} _LineColor(&#34;OutLineColor&#34;,color) = (1,1,1,1) _BackGroundColor(&#34;BackGroundColor&#34;,color) = (1,1,1,1) _EdgeOnly(&#34;EdgeOnly&#34;,float)=3 } SubShader{ Tags{&#34;RenderType&#34; = &#34;Transparent&#34;} Pass { Cull off ZTest Always ZWrite off CGPROGRAM #pragma vertex vert #pragma fragment frag #include &#34;UnityCG.cginc&#34; sampler2D _MainTex; float4 _MainTex_TexelSize; fixed4 _LineColor; fixed4 _BackGroundColor; float _EdgeOnly; struct a2v { fixed4 vertex : POSITION; fixed2 uv : TEXCOORD; }; struct v2f { fixed4 pos : SV_POSITION; fixed2 uv[9]:TEXCOORD;//对应了使用Sobel算子采样是需要的 //九个领域纹理坐标 }; fixed luminance(fixed4 color) { return color.</description>
    </item>
    <item>
      <title>关于LPC4357接汽车的CAN导致系统卡死无法工作的问题</title>
      <link>https://anwangtanmi.github.io/posts/350bda51f6d9363243a402241a9fe4de/</link>
      <pubDate>Mon, 27 Nov 2017 11:27:50 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/350bda51f6d9363243a402241a9fe4de/</guid>
      <description>新项目在11月中的时候到汽车厂装机调试，该项目使用的LPC4357芯片，使用UI demo显示系统工作正常，能正常显示对应的内容。当接收汽车CAN数据时，发现不能显示正确的UI并且无法调节LCD亮度及combiner的角度。在平时开发过程中，使用USBCAN模拟器可以正常使用。&#xA;后经使用J-Link调试发现，程序卡在CAN的中断处理函数中出不来，一直在while里面死循环，没有调到接收数据的回调函数RX_cb();if((1&amp;lt;&amp;lt;(msg_no-1))!= LPC_C_CAN1-&amp;gt;ND1)总是成立，认为是错误，再查看，msg_no = 1，LPC_C_CAN1-&amp;gt;ND1 = 0x07，msg_no = 1是一个报文周期为10ms的CAN数据。开始以为是中断来的太频繁导致中断处理不及时，但是通过查找资料发现CAN是有接收缓存的，应该不会出现处理不及时的问题。LPC_C_CAN1-&amp;gt;ND1这个是指哪个位置有新数据就会置1，那么msg_no = 1确实是有新数据的那一位，就发现这个语句的bug，当数据来的比较快的时候，CAN会缓存一部分数据，不是一个一个msg处理的，那么&#xA;LPC_C_CAN1-&amp;gt;ND1不会只置一位，那么&#xA;判断就会不等于，后来修改为if((1&amp;lt;&amp;lt;(msg_no-1))&amp;amp; LPC_C_CAN1-&amp;gt;ND1 == 0)，对应位有数据就调用RX_cb(),这么修改之后，解决了中断频繁导致的系统卡死问题。&#xA;在调试过程中发现，在收到数据中断之前，会收到一个状态中断，是一个接收成功中断，也就是说，每成功接收一个数据都会收到一个接收成功中断，那么接收一个10ms周期的报文，会收到两个中断，这样中断太频繁，为了避免增加CPU压力，在CAN初始化的时候不打开这个中断。</description>
    </item>
    <item>
      <title>UE4实现闪烁效果</title>
      <link>https://anwangtanmi.github.io/posts/0804dd8c469ae19f7c2b371b75c8aed3/</link>
      <pubDate>Wed, 05 Oct 2016 16:08:20 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/0804dd8c469ae19f7c2b371b75c8aed3/</guid>
      <description>官网文档链接:http://docs.unrealengine.com/latest/CHN/Engine/Rendering/Materials/ExpressionReference/Math/index.html?utm_source=editor&amp;amp;utm_medium=docs&amp;amp;utm_campaign=rightclick_matnode&#xA;这里主要是利用一个数学表达式的Cosine(余弦)节点在材质中利用连续的振荡波形实现简单的闪烁效果的，具体的在官方文档中讲得十分详细，相当于只是发了文档链接作个记忆备份。&#xA;利用不同的数学节点可以做出例如闪烁之类相当多的效果。</description>
    </item>
    <item>
      <title>Shader特效——实现“抗锯齿的黑白格”并原理解析【GLSL】</title>
      <link>https://anwangtanmi.github.io/posts/0aa9a0169a6ea4c726f78cbfff5a9362/</link>
      <pubDate>Sun, 07 Aug 2016 16:33:45 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/0aa9a0169a6ea4c726f78cbfff5a9362/</guid>
      <description>最终效果图： 完整 代码与分析 如下：&#xA;#extension GL_OES_standard_derivatives:enable //precision highp float; uniform int u_frequency; // ❤ 小格子的个数 = (2*freq)^2， 大格子的个数 = freq^2 uniform vec4 u_color0; // 白色 uniform vec4 u_color1; // 黑色 varying vec2 v_st; void main() { vec4 color; vec2 st_width; vec2 fuzz; vec2 pmod; float fuzz_max; st_width = fwidth(v_st); fuzz = st_width * float(u_frequency) * 2.0; fuzz_max = max(fuzz.s, fuzz.t); pmod = fract(v_st * float(u_frequency)); // ❤ 创建大网格，每个格子的 pmod 都 ∈ [0, 1) // 测试 //color = vec4(v_st * float(u_frequency), 0.</description>
    </item>
    <item>
      <title>shader forge初级篇|反射材质的运用</title>
      <link>https://anwangtanmi.github.io/posts/3666c224101f9fbb58cd494b829bbc71/</link>
      <pubDate>Fri, 06 May 2016 17:48:23 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/3666c224101f9fbb58cd494b829bbc71/</guid>
      <description>反射效果在制作游戏场景时是经常需要的，特别是在大理石、陶瓷类材质上有助于提升场景质感与氛围。&#xA;说道反射，游戏中常见做法就是利用当前场景cubemap作为反射源 而cubemap又是当前场景+Skybox的作用结果。&#xA;一 制作CubeMap&#xA;天空球【网上可以下载到很多.unitypackage，只说明unity新版本5.0之后将skybox移到了Lightmap下设置，旧版本在RenderSettings下设置】 cubemap【5.3.4版本在这里如图第三级资源目录下创建cubemap ,旧版本在第二级目录即可找到】 在场景中心，也就是你认为能反射全景的中心位置创建一个Sphere 如图 创建cubemap脚本代码【在资源目录的Editor文件夹中新建js脚本RenderCubemapWizard，将下面代码粘进去即可】 // Render scene from a given point into a static cube map. // Place this script in Editor folder of your project. // Then use the cubemap with one of Reflective shaders! class RenderCubemapWizard extends ScriptableWizard { var renderFromPosition : Transform; var cubemap : Cubemap; function OnWizardUpdate () { helpString = &#34;Select transform to render from and cubemap to render into&#34;</description>
    </item>
    <item>
      <title>【图形学】谈谈噪声</title>
      <link>https://anwangtanmi.github.io/posts/c11084a10fc8a635759685714fecda15/</link>
      <pubDate>Mon, 21 Dec 2015 17:36:14 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/c11084a10fc8a635759685714fecda15/</guid>
      <description>写在前面 很早就想学习和整理下噪声，稍微接触过图形学的人大概都听到过噪声，然后就会发现有各种噪声，Perlin噪声，Worley噪声，分形（fractal）噪声等等。尤其是Perlin噪声，一搜资料发现大家说的各不相同，更加不明所以。我也总是困惑，后来发现还是要相信wiki和paper。&#xA;这篇文章在于总结上面这些常见的噪声（即图形学中常见的程序噪声），它们是什么，怎么算出来的，以及一些应用。文章里的所有代码可以在我的Shadertoy上找到：&#xA;2D版：&#xA;width=”500″ height=”320″ src=”https://www.shadertoy.com/embed/ldc3RB?gui=true&amp;amp;t=10&amp;amp;paused=true&amp;amp;muted=false” allowfullscreen=””&amp;gt;&#xA;3D版：&#xA;width=”500″ height=”320″ src=”https://www.shadertoy.com/embed/4sc3z2?gui=true&amp;amp;t=10&amp;amp;paused=false&amp;amp;muted=false” allowfullscreen=””&amp;gt;&#xA;什么是噪声 在图形学中，我们使用噪声就是为了把一些随机变量来引入到程序中。从程序角度来说，噪声很好理解，我们希望给定一个输入，程序可以给出一个输出：&#xA;value_type noise(value_type p) { ... } 它的输入和输出类型的维数可以是不同的组合，例如输入二维输出一维，输入二维输出二维等。我们今天就是想讨论一下上面函数中的实现部分是长什么样的。&#xA;为什么我们需要这么多噪声 我对噪声的学习还没有很深，在此只想谈一点自己的想法。噪声其实就是为了把一些随机变量引入到程序中。在我们写一些C++这样的程序时，也经常会使用random这样的函数。这些函数通常会产生一些伪随机数，但很多情况下也足够满足我们的需要。同样，在图形学中我们也经常会需要使用随机变量，例如火焰、地形、云朵的模拟等等。相信你肯定听过大名鼎鼎的Minecraft游戏，这个游戏里面的地形生成也大量使用了随机变量。那么我们直接使用random这种函数不就好了吗？为什么要引入这么多名字的噪声呢？&#xA;这种直接使用随机生成器生成的随机值固然有它的好处，但它的问题在于生成的随机值太“随机”了。在图形学中，我们可以认为这种噪声就是白噪声（White noise）。wiki上说白噪声是功率谱密度在整个频域内均匀分布的噪声，听不懂对不对？通俗来讲，之所以称它为“白”噪声，是因为它类似于光学中包括全部可见光频率在内的白光。我相信你肯定听过白噪声，小时候电视机收音机没信号时，发出的那个沙沙声就是一种声音上的白噪声。我们这里只需要把白噪声理解为最简单的随机值，例如二维的白噪声纹理可以是下面这个样子：&#xA;可以看出白噪声非常不自然，听起来很刺耳，看起来也不好看。不光你这么想，图形学领域的前辈们也早发现了。如果你观察现实生活中的自然噪声，它们不会长成上面这个样子。例如木头纹理、山脉起伏，它们的形状大多是趋于分形状（fractal）的，即包含了不同程度的细节。比如地形，它有起伏很大的山脉，也有起伏稍小的山丘，也有细节非常多的石子等，这些不同程度的细节共同组成了一个自然的地形表面。那么，我们如何用程序来生成类似这样的自然的随机数（可以想象对应了地形不同的高度）呢？学者们根据效率、用途、自然程度（即效果好坏）等方面的衡量，提出了许多希望用程序模拟自然噪声的方法。例如，Perlin噪声被大量用于云朵、火焰和地形等自然环境的模拟；Simplex噪声在其基础上进行了改进，提到了效率和效果；而Worley噪声被提出用于模拟一些多孔结构，例如纸张、木纹等。&#xA;因此，学习和理解这些噪声在图形学中是十分必要的，因为它们的应用实在是太广泛了！&#xA;噪声的分类 根据wiki，由程序产生噪声的方法大致可以分为两类：&#xA;类别 名称 基于晶格的方法（Lattice based） 又可细分为两种：&#xA;第一种是梯度噪声（Gradient noise），包括Perlin噪声， Simplex噪声，Wavelet噪声等；&#xA;第二种是Value噪声（Value noise）。 基于点的方法（Point based） Worley噪声 需要注意的是，一些文章经常会把Perlin噪声、Value噪声与分形噪声（Fractal noise）弄混，这实际在概念上是有些不一样的。分形噪声会把多个不同振幅、不同频率的octave相叠加，得到一个更加自然的噪声。而这些octave则对应了不同的来源，它可以是Gradient噪声（例如Perlin噪声）或Value噪声，也可以是一个简单的白噪声（White noise）。&#xA;一些非常出色的文章也错误把这种分形噪声声称为Perlin噪声，例如：&#xA;Hugo Elias的文章，这篇文章讲得挺有趣的，关于什么是octave、怎么混合它们都讲得很细致，也非常有名，但作者错误地把值噪声+分形噪声标识为Perlin噪声，他的文章链接也出现了wiki的值噪声（Value noise）的页面中。&#xA;Devmag的如何在你的游戏中使用Perlin噪声一文，同样非常有名，但同样错误地把白噪声+分形噪声认为是Perlin噪声。&#xA;如果读者常逛shadertoy的话，会发现很多shader使用了类似名为fbm的噪声函数。fbm实际就是分型布朗运动（Fractal Brownian Motion）的缩写，读者可以把它等同于我们上面所说的分形噪声（Fractal noise），我们以下均使用fbm来表示这种噪声的计算方法。如果要通俗地说fbm和之前提及的Perlin噪声、Simplex噪声、Value噪声、白噪声之间的联系，我们可以认为是很多个不同频率、不同振幅的基础噪声（指之前提到的Perlin噪声、Simplex噪声、Value噪声、白噪声等之一）之间相互叠加，最后形成了最终的分形噪声。这里的频率指的是计算噪声时的采样距离，例如对于基于晶格的噪声们，频率越高，单位面积（特指二维）内的晶格数目越多，看起来噪声纹理“越密集”；而振幅指的就是噪声的值域。下图显示了一些基础噪声和它们fbm后的效果：&#xA;说明：分割线左侧表示单层的基础噪声，右侧表示通过叠加不同频率噪声后的fbm效果。上面效果来源于shadertoy：Perlin噪声，Simplex噪声，Value噪声，Worley噪声。&#xA;由于Worley噪声的生成和其他噪声有明显不同，因此不是本文的重点。它主要用于产生孔状的噪声，有兴趣的读者可以参见偶像iq的文章：&#xA;http://www.iquilezles.org/www/articles/smoothvoronoi/smoothvoronoi.htm http://www.iquilezles.org/www/articles/voronoise/voronoise.htm Perlin噪声、Simplex噪声和Value噪声在性能上大致满足：Perlin噪声 &amp;gt; Value噪声 &amp;gt; Simplex噪声，Simplex噪声性能最好。Perlin噪声和Value噪声的复杂度是&#xA;O(2n)&#xA;，其中n是维数，但Perlin噪声比Value噪声需要进行更多的乘法（点乘）操作。而Simplex噪声的复杂度为&#xA;O(n2)&#xA;，在高纬度上优化明显。&#xA;下面的内容就是重点解释Perlin噪声、Perlin噪声和Simplex噪声这三种常见的噪声，最后再介绍fbm。 Perlin噪声 先介绍大名鼎鼎的Perlin噪声。很多人都知道，Perlin噪声的名字来源于它的创始人Ken Perlin。Ken Perlin早在1983年就提出了Perlin noise，当时他正在参与制作迪士尼的动画电影《电子世界争霸战》（英语：TRON），但是他不满足于当时计算机产生的那种非常不自然的纹理效果，因此提出了Perlin噪声。随后，他在1984年的SIGGRAPH Course上做了名为Advanced Image Synthesis1的课程演讲，并在SIGGRAPH 1985上发表了他的论文2。由于Perlin噪声的算法简单，被迅速应用到各种商业软件中。我们这位善良的Perlin先生却并没有对Perlin噪声算法申请专利（他说他的祖母曾叫他这么做过……），如果他这么做了那会是多大一笔费用啊！（不过在2001年的时候，旁人看不下去了，把三维以上的Simplex噪声的专利主动授予了Perlin。对，Simplex噪声也是人家提出的……）再后来Perlin继续研究程序纹理的生成，并和他的一名学生又在SIGGRAPH 1989上发表了一篇文章3，提出了超级纹理（hypertexture）。他们使用噪声+fbm+ray marching实现了各种有趣的效果。到1990年，已经有大量公司在他们的产品中使用了Perlin噪声。在1999年的GDCHardCore大会上，Ken Perlin做了名为Making Noise的演讲4，系统地介绍了Perlin噪声的发展、实现细节和应用。如果读者不想读论文的话，强烈建议你看一下Perlin演讲的PPT。</description>
    </item>
    <item>
      <title>Ubuntu14.04–SUMO–Omnet&#43;&#43;和Veins</title>
      <link>https://anwangtanmi.github.io/posts/6fc37e0c1008bad05b7403736eaba40e/</link>
      <pubDate>Thu, 21 Aug 2014 18:57:49 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/6fc37e0c1008bad05b7403736eaba40e/</guid>
      <description>研究需要，所以安装这些工具。&#xA;按照car2x.org网页tutorial的说明，在Ubuntu环境更理想，但该指南是以windows系统为例说明安装。尝试后会发现，windows环境安装远比Ubuntu环境方便很多。&#xA;言归正传：&#xA;1. 先装好Ubuntu14.04（本人环境win7-64+virtualBox）&#xA;2. 根据Omnet++ 4.4.1 InstallationGuide 之Chapter 5. Ubuntu说明，完成预装模块：&#xA;$ sudo apt-get update&#xA;$ sudo apt-get install build-essential gcc g++ bison flex perl tcl-dev tk-dev blt libxml2-dev zlib1g-dev default-jre doxygen graphviz libwebkitgtk-1.0-0 openmpi-bin libopenmpi-dev libpcap-dev&#xA;3. 不建议在Ubuntu下下载Omnet++4.4.1，觉得速度太慢，建议其他方式下好后在相关目录下解压。&#xA;4. 检查配置：$ ./configure (如果发现异常情况，一定要做补救，比如安装所缺模块，否则会影响后续编译，导致错误）。&#xA;5 . 常见的需要安装的模块：Tcl/Tk （第2步已包括，但不知为何检查时提示没有。参考了–philips_629的博文：“ubuntu安装ns2时tcl/tk的问题”&#xA;6. 安装JRE，参考 了–lindabell的博文“ubuntu怎么安装JRE”进行；&#xA;7. 安装BLT：sudo apt-get install blt，提示安装进行并完成。重新检查./configure，根据提示直到提示需要的都ok：&#xA;8. make成功后，可以直接用omnetpp进入IDE界面（图像界面）。&#xA;9. 安装sumo，也使用./configure 检查配置情况。参考以下博文：“SUMO仿真快速入门系列一：Ubuntu 12.04下安装SUMO”。&#xA;10. PROJ也是需要预装的模块。再次./configure 无差错后进行make。&#xA;11. 正常编译后可以用sumo测试软件是否正常（会有版本提示，如果需要图形界面，则使用sumo-gui）。&#xA;12. 安装veins-3a3。先在选定的文件夹下解压，然后启动Omnetpp，载入project后Build all（具体细节在Car2x 网站上有说明）。</description>
    </item>
    <item>
      <title>去除图片的阴影部分，只显示图片：</title>
      <link>https://anwangtanmi.github.io/posts/c14ac2f2f50177f72e203faf6b4b2590/</link>
      <pubDate>Sun, 20 Jul 2014 13:18:12 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/c14ac2f2f50177f72e203faf6b4b2590/</guid>
      <description> 去除图片的阴影部分，只显示图片： 1.在Unity中制作背景图片，首先要建立一个材质（Material），然后把这个图片附在这个材质上。 2.在Unity中创建一个Plane，然后可以把刚刚建好的材质附在这个Panel上（也可以建立Cube来代替Plane），调整好大小就可以把这个背景图片显示在Unity中了。 3.因为图片不能直接附到Plane上，所以一定要通过材质。 4.最后一步就是设置这个Plane的Shader： 4.1.自发光：Mobile-&amp;gt;Unlit(Supports Lightmap) 4.2.只显示图片的形状：Particles-&amp;gt;Alpha Blended </description>
    </item>
  </channel>
</rss>
