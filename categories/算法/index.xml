<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 on 暗网探秘</title>
    <link>https://anwangtanmi.github.io/categories/%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 算法 on 暗网探秘</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 07 Mar 2019 11:14:57 +0800</lastBuildDate>
    <atom:link href="https://anwangtanmi.github.io/categories/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>低照度图像增强之卷积神经网络RetinexNet</title>
      <link>https://anwangtanmi.github.io/posts/b626af0a0393720309286479e0d11fce/</link>
      <pubDate>Thu, 07 Mar 2019 11:14:57 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/b626af0a0393720309286479e0d11fce/</guid>
      <description>转载请标注：https://blog.csdn.net/weixin_38285131&#xA;目录&#xA;一丶Retinex理论——图像分解&#xA;二丶RetinexNet卷积神经网络&#xA;1.训练数据说明&#xA;2.分解网络——Decom&#xA;3.增强网络——Relight&#xA;4.结果展示&#xA;低照度图像增强一直是计算机视觉领域的一个热门研究方向，之前传统的基于Retinex理论的研究方法已经出现很多，比如：MSR,MSRCR,MSRCP等，这些方法在低照度图像增强方面效果有明显提升，上一篇博客主要介绍了基于Retinex理论的集中图像增强方法，并给出了python代码。博客链接如下： [图像增强Retinex算法之python实现——MSR,MSRCR,MSRCP,autoMSRCR](https://blog.csdn.net/weixin_38285131/article/details/88097771)&#xA;但是基于传统的图像图像处理方法处理每一张图像会比较耗时，一副4000*8000的图像需要耗时十几分钟，这样就没法批量处理低照度图像，因此本文介绍一种基于Retinex理论的卷积神经网络模型——RetinexNet,该模型是北大的童鞋在2018年发表在BMVC上的，论文名字是——Deep Retinex Decomposition for Low-Light Enhancement&#xA;[论文PDF]&#xA;RetinexNet项目介绍，数据集，PPT等&#xA;一丶Retinex理论——图像分解 这个理论在上一篇博客中已有介绍，任何一幅图像可以分解为光照图像（illumination）和反射图像（reflectance），反射图像是物体的本身性质决定的即为不变的部分，光照图则受外界影响比较到，可以去除光照影响或者对光照图像进行校正，则可以达到增强图像的目的。如下图所示：&#xA;左边即为低照度图像，中间即为光照图，右边即为反射图像，原图S（x,y）=I(x,y)*R(x,y),将图像变换到log域则变成了相减，然后将光照图像减去即可达到增强图像的目的。&#xA;二丶RetinexNet卷积神经网络 摘抄自论文摘要：&#xA;Retinex理论是一种有效的微光图像增强工具。假设观测图像可以分解为反射图像和照度图像。大多数现有的基于Retinex卢纶的方法都为这种高度不适定的分解精心设计了手工约束和参数，当应用于各种场景时，这些约束和参数可能会受到模型容量的限制。Retinex包括一个用于分解的分解网络（Decom）和一个用于照明调节（Relight）的增强网络。在分解网络的训练过程中，没有分解反射和光照的地面真值。该网络的学习只有关键的约束条件，包括低/正常光图像共享的一致反射率，以及光照的平滑度。在分解的基础上，利用增强网络增强网对光照进行后续的亮度增强，联合去噪对反射率进行去噪操作。视网膜网是端到端可训练的，学习分解的性质有利于亮度的调节。&#xA;理论整体路线即为下图所示：&#xA;输入:低照度图像&#xA;分解网络（Decom）：对图像进行分解&#xA;增强网络（Relight）：对图像进行增强和调整&#xA;输出：校正之后的图像&#xA;1.训练数据说明 数据主要是利用单反相机不同的光圈值和感光度拍摄同一个场景，作为图像对进行训练，也就是说同一场景拍摄一个低照度图像，然后在拍摄一个正常图像进行训练，具体数据如下图所示：&#xA;作图为正常拍摄图像，右图为低照度图像，大概拍摄了500张图像对作为训练数据&#xA;2.分解网络——Decom 文中的分解网络应该是一个五层的卷积神经网络，代码中是利用relu函数进行激活，没有什么特别的处理，具体结构如下：&#xA;可以看到将图像对中的低照度图像和正常图像作为输入数据送入卷积神经网络进行分解，最后得到光照图像和反射图像，根据Retinex理论反射图像基本接近，但是两者光照图像相差很大，这样把每一张训练图像进行分解，然后再送入后面的增强网络进行训练。&#xA;3.增强网络——Relight 增强网络，我看代码应该是一个九层的卷积神经网络，利用relu进行激活，中间还进行最邻近差值的resize操作，具体如下图：&#xA;对刚才分解的反射图像进行去噪音操作，他中间用了平滑，但是我觉得用了平滑之后降低了图像本身的锐度，图像变得模糊，个人觉得这一步还应该做一下增强处理，回头看看能不能修改一下这个中间处理操作。应该可以用拉普拉斯进行一下图像恢复吧，我觉得这一步降低图像锐度不太好，重建图像稍显模糊。&#xA;4.结果展示 中间即为校正之后的，右边为正常光照图像，虽然和正常图像比不了，但是已经很不错了，&#xA;最后与其他算法做了一些对比工作，感觉各有千秋吧，不过都有一定的亮度提升，还是很值得研究一哈的 做一下改进。&#xA;下一步，我准备用这个神经网络训练一下自己的数据，然后测试一下增强效果。&#xA;数据集百度网盘地址&#xA;github地址&#xA;转载请注明地址：https://blog.csdn.net/weixin_38285131</description>
    </item>
    <item>
      <title>计蒜客2019蓝桥杯省赛A组模拟赛（一）题目及解析</title>
      <link>https://anwangtanmi.github.io/posts/b98d5d8c3e947c72ef6bad1fdfa74ccf/</link>
      <pubDate>Sat, 02 Feb 2019 01:28:45 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/b98d5d8c3e947c72ef6bad1fdfa74ccf/</guid>
      <description>蓝桥杯历年真题题目及题解目录汇总 A. 结果填空：阶乘位数 题库链接 分值: 5&#xA;蒜头君对阶乘产生了兴趣，他列出了前 10 个正整数的阶乘以及对应位数的表：&#xA;n n! 位数 1 1 1 2 2 1 3 6 1 4 24 2 5 120 3 6 720 3 7 5040 4 8 40320 5 9 362880 6 10 3628800 7 对于蒜头君来说，再往后就很难计算了。他试图寻找阶乘位数的规律，但是失败了。现在请你帮他计算出第一个正整数的阶乘位数大于等于 10000 的数是多少，即求最小的正整数 n 满足 n! 的位数大于等于 10000。&#xA;答案3249，细节，注意少点new对象，大数类的对象之类的，很耗时间，打牛客的时候入过坑&#xA;import java.math.BigInteger; public class 阶乘位数 { public static void main(String[] args) { BigInteger n = BigInteger.valueOf(1); BigInteger one =BigInteger.</description>
    </item>
    <item>
      <title>算法刷题（18）_逆时针打印矩阵学习记录</title>
      <link>https://anwangtanmi.github.io/posts/8817c767310876b8497cb1edb036507e/</link>
      <pubDate>Sun, 29 Jul 2018 05:12:15 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/8817c767310876b8497cb1edb036507e/</guid>
      <description>算法刷题（18）_逆时针打印矩阵学习记录&#xA;【说明】&#xA;题目：输入一个矩阵，按照从外向里以顺时针顺序依次打印出每一个数字，例如：如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1, 5，9，13，14，15，16，12，8，4，3，2，6，10，11，7.&#xA;【算法实现】&#xA;package p4; /** * 逆时针打印矩阵 * @author Guozhu Zhu * @date 2018/7/29 * @version 1.0 * */ public class Test02 { public static void main(String[] args) { int[][] arr = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}, {10, 11, 12}}; int[] res = Solution01(arr, 4, 3); for (int i : res) { System.</description>
    </item>
    <item>
      <title>leetcode经典题目及解法记录</title>
      <link>https://anwangtanmi.github.io/posts/bbfae7d99f50c3099d1d6411140f1f01/</link>
      <pubDate>Fri, 20 Oct 2017 22:43:50 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/bbfae7d99f50c3099d1d6411140f1f01/</guid>
      <description>Question15 3Sum&#xA;Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets.&#xA;For example, given array S = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ] 解法如下：</description>
    </item>
    <item>
      <title>Elo评分算法原理与实现</title>
      <link>https://anwangtanmi.github.io/posts/d05574d98dba316f063e857ff8d1e440/</link>
      <pubDate>Wed, 19 Apr 2017 15:38:55 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/d05574d98dba316f063e857ff8d1e440/</guid>
      <description>《社交网络》里的Mark Zackburg被女朋友甩后，在舍友的启发下，充分发挥了技术宅男自娱自乐的恶搞天分，做出了Facemash网站，对学校女生的相貌进行排名打分，结果网站访问流量过大，直接把学校网络搞瘫痪了。Facemask大受欢迎的关键就在于Zackburg基友Eduardo写在窗户上的排名公式，看电影之时就对这个排名公式非常感兴趣，上网了解下，才发现这条公式就是大名鼎鼎的ELO等级分制度。ELO的应用非常广泛，大部分棋类比赛，现在流行的MODB游戏，像11平台的DOTA天梯系统，都是采用ELO等级分。&#xA;ELO等级分制度是由匈牙利裔美国物理学家Elo创建的一个衡量各类对弈活动选手水平的评分方法，是当今对弈水平评估的公认的权威方法。被广泛应用于国际象棋、围棋、足球等运动，以及很多网游与电子竞技产业。游戏界比较著名的应用有： WOW（魔兽世界）、DOTA、LOL。&#xA;ELO计算方法 Ra：A玩家当前的积分 Rb：B玩家当前的积分 Sa：实际胜负值，胜=1，平=0.5，负=0 Ea：预期A选手的胜负值，Ea=1/(1+10^[(Rb-Ra)/400]) Eb：预期B选手的胜负值，Eb=1/(1+10^[(Ra-Rb)/400]) 因为E值也为预估，则Ea+ Eb=1 R’a=Ra+K（Sa-Ea） R’a：A玩家进行了一场比赛之后的积分 其中 K 值是一个常量系数，按照国际象棋里的标准， K 值对于大师选手为16，对于一般选手是32。K值的大小直接关系到一局游戏结束，根据胜负关系计算出的积分变化值。&#xA;关于K值 K值是一个极限值，代表理论上最多可以赢一个玩家的得分和失分，K/2就是相同rating的玩家其中一方胜利后所得的分数。国际象棋大师赛中，K=16；在大部分的游戏规则中，K=32。通常水平越高的比赛中其K值越小，这样做是为了避免少数的几场比赛就能改变高端顶尖玩家的排名。&#xA;关于分母400 公式Ea和Eb中分母的400是怎么来的呢？为何是400，不是200、100或者是其他？ 根据公式可以得出，当K值相同的情况下，越高的分母，越低的积分变化。总体来说400是一个平衡的、万金油的值、让多数玩家积分保持 标准正态分布 的值。具体可以参考：http://en.chessbase.com/post/arpad-elo-and-the-elo-rating-system&#xA;实例说明 若当前A玩家积分为1500，B玩家积分为1600 预估A玩家的胜负值： Ea = 1/(1+10^[（1600-1500）/400]）≈0.36 预估B玩家的胜负值： Eb = 1-Ea = 1-0.36 = 0.64 假设A玩家获胜，实际胜负值为Sa = 1 A玩家最终得分为 ：R’a = 1500 + 32*(1-0.36) = 1500+20.5 = 1520 A玩家赢20分，B玩家输20分。 假设B玩家获胜，实际胜负值为Sa = 1 B队最终得分为 R’b = 1600 + 32*(1-0.64) = 1600 + 11.52 = 1612，B玩家赢12分，A玩家输12分。</description>
    </item>
    <item>
      <title>一道逻辑题 房间里有100盏电灯</title>
      <link>https://anwangtanmi.github.io/posts/1bfd5f913ec685481beeba343063fb1f/</link>
      <pubDate>Sun, 12 Apr 2015 16:41:51 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/1bfd5f913ec685481beeba343063fb1f/</guid>
      <description> 在&#xA;博客园看到的这个问题，也想做一下。题目是这样的 房间里有100盏电灯，编号为1，2，3……100，每盏灯上有一个按钮，初始时灯全都是关的。编好号的100位同学由房间外依次走进去，将自己编号的倍数的灯的按钮全部按一次，例如第一位同学把编号是1的倍数的灯的按钮按一下（此时100盏灯全亮），第二位同学把编号是2的倍数的灯的按钮按一下（此时只有50盏灯亮着，50盏被这个人按灭了）……第100位同学把编号是100的倍数的灯（即编号为100的灯）的按钮按一下，请问依次走完后，还有多少盏灯亮着？&#xA;最简单的做法就是模拟一下100个同学进入房间的情景，从1号同学开始每个人都去按一遍开关，最后看一下哪些灯亮着，这个方法最简单也最容易想到，可是效率有点低。其实可以计算一下每个开关被按下的次数，因为刚开始的时候所有的灯泡都是关着的，所以如果某个灯泡的开关被按了奇数次，那么这个灯泡最终就是开着的，否则就是关着的。那怎么计算每个灯泡开关被按下的次数呢？因为每个同学都会按下自己编号倍数的开关，即如果灯泡编号是同学编号的倍数，他就会按下开关，也就是说如果同学编号是灯泡编号的约数，他就会按下开关（这不是废话么）。那么统计一下灯泡编号约数的个数就可以了，约数个数为计数的灯泡最后开着，约数个数为偶数的灯泡最后关着。下边是代码：&#xA;public class Lamp { public static void main(String[] args){ int result = 0; for(int i=1;i&amp;lt;=100;i++){ if(isOdd(getFactorNum(i))){ result += 1; } } System.out.println(result); } //求n约数的个数 public static int getFactorNum(int n){ int result = 0; for(int i=1;i&amp;lt;=n;i++){ if(n%i == 0){ result += 1; } } return result; } //判断n是否为奇数 public static boolean isOdd(int n){ return (n&amp;amp;1) == 1; } } ——————————–更新——————————&#xA;又想了一下还有更简单的算法，因为一个数的约数都成成对出现的，也就是说如果n存在一个约数p，那么一定有一个q与之相对应且满足n=pq，所以n约数的个数一定是偶数，但是有一种情况例外，那就是p=q，所以只有编号为完全平方数的灯泡亮着。按着这个方法计算就简单多了，直接return (int)Math.sqrt(100); </description>
    </item>
    <item>
      <title>18大经典数据挖掘算法小结</title>
      <link>https://anwangtanmi.github.io/posts/4766cd206629065c1decfe08cecd9936/</link>
      <pubDate>Fri, 27 Feb 2015 10:04:01 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/4766cd206629065c1decfe08cecd9936/</guid>
      <description>本文所有涉及到的数据挖掘代码的都放在了我的github上了。&#xA;地址链接: https://github.com/linyiqun/DataMiningAlgorithm&#xA;大概花了将近2个月的时间，自己把18大数据挖掘的经典算法进行了学习并且进行了代码实现，涉及到了决策分类，聚类，链接挖掘，关联挖掘，模式挖掘等等方面。也算是对数据挖掘领域的小小入门了吧。下面就做个小小的总结，后面都是我自己相应算法的博文链接，希望能够帮助大家学习。&#xA;1.C4.5算法。C4.5算法与ID3算法一样，都是数学分类算法，C4.5算法是ID3算法的一个改进。ID3算法采用信息增益进行决策判断，而C4.5采用的是增益率。&#xA;详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/42395865&#xA;2.CART算法。CART算法的全称是分类回归树算法，他是一个二元分类，采用的是类似于熵的基尼指数作为分类决策，形成决策树后之后还要进行剪枝，我自己在实现整个算法的时候采用的是代价复杂度算法，&#xA;详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/42558235&#xA;3.KNN(K最近邻)算法。给定一些已经训练好的数据，输入一个新的测试数据点，计算包含于此测试数据点的最近的点的分类情况，哪个分类的类型占多数，则此测试点的分类与此相同，所以在这里,有的时候可以复制不同的分类点不同的权重。近的点的权重大点，远的点自然就小点。&#xA;详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/42613011&#xA;4.Naive Bayes(朴素贝叶斯)算法。朴素贝叶斯算法是贝叶斯算法里面一种比较简单的分类算法，用到了一个比较重要的贝叶斯定理，用一句简单的话概括就是条件概率的相互转换推导。&#xA;详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/42680161&#xA;5.SVM(支持向量机)算法。支持向量机算法是一种对线性和非线性数据进行分类的方法，非线性数据进行分类的时候可以通过核函数转为线性的情况再处理。其中的一个关键的步骤是搜索最大边缘超平面。&#xA;详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/42780439&#xA;6.EM(期望最大化)算法。期望最大化算法，可以拆分为2个算法，1个E-Step期望化步骤,和1个M-Step最大化步骤。他是一种算法框架，在每次计算结果之后，逼近统计模型参数的最大似然或最大后验估计。&#xA;详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/42921789&#xA;7.Apriori算法。Apriori算法是关联规则挖掘算法，通过连接和剪枝运算挖掘出频繁项集，然后根据频繁项集得到关联规则，关联规则的导出需要满足最小置信度的要求。&#xA;详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/43059211&#xA;8.FP-Tree(频繁模式树)算法。这个算法也有被称为FP-growth算法，这个算法克服了Apriori算法的产生过多侯选集的缺点，通过递归的产生频度模式树，然后对树进行挖掘，后面的过程与Apriori算法一致。&#xA;详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/43234309&#xA;9.PageRank(网页重要性/排名)算法。PageRank算法最早产生于Google,核心思想是通过网页的入链数作为一个网页好快的判定标准，如果1个网页内部包含了多个指向外部的链接，则PR值将会被均分，PageRank算法也会遭到Link Span攻击。&#xA;详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/43311943&#xA;10.HITS算法。HITS算法是另外一个链接算法，部分原理与PageRank算法是比较相似的，HITS算法引入了权威值和中心值的概念，HITS算法是受用户查询条件影响的，他一般用于小规模的数据链接分析，也更容易遭受到攻击。&#xA;详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/43311943&#xA;11.K-Means(K均值)算法。K-Means算法是聚类算法，k在在这里指的是分类的类型数，所以在开始设定的时候非常关键，算法的原理是首先假定k个分类点，然后根据欧式距离计算分类，然后去同分类的均值作为新的聚簇中心，循环操作直到收敛。&#xA;详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/43373159&#xA;12.BIRCH算法。BIRCH算法利用构建CF聚类特征树作为算法的核心，通过树的形式，BIRCH算法扫描数据库，在内存中建立一棵初始的CF-树，可以看做数据的多层压缩。&#xA;详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/43532111&#xA;13.AdaBoost算法。AdaBoost算法是一种提升算法，通过对数据的多次训练得到多个互补的分类器，然后组合多个分类器，构成一个更加准确的分类器。&#xA;详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/43635115&#xA;14.GSP算法。GSP算法是序列模式挖掘算法。GSP算法也是Apriori类算法，在算法的过程中也会进行连接和剪枝操作，不过在剪枝判断的时候还加上了一些时间上的约束等条件。&#xA;详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/43699083&#xA;15.PreFixSpan算法。PreFixSpan算法是另一个序列模式挖掘算法，在算法的过程中不会产生候选集，给定初始前缀模式，不断的通过后缀模式中的元素转到前缀模式中，而不断的递归挖掘下去。&#xA;详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/43766253&#xA;16.CBA(基于关联规则分类)算法。CBA算法是一种集成挖掘算法，因为他是建立在关联规则挖掘算法之上的，在已有的关联规则理论前提下，做分类判断，只是在算法的开始时对数据做处理，变成类似于事务的形式。&#xA;详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/43818787&#xA;17.RoughSets(粗糙集)算法。粗糙集理论是一个比较新颖的数据挖掘思想。这里使用的是用粗糙集进行属性约简的算法，通过上下近似集的判断删除无效的属性，进行规制的输出。&#xA;详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/43876001&#xA;18.gSpan算法。gSpan算法属于图挖掘算法领域。，主要用于频繁子图的挖掘，相较于其他的图算法，子图挖掘算法是他们的一个前提或基础算法。gSpan算法用到了DFS编码，和Edge五元组，最右路径子图扩展等概念，算法比较的抽象和复杂。&#xA;详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/43924273</description>
    </item>
    <item>
      <title>C&#43;&#43;图形边缘检测与区域提取</title>
      <link>https://anwangtanmi.github.io/posts/e30ea615f5660a78882e9dddf7108b85/</link>
      <pubDate>Sun, 21 Jul 2013 10:42:52 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/e30ea615f5660a78882e9dddf7108b85/</guid>
      <description>边缘检索与区域提取是我们的课程设计的一个课题。看到这个课题感到十分新颖，因为以前从未接触过这方面的知识。而且由于课程作业要求的语言是c++,所以选择了 c++ 的一个界面类函数库easyX 下载可见官网 http://www.easyx.cn/&#xA;我们将这个课题分为两部分，一是边缘检测，一是区域提取。&#xA;关于边缘检测：图像的边缘形成的原因是图像的灰度在某一区域的突然变化使得人眼才有了识别轮廓的功能。所以对于计算机识别边缘我们也可以用数学的方法定量的找出图像中灰度阶跃不连续或是线条不连续的地方，比如说一阶导数的极值点或二阶导数的零点的方法找到边缘。（图片摘自百度）。 [img]http://dl2.iteye.com/upload/attachment/0086/8785/e404332a-a703-3f11-a121-6dce248d25c6.png[/img]&#xA;当我们继续往下学时，越来越多的概念涌了出来，各种算子、幅度、差分、阈值、卷积运算。这对我这种数学渣渣的确是一种考验。其实我们没必要将边缘检索的数学推导都看懂。我们只要了解它的基本原理后，在运用它的结论就足以达到我们的目的。&#xA;我们总结了一下：什么Prewitt算子、Sobel算子，都是对灰度图片的一个变换，我们称这个变换为卷积模板变换，模板变换后，边缘就会被检索出来。首先让我们必须了解什么叫做卷积模板变换。这个博客说的很清楚，大家可以看看。&#xA;http://www.cnblogs.com/a-toad/archive/2008/10/24/1318921.html&#xA;所以我们根据这个运算规则，将它封装成一个方法，代码及注释如下&#xA;//模板操作，包括图像边缘的检测，图像的平滑都会用到这个函数&#xA;/*参数的意义&#xA;* img 指向图像的指针&#xA;* tempWidth tempHeight 模板的宽高&#xA;* tempX tempY 模板的中心的x y 坐标&#xA;* temp 指向模板数组的指针 tempCoef 模板的系数&#xA;* img2 为转化后的照片&#xA;*/&#xA;bool templateChange(IMAGE *img,int tempWidth,int tempHeight,int tempX,int tempY,float *temp,float tempCoef,IMAGE *img2){&#xA;long imgWidth = img-&amp;gt;getwidth();&#xA;long imgHeight = img-&amp;gt;getheight();&#xA;//得到原图的内容&#xA;DWORD *p = GetImageBuffer(img);&#xA;(*img2).Resize(imgWidth,imgHeight);&#xA;DWORD *p2 = GetImageBuffer(img2);&#xA;//用于暂存模板值&#xA;float result;&#xA;int endResult;</description>
    </item>
    <item>
      <title>中国移动互联网投资饕餮盛宴 无线增值业务居首</title>
      <link>https://anwangtanmi.github.io/posts/b895e4d579e89626923a36c3c62bb0f0/</link>
      <pubDate>Wed, 11 Jan 2012 09:19:09 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/b895e4d579e89626923a36c3c62bb0f0/</guid>
      <description>手机终端的快速普及、通信网络设施建设日臻完善、各类手机应用几何级数出现，成为中国移动互联网产业快速发展的基础及推动力量。当然，在产业自我推动的背后，产业资本与VC/PE的多向关注也是其发展的幕后推手。2011中国移动移动互联网投资创2005年来各年投资新高，这是一个积极的信号，当然也暗藏不安。&#xA;产业资本与VC/PE共舞，投资转向移动互联网&#xA;首先，从产业资本的表现来看，2010年以来，以盛大、联想等为代表的产业资金快速转向中国移动互联网行业。2010年2月，盛大将投资部门升级为盛大资本，未来将专注于投资移动互联网领域；2010年11月，联想成立天使基金投资移动互联网，首期投入1亿元；2010年11月，网龙联合IDG成立移动互联网基金；2010年12月，新浪成立转向资金投资移动互联网。种种事件背后标识行业领军企业对于移动互联网产业未来崛起的初步判断是一致的，对于移动互联网产业而言消息利好。&#xA;其次，从VC/PE投资表现情况来看，“春江水暖鸭先知”。2005-2011年上半年，中国移动互联网行业投资事件158起，其中已经披露投资金额的案例有128起，披露投资金额为11.19亿美元，平均单笔投资金额为874万美元。2005-2011年上半年投资情况来看，2011年上半年，中国移动互联网已经披露的投资案例数量为33起，其中，披露金额的投资案例数为25起，投资金额总额为3.20亿美元，平均单笔投资金额为1278万美元。毫无疑问，自2009年移动互联网市场投资回暖以来，2011年中国的移动互联网投资必然创历年新高。&#xA;2005年-2011年上半年，中国移动互联网各细分投资领域中，从披露的投资案例数情况来看，无线增值业务及其相关领域披露的投资案例数位居榜首，达31起，占总投资案例总数的19.62%。其次，手机游戏领域投资案例数也较多，达30起，占总投资案例总数的18.99%。此外，无线搜索、无线广告、手机客户端软件，手机支付等领域也是投资方关注的热点领域。清科研究中心分析认为，未来，手机游戏、无线广告、手机支付、手机视频等领域均值得资本市场关注。&#xA;中国移动互联网快速发展背后的三大推手&#xA;清科研究中心分析认为，中国移动互联网产业发展背后存在三大推手。&#xA;其一，开放共赢的移动互联网时代为中小企业参与者提供有益资源。这种开放主要表现为三点：一是，电信运营商转型时代，进一步向产业参与者敞开心扉，网络通路逐渐顺畅；二是，以腾讯、百度、UCWEB、盛大等为代表的企业相继开放应用入口；三是，操作系统底层开放。&#xA;其二，移动互联网用户使用成本逐渐降低，主要表现在智能手机终端价位降低、流量资费下调、获取应用的时间成本减少。&#xA;其三，移动互联网企业参与成本不断降低，从利用开放操作系统的应用开发，到利用开放平台的整合营销推广，再到交易成本的降低，尤其成为催生中小企业快速发展的沃土。&#xA;中国移动互联网多项应用“钱景”广阔，但用户基数并非完全代表变现能力&#xA;清科研究中心分析认为，手机游戏、移动支付&amp;amp;二维码、LBS、移动社交应用、移动电子商务、无线营销等细分领域均具有较强的投资价值。此外，与先进技术相关的应用及移动互联网化解决方案提供商也具有较好的投资价值。&#xA;不过，面对异常活跃的市场而言，我们仍需警惕数据背后的谎言与无奈。目前而言，中国移动互联网企业是否具有投资价值的主要评判标准就是用户基数情况，但是未来的某一天，也许我们会发现，用户基数并非代表企业的变现能力，尤其在移动互联网领域更甚。</description>
    </item>
  </channel>
</rss>
