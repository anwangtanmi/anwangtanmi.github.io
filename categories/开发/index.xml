<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>开发 on 暗网探秘</title>
    <link>https://anwangtanmi.github.io/categories/%E5%BC%80%E5%8F%91/</link>
    <description>Recent content in 开发 on 暗网探秘</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 12 Sep 2019 13:24:28 +0800</lastBuildDate>
    <atom:link href="https://anwangtanmi.github.io/categories/%E5%BC%80%E5%8F%91/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>读书</title>
      <link>https://anwangtanmi.github.io/posts/a25661f0fb2a8205e2ed2a41411a31b4/</link>
      <pubDate>Thu, 12 Sep 2019 13:24:28 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/a25661f0fb2a8205e2ed2a41411a31b4/</guid>
      <description>———————- 2019 ————– 10月&#xA;《半小时漫画经济学·生活常识篇》陈磊（微信读书）很常识，适合大学生看 《图解算法》巴尔加瓦（微信读书） 《暗网》杰米·巴特利特（微信读书）比较喜欢看一些特别案件，比如大丽花啥的，总会猜测这些特别的人怎么想的。暗网的创造开始是以极端方式监督统治者，但是如今充斥着暴力色情毒品还是清理清理比较好。国内网络的GFW一直是个热议的话题，希望能够正式历史，开放网络。 《月亮和六便士》威廉· 萨默赛特·毛姆（微信读书）不理解这种人，只想等老的时候和家人到澳洲住着，养着动植物，和外国美女聊聊天。书中的我也是一个诡异的人，貌似没有爱情却对他人的情感评头论足，受大家喜欢但感情非常冷淡，对男女有强大的偏见，很多主观的想法也许代表了当代大众思想吧。斯特里克兰是主要人物，他刚开始逃离第一人妻子家的时候，家里没有钱，自己没有钱，合伙生意没有钱，这样情景说他是单纯为了理想跑路很难说服读者，怕不是在经营失利后对生活失去了信念。如果说浑浑噩噩一生但做出影响无数后世的成就，我觉得倒不如平平淡淡却幸幸福福的过完一生，因为对于几十亿的星球，人人都追求前者，那又有谁去给他们做善后工作呢。正是由于人类的保守克制，人类文明才不至于遭受超级大灾难吧。布兰琪为什么报复德克！完全想不明白，女人为什么接受不了别人为她作出的牺牲，如果单纯偏执不喜欢欠别人人情的人我可以理解，但是女生不是这样的吧，单从自己的家庭来看，爸爸为女儿牺牲多少个人时间多少金钱，哪个女儿不是心安理得，所以很讨厌书中的我。书中的我肯定是对斯特里克兰的第一任太太有好感，但却这么冷漠，很可怕。我非常欣赏艺术家思想家因为他们都有自己偏执的观念以及足够的专业知识，起码对于自己及时间万物不会迷茫，虽然都掺带着强烈的个人观点。 09月&#xA;《红楼梦》(微信读书-大音社) 声音非常好听，首先读的是白话版很多原有的细节都丢掉了，很可惜。贾府的悲剧在我看来，是由于产业不够多样化、男人不负责任造成的。居安思危 08月&#xA;《Linux系统命令及Shell脚本实践指南》王军 (微信读书) 《幕后产品：打造突破式产品思维》 王诗沐 (微信读书) 产品经理需要保持创业心态、终身学习、善于联想、善于决断 《人间失格》太宰治 (微信读书) 这种极端的心理活动是我所不能理解的，或许可能是文字的篇幅问题又或是中文不能完全传达日语的问题。我比较推崇明示＋暗扣的，即既有正面说明主角性格的，也有细节刻画的，后者更容易给人认同感。我认为此书有些生硬，倾力推送这种消极的心情，细枝末节却又未描述或过于简短。期待19年小栗旬主演的电影版人间失格。 07月&#xA;《浪潮之巅》吴军 读史使人明智,读诗使人灵秀,数学使人周密,科学使人深刻,伦理学使人庄重,逻辑修辞使人善辩,凡有所学,皆成性格 –培根。 《信息简史》令我失望的一本书，本以为是信息的简史，反而是人物列传的堆叠。 《半小时漫画中国史+世界史》、《半小时漫画唐诗》陈磊 (微信读书) 这个系列确实很吸引人！ 06月&#xA;《统计学习方法》李航 还在看 机器学习实战 这本经典书，但是里面好多内容都是一笔带过，对于至少四年未碰数理化的我来说，痛苦至极，看不懂。。再回顾下这本书。理论知识非常丰富，实战不足，恰恰 机器学习实战 是理论不足，实战完美 《响应式web设计—html5和css3实战》相关地址 css3确实炒鸡强大，可写内容太多了，这本书也只能蜻蜓点水，但是足以体会css3的厉害。更多牛逼的例子可以在 http://codepen.io 上看，各种大牛?。 《如何阅读一本书》读了几页，实在读不下去 《概率论与数理统计(浙大第四版)》前面的全概率公式和贝叶斯公式在机器学习非常有用，后边学到的知识除了能做题实在不知道有什么用处。 《托马斯微积分》以前大学学的英文版，超级超级厚的两大本，内容和高数差不多，部分抽象的东西还需要再参悟参悟。 05月&#xA;《数学之美》好书，不解释。让你有超级冲动自己动手写一个分布式搜索引擎。 《机器学习实战》github 理论+代高质量码，感动?。部分代码值得优化和改正(有些写错)，建议实操时留个心。数据可以直接从https://github.com/apachecn/AiLearning这里的data目录获取到。 我自己学习写的代码放在 https://github.com/Goddywu/mechine-learning-in-action 里面有中/英文的书，每章的核心模型代码统一命名为xxx_core.py 建议搭配李航的《统计学习方法》来看，帮助理论模型的理论 相关书籍纯属分享，不做商业用途，如有侵权，请联系我进行删除。 知乎专栏:知识图谱-给AI装个大脑链接 文章浅显易懂，知识图谱入门可以看下 04月&#xA;《自然语言处理综论》 《黑客与画家》这本书主要描述的黑客的心态，他们是如何看待事物的，不同情景下的心理活动。编程语言就像一只铅笔，帮助你思考程序，而不是表达已经想好的程序，先动手做再不断优化。黑客的重要职责是设计软件而不是开发软件。白天工作和夜晚工作分隔开。保持独立思考，拥有自己的观点。管理企业只要做到两点：做出用户喜欢的产品、保证开支小于收入。好设计即简单的设计，永远不过时，解决问题的方向很明确并解决主要问题。好的设计为启发性设计，提供基础的工具、模块供使用者自由设计、使用，带有一定趣味性。好的设计是模仿大自然的设计。好的设计是不断再设计，培养自己的不满情绪。功能决定形式。 《Java RESTful Web Service实战》emmm…不好看 《2017-Scrum-Guide-Chinese-Simplified》还是需要根据实际的团队来修改，专门分一个人来做scrum master感觉成本还是偏大 《一线架构师实践指南》用词比较不太容易理解，应该有更好的书值得看。架构师要快速对需求有深入的了解&amp;amp;有大局观 03月&#xA;《人月神话》(03.14- 创建外科手术般的团队 《Spring Boot实战》(03.</description>
    </item>
    <item>
      <title>网站加密密码查看（或者破解）</title>
      <link>https://anwangtanmi.github.io/posts/6caf6180bda30b701d1bfc7044a3dde2/</link>
      <pubDate>Fri, 05 Jul 2019 11:23:31 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/6caf6180bda30b701d1bfc7044a3dde2/</guid>
      <description>从源代码中查看到的加密算法（MD5 单次加密）&#xA;![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705112059582.png&#xA;public static string MD5(this string str)&#xA;{&#xA;if (string.IsNullOrEmpty(str))&#xA;{&#xA;return string.Empty;&#xA;}&#xA;MD5CryptoServiceProvider md5 = new MD5CryptoServiceProvider();&#xA;byte[] arr = UTF8Encoding.Default.GetBytes(str);&#xA;byte[] bytes = md5.ComputeHash(arr);&#xA;str = BitConverter.ToString(bytes);&#xA;//str = str.Replace(“-“, “”);&#xA;return str;&#xA;}&#xA;从数据库查询的加密文件&#xA;E4-ED-0F-5C-D9-6B-E5-F5-4B-79-86-3B-71-C8-11-61&#xA;https://pmd5.com/（MD5在线解密网址）&#xA;查询到用户admin的密码 Qwert</description>
    </item>
    <item>
      <title>Labview文字识别-从训练到识别</title>
      <link>https://anwangtanmi.github.io/posts/824998074f9923f4a77039917eb9de7f/</link>
      <pubDate>Tue, 05 Mar 2019 22:29:47 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/824998074f9923f4a77039917eb9de7f/</guid>
      <description>一个简单的Labview文字识别例子，包含从训练到最终的识别，比较简单，主要是熟悉labview文字识别的整个流程。&#xA;首先需要安装视觉开发模块（NI Vision Development Module），可从官网下载，也可以直接运行安装程序勾选“图像采集和机器视觉选项”&#xA;安装完成后，不仅文字识别需要的库已经安装了，而且还安装了Vision Assistant了，接下来训练就需要用到它了。&#xA;（1）为了方便，我们就地取材，就以上一张图片为训练素材开始训练，打开Vision Assistant，导入上一张图片。&#xA;（2）选择New Character Set File&#xA;（3）框选需要训练的区域，以2014为例，按下图标记孙旭顺序完成训练，最后保存为为类型为abc的文件。&#xA;（4）参考Labview提供的范例，编写程序如图所示，输入需要辨识部分区域的坐标，运行程序。&#xA;（5）辨识结果如图所示。&#xA;注：指定识别区域越小，辨识准确度越高，图中2014的位置可以通过鼠标移到2014附近，观察下方坐标的变化得到区域的坐标。&#xA;这篇文章主要是熟悉labview做文字识别从训练到实现的整个流程，目的只是入门体验，省去了中间很多对图像的处理过程，新手一枚，不对的地方可以一起相互讨论学习。&#xA;源码地址：https://download.csdn.net/download/weixin_42266753/10998480&#xA;上传了源码，想设置0积分设置不了，确实还需要源码的留邮箱吧</description>
    </item>
    <item>
      <title>VTK图像处理颜色映射（三）</title>
      <link>https://anwangtanmi.github.io/posts/56f787c71f9f5ac546f7f92fba7ef5ba/</link>
      <pubDate>Sun, 03 Mar 2019 22:47:28 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/56f787c71f9f5ac546f7f92fba7ef5ba/</guid>
      <description>颜色映射的操作对象是数据集中的标量属性。它是一种常用的 标量算法。它会根据数据集中各个部分不同的标量值，对各个部分上不同的颜色。与此相关的另一种上色方法是控制演员的颜色属性，但这样整个图形只有单一的颜色，这显然没有颜色映射方法灵活。&#xA;下面会介绍一下:&#xA;ScalarBar的用法,可以根据自己的需要来设置scalarBar的属性。&#xA;ScalarBar和lookupTable结合使用方法&#xA;1 ScalarBar的用法 virtual int IsA（const char * type） 如果此类与指定类的类型（或子类）相同，则返回1。&#xA;void PrintSelf（ostream＆os，vtkIndent indent） print调用的方法打印有关对象的信息，包括超类。&#xA;int HasTranslucentPolygonalGeometry（） 这个道具有一些半透明的多边形几何形状吗？&#xA;void ReleaseGraphicsResources（vtkWindow *） 释放此actor所使用的所有图形资源。&#xA;virtual void GetScalarBarRect（int rect [4]，vtkViewport * viewport） 使用视口坐标中标量条的尺寸填充rect。&#xA;void ShallowCopy（vtkProp * prop） vtkProp的浅拷贝。&#xA;int RenderOpaqueGeometry（vtkViewport * viewport） 将标量栏和注释文本绘制到屏幕上。&#xA;int RenderTranslucentPolygonalGeometry（vtkViewport *） 将标量栏和注释文本绘制到屏幕上。…&#xA;int RenderOverlay（vtkViewport * viewport） 将标量栏和注释文本绘制到屏幕上&#xA;virtual void SetLookupTable（vtkScalarsToColors *） 设置/获取要使用的查找表。&#xA;virtual vtkScalarsToColors * GetLookupTable（） 设置/获取要使用的查找表。&#xA;virtual void SetUseOpacity（vtkTypeBool） 显示不透明度。&#xA;virtual GetUseOpacity（） 获取不透明度。</description>
    </item>
    <item>
      <title>Visual Studio Code（插件篇）：Visual Studio Code 必装的 10 个高效开发插件（扩展）</title>
      <link>https://anwangtanmi.github.io/posts/9b11bfd34a6226c2b9fe74819dab68cc/</link>
      <pubDate>Wed, 27 Feb 2019 00:51:45 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/9b11bfd34a6226c2b9fe74819dab68cc/</guid>
      <description>插件，亦成为 扩展。 使VSCode 如虎添翼。&#xA;本文介绍了目前前端开发最受欢迎的开发工具 VSCode 必装的 10 个开发插件，用于大大提高软件开发的效率。&#xA;相关文章推荐：Visual Studio Code（目录篇）：如何熟练使用 Visual Studio Code目录&#xA;目录&#xA;文件图标 vscode-icons&#xA;暗色主题 One Dark Pro&#xA;​代码美化 Beautify&#xA;代码检查工具 ESLint&#xA;必备调试工具 Debugger for Chrome&#xA;万能语言运行环境 Code Runner&#xA;特征&#xA;用法&#xA;快速注释 Document This&#xA;CSS 类名智能提示&#xA;特征&#xA;代码拼写检查 Code Spell Checker&#xA;备忘插件 TODO Highlight&#xA;总结&#xA;文件图标 vscode-icons 插件名称：vscode-icons 插件地址：https://marketplace.visualstudio.com/items?itemName=robertohuertasm.vscode-icons 首先为了我们在编码时有一个高效、易用的界面，我们需要对一些不明了的组件做一些美化。&#xA;vscode-icons 插件可以实现对各种文件类型的文件前的图标进行优化显示，这样我们在查看长长的文件列表的时候，可以直接通过文件的图标就可以快速知道文件的类型，而不是去看文件的后缀。&#xA;演示操作：&#xA;暗色主题 One Dark Pro 插件名称：One Dark Pro 插件地址：https://marketplace.visualstudio.com/items?itemName=zhuangtongfa.Material-theme 长时间的编码，暗色调的编码环境更不容易让视力疲劳，而且也可以让自己更加专注。&#xA;安装了 One Dark Pro 插件后，可以一键将 VSCode 编辑器的颜色调整成暗色系，编码起来更加舒适。</description>
    </item>
    <item>
      <title>[Xilinx FPGA] #1 Xilinx ISE 工程开发全流程笔记</title>
      <link>https://anwangtanmi.github.io/posts/d52d8fcdd15ab4c26722cac3f02b6323/</link>
      <pubDate>Mon, 07 Jan 2019 21:57:24 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/d52d8fcdd15ab4c26722cac3f02b6323/</guid>
      <description>开发工具：ISE 14.7&#xA;所用芯片(开发板)：黑金 LX45 (Xilinx Spartan-6 XC6LX45-2CSG324C)&#xA;注：参考 ISE-Help-Help Topics&#xA;Creating a Project 1.File-New Project-New Project Wizard&#xA;2.Create New Project — set the name, location, and project type&#xA;top-level source type: HDL (VHDL或Verilog),Schematic(原理图),EDIF(网表),NGC/NGO(网表)&#xA;-&amp;gt;Next&#xA;3.Project Settings — set the device and project properties&#xA;Evaluation Development Board: None Specified (指定官方开发板，手动设置即点 None Specified)&#xA;Product Category: All (指定产品类别，可过滤下发的设备选项)&#xA;Family: Spartan6 (Xilinx FPGA芯片所属的系列)&#xA;Device: XC6SLX45 (Xilinx FPGA芯片的型号)&#xA;Package: CSG324 (Xilinx FPGA芯片的封装型号)&#xA;Speed: -2 (指定速度等级)</description>
    </item>
    <item>
      <title>TCP通讯协议（上）同步传输</title>
      <link>https://anwangtanmi.github.io/posts/99dfb2171977e639ec72bc5c9847a388/</link>
      <pubDate>Mon, 24 Dec 2018 01:41:39 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/99dfb2171977e639ec72bc5c9847a388/</guid>
      <description>直接上例子，学习资料来自NET之美。服务端创建Listener对象，客户端创建Client对象，服务端首先开始对本地端口监听，客户端发送连接请求。当需要传输字符串时，两者均需要创建Stream对象，将想说的话，写在这片小红叶上，小红叶就飞到对方哪里了。&#xA;using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Threading; using System.Net; using System.Net.Sockets; using System.IO; namespace ConsoleTest { class Server { static void Main(string [] args) { Console.WriteLine(&#34;Server is running&#34;); const int buffersize =6; IPAddress ip = IPAddress.Parse(&#34;127.0.0.1&#34;); //IPAddress ip = Dns.GetHostEntry(Dns.GetHostName()).AddressList[0]; TcpListener listener = new TcpListener(ip,8500); listener.Start(); TcpClient remoteclient = listener.AcceptTcpClient();//同步方法，读取同意客户端多个信息 Console.WriteLine(&#34;Client{0} connects to---&amp;gt;Server{1}&#34;, remoteclient.Client.RemoteEndPoint, remoteclient.Client.LocalEndPoint); NetworkStream streamToClient = remoteclient.GetStream(); do { //read data try {//防止客户端阻塞在read()方法处，要把命令写在try catch中 byte[] buffer = new byte[buffersize]; MemoryStream ms = new MemoryStream(); int byteread; byteread = streamToClient.</description>
    </item>
    <item>
      <title>[Re]南邮ctf平台逆向题</title>
      <link>https://anwangtanmi.github.io/posts/960db5b0a7bfcdd1660661f6c90c25ce/</link>
      <pubDate>Mon, 03 Dec 2018 14:23:16 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/960db5b0a7bfcdd1660661f6c90c25ce/</guid>
      <description>继续学习，这次尝试做了一下南邮ctf平台的逆向题来练习&#xA;目录&#xA;第一题 HELLO,RE！&#xA;第二题 ReadAsm2&#xA;第三题 Py交易&#xA;第四题 WxyVM&#xA;第五题 maze&#xA;第六题 WxyVM 2&#xA;第一题 HELLO,RE！ 打开ida，找到main函数按F5，hexray反编译&#xA;就在眼前 flag{Welcome_To_RE_World!}&#xA;第二题 ReadAsm2 来锻炼汇编的阅读能力吧&#xA;main函数定义了一串字符串，应该就是加密的密文&#xA;通过func解密后输出结果，题目提示调用约定为System V AMD64 ABI&#xA;百度调用约定后，分析结果如下&#xA;总的来说，意思就是函数对输入的字符串每一个字符都与其&#xA;所在缓冲区的索引做异或运算，最后输出结果。&#xA;用py来写解密脚本吧&#xA;flag = [0x0,0x67,0x6e,0x62,0x63,0x7e,0x74,0x62,0x69,0x6d, 0x55, 0x6a, 0x7f, 0x60, 0x51, 0x66,0x63, 0x4e, 0x66, 0x7b, 0x71, 0x4a, 0x74, 0x76, 0x6b, 0x70, 0x79, 0x66 , 0x1c] flagstr = [] index = 0 for ech in flag: flag[index] = ech^index flagstr.append(chr(flag[index])) index = index+1 print &#39;&#39;.</description>
    </item>
    <item>
      <title>IDE – Codeblcoks 调试断点不停解决办法【绝对有效】</title>
      <link>https://anwangtanmi.github.io/posts/613bf894bf571578f64747071291edf5/</link>
      <pubDate>Sat, 01 Dec 2018 12:39:47 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/613bf894bf571578f64747071291edf5/</guid>
      <description>在用code::blocks调试程序的时候，设置了断点，但跑程序的时候一口气跑完，不会停在断点处，网上传的三种情况都试过了。&#xA;新建一个工程，然后再开始调试。CodeBlock无法对单独的一个CPP文件进行调试。 编译时没有打开-g标志，导致没有debug信息，所以无法调试。 解决办法：在debug模式：设置-&amp;gt;编译器和调试器设置-&amp;gt;全局编译器设置-&amp;gt;编译器设置——勾上产生调试符号-g project路径中包含汉字字符（貌似有空格和括号也不行，把空格都改成下划线把），导致断点不停。 解决办法：当然是把project路径变为无汉字即可。 三种情况都已经避免了， 可还是停不下来~&#xA;终极解决办法：Settings -&amp;gt; Compiler..&#xA;最后记得重启 Codeblcoks 再试试！如果还不行，请留言~</description>
    </item>
    <item>
      <title>【nuxt】服务器部署步骤</title>
      <link>https://anwangtanmi.github.io/posts/2e1bcb7ab9ac935244dc287dc30512d6/</link>
      <pubDate>Wed, 21 Nov 2018 13:51:27 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/2e1bcb7ab9ac935244dc287dc30512d6/</guid>
      <description>一. 安装nodejs&#xA;创建文件目录&#xA;mkdir -p /usr/local/software 进入文件目录&#xA;cd /usr/local/software 下载nodeJS&#xA;wget https://nodejs.org/dist/v8.9.1/node-v8.9.1-linux-x64.tar.gz 注意：&#xA;想要合适的版本node到 https://nodejs.org/dist/ 下自己查找 到时候复制链接 wget的时候还称自己的链接即可&#xA;解压NodeJs文件&#xA;tar -zxvf node-v8.9.1-linux-x64.tar.gz -C ../ 为nodejs更名&#xA;mv /usr/local/node-v8.9.1-linux-x64/ /usr/local/node8.9.1 # 软链接指向到node npm ln - s /usr/ local/node8. 9.1/bin/node /usr/ local/bin/node ln - s /usr/ local/node8. 9.1/bin/npm /usr/ local/bin/npm 查看软链是否成功&#xA;ls -al /usr/local/bin 软链接输出内容&#xA;[root@jsyfpre001 bin]# ls -al /usr/ local/bin total 3428 drwxr-xr-x 2 root root 4096 Feb 6 14: 09 .</description>
    </item>
    <item>
      <title>集成Eureka-server和Eureka-cliet以及遇到的各种问题总结</title>
      <link>https://anwangtanmi.github.io/posts/2d091ce2f9301f22735e54ba68a44fde/</link>
      <pubDate>Sun, 14 Oct 2018 19:37:24 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/2d091ce2f9301f22735e54ba68a44fde/</guid>
      <description>环境配置Eureka-server&#xA;application.properties配置：&#xA;server.port=8761 eureka.instance.hostname=localhost #代表不向注册中心注册自己 eureka.client.register-with-eureka=false #维护服务实例，不需要检索服务 eureka.client.fetch-registry=false eureka.client.serviceUrl.defaultZone=http://${eureka.instance.hostname}:${server.port}/eureka pom.xml文件&#xA;4.0.0 com.unistrong eureka-servser 0.0.1-SNAPSHOT jar eureka-servser Demo project for Spring Boot UTF-8 UTF-8 1.8 org.springframework.boot spring-boot-starter-parent 2.0.5.RELEASE org.springframework.cloud spring-cloud-starter-netflix-eureka-server org.springframework.boot spring-boot-starter-test test org.springframework.cloud spring-cloud-dependencies Finchley.RELEASE pom import org.springframework.boot spring-boot-maven-plugin spring-milestones Spring Milestones https://repo.spring.io/milestone false 类配置：&#xA;@SpringBootApplication @EnableEurekaServer public class EurekaServserApplication { public static void main(String[] args) { SpringApplication.run(EurekaServserApplication.class, args); } } Eureka-client:&#xA;application.properties配置：&#xA;spring.application.name=eureka-server eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka pom.xml&#xA;4.0.0 com.unistrong eureka-client 0.</description>
    </item>
    <item>
      <title>访问服务器缓慢的原因</title>
      <link>https://anwangtanmi.github.io/posts/281bf0e3bdc3958e6204887f323ccffe/</link>
      <pubDate>Wed, 19 Sep 2018 09:37:12 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/281bf0e3bdc3958e6204887f323ccffe/</guid>
      <description>序号 可能导致的原因 1 域名解析的问题 2 连接数据库的原因(搜索数据) 3 访问第三方网站影响速度(curl与file_get_contents访问第三方效率也是有差别的，curl更快些(个人测试所得)) 4 iis的设置问题 5 php的配置问题 6 mysql的配置问题（包括索引，占用cpu内存，mysql服务） 7 php升级导致的某些函数问题（某些函数被舍弃等） 8 waf防护墙防护导致某些代码或者操作不规范的问题 9 人数访问量导致服务器负载 10 session导致的错误（session泛滥，服务器临时文件过多等） 未完待续</description>
    </item>
    <item>
      <title>使用最新WebStorm开发及调试React Native项目</title>
      <link>https://anwangtanmi.github.io/posts/f0b1847a5e6feec6268c781d63422484/</link>
      <pubDate>Thu, 13 Sep 2018 15:48:08 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/f0b1847a5e6feec6268c781d63422484/</guid>
      <description>React Native允许您使用JavaScript和React为iOS和Android开发原生移动应用程序。它是由Facebook创建的，用于Instagram，Airbnb和现在的JetBrains自己的 YouTrack移动应用程序（顺便说一下，它是开源的）等知名应用程序。&#xA;使用WebStorm，您现在可以使用React Native开发移动应用程序，从而获得WebStorm好处的所有好处，例如React，Flow支持和内置调试器的代码完成。我们相信WebStorm可以成为使用React Native进行开发的强大工具！&#xA;让我们看看如何使用WebStorm中的React Native建立开发工作流程。&#xA;安装React Native CLI 确保您的计算机上安装了React Native CLI。要安装它，请在终端中运行以下命令：npm install -g react-native-cli。&#xA;您开始使用React Native时需要安装的工具列表取决于您的操作系统以及您要定位应用程序的移动平台。有关详细的安装说明，请查看React Native的入门指南。&#xA;创建一个新项目 现在，您可以直接从IDE欢迎屏幕创建一个新的React Native项目：单击Create new project，从左侧列表中选择React Native，输入项目名称并单击OK。&#xA;WebStorm将运行项目生成器并安装所有必需的依赖项。&#xA;当然，您也可以打开现有项目或从版本控制中选择一个。&#xA;我们建议您从项目中排除android和ios文件夹。为此，右键单击“项目”视图中的文件夹，然后选择“ 标记为已排除”。&#xA;运行和调试应用程序 现在我们在IDE中有我们的应用程序代码，让我们运行它。&#xA;UPD： 在WebStorm 2018.1中，我们 重新设计了React Native配置。它现在为您提供了更灵活的运行捆绑程序和构建应用程序本身。在下面的步骤中，我们使用WebStorm版本2018.2。&#xA;我们需要创建一个新的React Native运行/调试配置。在“Run”菜单中，选择“ Edit configurations…”，单击“ +”按钮，然后从列表中选择“ React Native ”。&#xA;要首次启动React Native应用程序，您需要做两件事：运行React Native bundler / packager，然后使用react-native run-ios或在模拟器或设备上构建和启动应用程序run-android command。只有在那之后，您才可以开始调试它。&#xA;选中 Build and Launch Application选项后，WebStorm将为您完成所有这些操作 – 您只需选择目标平台iOS或Android，确保React Native CLI软件包的路径正确并单击Ok。&#xA;如果您要在Android上运行您的应用，请不要忘记先启动Android虚拟设备 。您还可以在通过USB连接的真实Android设备上运行您的应用程序 （为此，请不要忘记 启用USB调试）。&#xA;现在让我们运行创建的配置 – 单击IDE工具栏中配置名称旁边的绿色调试图标。WebStorm将首先在新的React Native工具窗口中启动React Native打包程序，然后运行react-native run-ios或react-native run-android命令，具体取决于所选的目标平台。</description>
    </item>
    <item>
      <title>Codeblocks官方主题颜色更换及方法</title>
      <link>https://anwangtanmi.github.io/posts/1871effe922624b357d20f70eeb4f766/</link>
      <pubDate>Sun, 26 Aug 2018 23:16:34 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/1871effe922624b357d20f70eeb4f766/</guid>
      <description>一、用工具导入配置文件：&#xA;第一步：打开codeblock wiki网址：可以看到该网页中有十几个配色主题，可以预览一下。&#xA;可以看看，按照后面说的，把配置文件保存为： colour_themes.conf&#xA;第二步：下载 Colour_themes.conf 配置文件：https://download.csdn.net/download/xrinosvip/10628032&#xA;第三步：打开Code::Blocks安装目录下的cb_share_config.exe文件。&#xA;在 Soures Configuration file 选择上一步下载的Colour_Themes.conf，&#xA;在Destination Configuration file 选择C:\Users\Sandy（此处替换成你的用户名）\AppData\Roaming\CodeBlocks\default.conf （注意:……\AppData\Roaming\CodeBlocks\default.conf,是处于隐藏状态的，按照下图的方法即可显示 ）&#xA;1、运行 cb_share_config.exe文件&#xA;2、 点击打开cb_share_config.exe后， 主题全部勾选上，然后依次点3个按钮（是否备份无所谓，默认主题会保留下来的）&#xA;3、重启Codeblocks，Settings→Editor→Syntax highlighting→colour theme就成功啦 二、配置主题&#xA;1、打开codeblocks，setting（设置）-&amp;gt;editor（编辑）-&amp;gt;Syntax highlighting(语法高亮), 然后在右边的Colour theme（主题）里选择适合你的主题&#xA;下一步：&#xA;注：点击Background-&amp;gt;添加自定义颜色-&amp;gt;记住上图的 六 个数据，后面会用到！&#xA;2、设置光标&#xA;可能用新的界面风格由于颜色会看不到光标，setting（设置）-&amp;gt;editor（编辑）-&amp;gt;Margins and caret-&amp;gt;caret, 然后选择适合你颜色、大小的光标 4、配置字体&#xA;在Settings-&amp;gt;Editor-&amp;gt;左侧General settings，修改字体为Consolas，字号选择11号，同时把下面的show line numbers选中&#xA;Consolas字体的斜体简直不要太好看~~~&#xA;下一步：勾选展示 行号&#xA;4、设置左边行号区域部分&#xA;setting（设置）-&amp;gt;Environment-&amp;gt;Colurs, 然后就要用到第 1 步的六个数值！&#xA;按照下图修改：&#xA;设置完后的效果：&#xA;三、codeblocks的editor以外的背景暂时不知道怎么修改，可能要源码编译&#xA;codeblocks怎么改editor以外的背景&#xA;是时候发个codeblocks配色的设置帖子，图多慎入&#xA;Reference:&#xA;美化CodeBlocks的主题和字体&#xA;CodeBlocks 配色方案设置&#xA;如何把CodeBlocks写的程序的背景改变啊</description>
    </item>
    <item>
      <title>图像预处理：去雾算法总结</title>
      <link>https://anwangtanmi.github.io/posts/9a53c51c4551d735b0d725467860dff5/</link>
      <pubDate>Fri, 10 Aug 2018 10:27:01 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/9a53c51c4551d735b0d725467860dff5/</guid>
      <description>图像预处理：图像去雾算法总结 去雾算法总结&#xA;1、暗通道去雾算法 何凯明暗通道去雾算法&#xA;matlab源码实现像素逐个运行，比较耗时，可查找C++实现的代码。&#xA;matlab源码和C++源码底部有下载链接&#xA;1.1 单张图片去雾处理 % 功能：去雾算法单张图片测试 clc clear all I = imread(&#39;F:\\去雾算法\\2.jpg&#39;); [ J,tmap,tmap_ref ] = darkChannel( I,15,0.95); % J 为处理后输出的图像 1.2 图像批量去雾处理 % 功能：读取指定文件夹下的所有图片，改变尺寸后去雾再保存。 clc; clear; % PathName = &#39;.\train\&#39;; %指定当前程序所在路径下的文件夹 PathName = &#39;F:\input_img\&#39;; %指定其他路径下的文件夹 Num = dir([PathName,&#39;*.jpg&#39;]); %关联文件夹下某种类型的文件 % if ~exist(&#39;newData&#39;,&#39;dir&#39;) %若当前工作路径下不存在，则创建新文件夹newData % mkdir(&#39;newData&#39;) % end % paths=[pwd,&#39;\newData&#39;]; %在当前路径下生成新的存储路径 fprintf(&#39;处理ing，请稍等...\n&#39;); for i=1:length(Num) FileName = Num(i).name; trainImg = imread([PathName FileName]); newImg = imresize(trainImg,[416 416]); %统一尺寸 % newImg = rgb2gray(newImg);%灰度化 [ J,tmap,tmap_ref ] = darkChannel( newImg,15,0.</description>
    </item>
    <item>
      <title>element-ui框架的el-dialog弹出框被遮罩层挡住了</title>
      <link>https://anwangtanmi.github.io/posts/621f06a6b3f725cdeec21a83defe3489/</link>
      <pubDate>Mon, 02 Jul 2018 19:24:30 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/621f06a6b3f725cdeec21a83defe3489/</guid>
      <description>如图：&#xA;解决办法&#xA;在el-dialog标签里添加 :modal-append-to-body=’false’&#xA;实现效果：&#xA;问题解析 先来看看element-ui官网提供的属性说明文档&#xA;文档解释：翻译成大白话就是，若el-dialog弹出框设置了modal-append-to-body=’true’（默认）属性，它的遮罩层就会被插入到body标签下（即与组件所在的最外层div同一层级），知道这个原理就好办了。&#xA;问题分析：经过分析源代码可得，el-dialog的显示层和遮罩层都设置了position:fixed，当然显示层的z-index肯定要比遮罩层的大，才能正常的显示弹出框。问题就出在此处，若el-dialog的父级也设置了position:fixed，并且其z-index比弹出框的遮罩层的小（遮罩层处于更高一层），那么弹出框的内容就会被遮罩层所遮挡住了。&#xA;经过分析出问题的代码可得出，el-dialog的父级元素确实设置了position:fixed，并且其z-index比弹出框的遮罩层的小，所以就会出现遮罩层把内容挡住的问题。&#xA;解决方案&#xA;1、给el-dialog设置modal-append-to-body=“false”，使遮罩层插入至 Dialog 的父元素上。（推荐）&#xA;2、给position:fixed的父元素设置一个z-index，并且要比遮盖层的大。&#xA;3、el-dialog父元素不使用fixed定位。&#xA;为了验证这个问题，我特地写了个demo，如下图：&#xA;图一：modal-append-to-body=“true”&#xA;图二：modal-append-to-body=“false”&#xA;(完)</description>
    </item>
    <item>
      <title>php判断两张图片是否相同以及相似度</title>
      <link>https://anwangtanmi.github.io/posts/81d79fd9f0a388426f8c225bc7c1bd75/</link>
      <pubDate>Thu, 31 May 2018 10:35:14 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/81d79fd9f0a388426f8c225bc7c1bd75/</guid>
      <description>php有强大的拓展类库： 判断文件是否完全相同可以使用内置的函数；&#xA;md5() - 计算字符串的 MD5 散列值 sha1_file() - 计算文件的 sha1 散列值 也可以使用第三方拓展包，这个速度会快很多，是将图片先进行压缩，再进行比较，还可以得出图片的相似度，很是强大。 https://packagist.org/packages/jenssegers/imagehash&#xA;验证码识别，破解： https://www.jb51.net/article/95854.htm</description>
    </item>
    <item>
      <title>php图片合成和图片处理（imagick）</title>
      <link>https://anwangtanmi.github.io/posts/89290cd2ccd3ea4e60a6d7d7574c0152/</link>
      <pubDate>Fri, 25 May 2018 15:53:11 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/89290cd2ccd3ea4e60a6d7d7574c0152/</guid>
      <description>在我们印象中php一些简单的图片处理可以用gd库来完成，但是真正快速高效的、灵活复杂的图片处理，gd库是不满足的，所以我们一般使用linux上的 ImageMagick 或者 php的imagick扩展。&#xA;我们来看看两者的区别：&#xA;（1） imagick是一个PHP的扩展，用ImageMagick提供的API来进行图片的创建与修改，不过这些操作已经包装到扩展imagick中去了，最终调用的是ImageMagick提供的API.&#xA;（2） ImageMagick则是一套软件系列，主要用于图片的创建、编辑以及转换等，详细的解释见ImageMagick的官方网站http://www.imagemagick.org/，ImageMagick比GD的性能要高很多，如果是在处理大量的图片时更加能体现ImageMagick的性能。&#xA;1. 下载安装ImageMagick Linux代码 wget ftp://mirror.aarnet.edu.au/pub/imagemagick/ImageMagick-6.6.8-10.tar.gz tar -xzvf ImageMagick-6.6.8-10.tar.gz ./configure –prefix=/usr/local/imagemagick make make install 2. 下载安装Imagick 注意：安装该扩展不要求安装ImageMagick&#xA;从http://pecl.php.net/package/imagick找到imagick的最新的版本&#xA;Linux代码 wget http://pecl.php.net/get/imagick-3.1.0RC1.tgz tar -xzvf imagick-3.1.0RC1 phpize ./configure –with-php-config=/usr/local/php/bin/php-config –with-imagick=/usr/local/imagemagick make make install linux imagemagick的一些常用命令 可参考 w3c文档 地址：https://www.w3cschool.cn/imagemagick_use/imagemagick_use-bcm32819.html&#xA;php imagick的常用方法 可参考 地址：http://www.jb51.net/article/60161.htm</description>
    </item>
    <item>
      <title>HTML – 颜色</title>
      <link>https://anwangtanmi.github.io/posts/d55e06c6207435117bd5aabe45c914a6/</link>
      <pubDate>Sat, 14 Apr 2018 10:17:20 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/d55e06c6207435117bd5aabe45c914a6/</guid>
      <description>HTML颜色的表示 HTML 颜色由红色、绿色、蓝色混合而成。&#xA;HTML颜色可以通过颜色值或者颜色RGB或者颜色名来引用。&#xA;sublime text3自带取色器可以用，右键 &amp;gt; insert color with color picker就可以从color picker取色了。&#xA;颜色值 HTML 颜色由一个十六进制符号来定义，这个符号由红色、绿色和蓝色的值组成（RGB）。每种颜色的最小值是0（十六进制：#00）。最大值是255（十六进制：#FF）。&#xA;十六进制值的写法为#号后跟三个或六个十六进制字符。三位数表示法为：#RGB，转换为6位数表示为：#RRGGBB。&#xA;如&#xA;颜色 3位十六进制颜色值 6位十六进制颜色值 RGB #000 #000000 rgb(0,0,0) 这个表格给出了由三种颜色混合而成的具体效果：&#xA;颜色(Color) 颜色十六进制(Color HEX) 颜色RGB(Color RGB) #000000 rgb(0,0,0) #FF0000 rgb(255,0,0) #00FF00 rgb(0,255,0) #0000FF rgb(0,0,255) #FFFF00 rgb(255,255,0) #00FFFF rgb(0,255,255) #FF00FF rgb(255,0,255) #C0C0C0 rgb(192,192,192) #FFFFFF rgb(255,255,255) 颜色RGB：透明度 相对于使用rgb(255,255,0)，使用rgba(255,255,0,0.5)可以实现设置颜色透明度的功能，这里的0.5表示透明度，范围0~1。 style=&#34;background-color:rgba(255,255,0,0.25)&#34;&amp;gt; 通过 rbg 值设置背景颜色&#xA;颜色名 141个颜色名称是在HTML和CSS颜色规范定义的（17标准颜色，再加124）。下表列出了所有颜色的值，包括十六进制值。目前所有浏览器都支持以下颜色名。&#xA;: 17标准颜色：黑色，蓝色，水，紫红色，灰色，绿色，石灰，栗色，海军，橄榄，橙，紫，红，白，银，蓝绿色，黄色。点击其中一个颜色名称（或一个十六进制值）就可以查看与不同文字颜色搭配的背景颜色。&#xA;某小皮&#xA;不同颜色的展示&#xA;1600万种不同颜色 三种颜色 红，绿，蓝的组合从0到255，一共有1600万种不同颜色(256 x 256 x 256)。&#xA;在下面的颜色表中你会看到不同的结果，从0到255的红色，同时设置绿色和蓝色的值为0,随着红色的值变化，不同的值都显示了不同的颜色。</description>
    </item>
    <item>
      <title>安卓PHPapi接口实现用户登陆功能，注册同理</title>
      <link>https://anwangtanmi.github.io/posts/5da4079e604a3122b742724312411dd7/</link>
      <pubDate>Mon, 02 Apr 2018 11:45:14 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/5da4079e604a3122b742724312411dd7/</guid>
      <description>/** * Created by PhpStorm. * User: Adaministrator * Date: 2018/3/29 * Time: 15:01 */// 定义接口返回值 $servername = &#34;182.254.147.87&#34;; $username = &#34;数据库账号&#34;; $password = &#34;数据库密码&#34;; $dbname = &#34;数据库名称&#34;; $success = &#39;&#39;; $output = array(); $name = @$_GET[&#39;username&#39;];//根据需要自行设置 $psw=@$_GET[&#39;password&#39;]; $con = mysqli_connect($servername,$username,$password,$dbname); if (!$con) { die(&#39;Could not connect: &#39; .mysqli_error($con)); } mysqli_select_db( $con,$dbname); $username_table = lib_replace_end_tag($_GET[&#39;username&#39;]); $sql=&#34;SELECT firstname , lastname FROM myguests where firstname=&#39;$username_table&#39; AND lastname=&#39;$psw&#39;&#34;; $result =mysqli_query($con,$sql); if(!$result) { die(&#34;</description>
    </item>
    <item>
      <title>Unity UGUI Slider颜色改变（过渡）</title>
      <link>https://anwangtanmi.github.io/posts/5645384da9b244066d61ce457b094b43/</link>
      <pubDate>Wed, 28 Mar 2018 16:05:32 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/5645384da9b244066d61ce457b094b43/</guid>
      <description>using UnityEngine; using System.Collections; using UnityEngine.UI; public class SliderColor : MonoBehaviour { public Color[] colors = new Color[] { Color.red, Color.yellow, Color.green }; Slider slider; void Start() { slider = GetComponent(); slider.fillRect.transform.GetComponent().color = Color.green; } void Update() { float val = slider.value; val *= (colors.Length - 1); int startIndex = Mathf.FloorToInt(val); Color color = colors[0]; if (startIndex &amp;gt;= 0) { if (startIndex + 1 &amp;lt; colors.Length) { float factor = (val - startIndex); color = Color.</description>
    </item>
    <item>
      <title>我眼中的IL, JIT,CTS, CLS,CLR</title>
      <link>https://anwangtanmi.github.io/posts/6fff8eebe7bb61181bd2f3dce4fa42fb/</link>
      <pubDate>Sun, 25 Mar 2018 19:22:35 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/6fff8eebe7bb61181bd2f3dce4fa42fb/</guid>
      <description>一 概念及作用 1. IL代码：&#xA;1）概念：.NET框架中的中间语言（Intermediate Language）的缩写，IL还有另外的2种叫法：CIL，Common Intermediate Language；MSIL， MicrosoftIntermediate Language。&#xA;作用：使用.NET框架提供的编译器（例如VS）可以直接将源程序（例如C++,VB.NET，C#）编译为.exe或.dll文件，但此时编译出来的程序代码并不是CPU能直接执行的机器代码，而是一种中间语言IL（Intermediate Language）的代码。因此还需要通过JIT编译器进行二次编译，将IL代码转化成机器代码。&#xA;2）优点：使用中间语言的优点有两点，一是可以实现平台无关性，即与特定CPU无关，意思是对平台没有依赖性，不指定特定的CPU，可以跨平台跨系统，具有一定通用性；二是只要把.NET框架某种语言编译成IL代码，就实现.NET框架中语言之间的交互操作。&#xA;3）IL与程序集的关系：IL代码是程序集的核心部分。&#xA;4）.NET程序集的构成&#xA;从结构上看，一个.NET程序集（*.dll或者*.exe）包含以下几个部分：&#xA;Windows文件首部&#xA;Windows文件首部使程序集被Windows系列操作系统加载和操作。这些首部信息标识了应用程序将以什么类型（是基于控制台、基于图形用户界面还是*.dll代码库）驻留在Windows操作系统中。&#xA;CLR文件首部&#xA;为了驻留于CLR中，所有的.NET文件都必须含有CLR首部数据块，简单地讲，CLR文件首部定义了多个标记，它们使得运行时环境可以了解到托管文件的布局。&#xA;IL代码&#xA;IL代码是程序集的核心部分，是独立于平台和CPU的中间语言。在运行时，程序集内部的IL代码只在绝对必需的情况下才被（实时的JIT编译器）编译成特定平台和CPU的指令。”绝对必需”通常是指一段IL指令（例如一个方法实现）被CLR引用时。在这种机制下，.NET程序集可以在多种不同的架构、设备和操作系统下运行。&#xA;类型元数据&#xA;类型元数据完整地描述了程序集内含类型和引用外部类型的格式。.NET运行时环境利用元数据在内存的二进制布局类型中解析类型（以及类型的成员）的位置，使远程方法调用更便利。&#xA;程序集清单&#xA;清单（manifest,也称程序集元数据，是对程序集本身的自描述）详细记录了程序集中的每一个模块、构建程序集的版本以及该程序集引用的所有外部程序集。它提供有关程序集的类型、版本、区域性和安全要求等信息。&#xA;可选的嵌入资源&#xA;.NET程序集还可以包含一些嵌入资源，如应用程序图标、图像文件、声音片段或者字符串表。事实上，.NET平台支持卫星程序集（satellite assembly），这些程序集只包含本地化资源。在构建国际化软件系统的时候，我们可能想基于特定区域（英语、德语等）来对资源进行分类打包，这时候附属程序集就显得非常有用。&#xA;5）程序集加载流程：&#xA;IL 代码与资源（例如位图和字符串）一起作为一种称为程序集的可执行文件存储在磁盘上，通常具有的扩展名为 .exe 或.dll。 执行 C# 程序时，程序集将加载到 CLR 中，这可能会根据清单中的信息执行不同的操作。然后，如果符合安全要求，CLR 就会执行实时 (JIT) 编译以将 IL 代码转换为本机机器指令。&#xA;2. JIT编译器： 概念：JIT编译器，英文写作Just-In-Time Compiler，中文意思是即时编译器。&#xA;作用：JIT编译器能够将MSIL代码进行二次编译后成为各种不同的机器代码，以适应对应的系统和平台，最终使得程序在目标系统中得到顺利地运行。（帮助IL实现跨系统）&#xA;3. CTS: 公共类型系统(Common Type System)&#xA;CTS（通用类型系统）是一个正式的规范，它规定了类型必须如何定义才能被CLR承载。通过正式的规范来描述类型的定义和行为，所有.net框架下的目标语言定义的语言都要与CTS的类型进行映射对应，这样才能保证各语言之间的互操作性。&#xA;4.CLS：公共语言规范(Common Language Specification)&#xA;CLS限制了由各种语言不同特性而引发的互操作性问题,CLS制定了一种以.NET平台为目标的语言所必须支持的最小特征，&#xA;以及该语言与其他.NET语言之间实现互操作性所需要的完备特征。即.NET框架下的目标语言如果要实现互操作性，至少需要对CLS规范进行完全支持。&#xA;由图总结： 1） CTS定义类型，CLS定义规范，在共同定义的环境下实现以.Net平台为目标的各语言之间的互操作性。&#xA;2）CLS是各语言间实现互操作性的最低规范。但是内部使用语言时可以只满足CTS不满足CLS。 3） CRL严格按照CTS进行实现。&#xA;5.CLR：公共语言运行时（Common Language RunTime）</description>
    </item>
    <item>
      <title>序</title>
      <link>https://anwangtanmi.github.io/posts/06f2b086c7650f5c09b2faa92ab2b87a/</link>
      <pubDate>Thu, 22 Feb 2018 00:00:18 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/06f2b086c7650f5c09b2faa92ab2b87a/</guid>
      <description>晚上睡不着觉又a不动题，干脆看看书……&#xA;学校课上讲的C++刚到面向对象就结束了，简直比吃鸡剩两个人时天命圈刷到自己脚底下突然屏幕一暗中间出现一个&#xA;图标上面写着一行”网络延迟检测”还要难受。没得办法，自己看看书做做笔记学一学了。</description>
    </item>
    <item>
      <title>图像增强:多尺度的图像细节提升(multi-scale detail boosting)实现方法</title>
      <link>https://anwangtanmi.github.io/posts/4719a3d36e83dd0ac5be01ea9aefdbc0/</link>
      <pubDate>Tue, 23 Jan 2018 11:49:42 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/4719a3d36e83dd0ac5be01ea9aefdbc0/</guid>
      <description>图像增强:多尺度的图像细节提升(multi-scale detail boosting)实现方法 看到一篇博客介绍基于多尺度的图像的细节提升算法，其参考论文《Dark image enhancement based onpairwise target contrast and multi-scale detail boosting》，下图是该论文的核心算法过程。然后自己在Matlab和OpenCV实现了该算法，最终实现的效果还是不错的，可以增强图像的细节部分。 论文的核心算法过程：&#xA;论文的核心思想类似于Retinex，使用了三个尺度的高斯模糊，再和原图做减法，获得不同程度的细节信息，然后通过一定的组合方式把这些细节信息融合到原图中，从而得到加强原图信息的能力：请参考这一篇博客介绍：http://www.cnblogs.com/Imageshop/p/7895008.html，该博客给出了SSE的实现过程。 算法实现很容易，下面，我给出本人的OpenCV和Matlab实现方法： OpenCV实现方法： #include #include #include using namespace std; using namespace cv; cv::Mat multiScaleSharpen(cv::Mat Src, int Radius) { int rows = Src.rows; int cols = Src.cols; int cha = Src.channels(); cv::Mat B1, B2, B3; GaussianBlur(Src, B1, Size(Radius, Radius), 1.0, 1.0);//高斯模糊 GaussianBlur(Src, B2, Size(Radius*2-1, Radius*2-1), 2.0, 2.0); GaussianBlur(Src, B3, Size(Radius*4-1, Radius*4-1), 4.0, 4.0); double w1 = 0.</description>
    </item>
    <item>
      <title>《树莓派开发笔记 – 第1部分 基础篇》第6章 树莓派摄像头操作</title>
      <link>https://anwangtanmi.github.io/posts/20e42050126656d6d393482e07f3ac37/</link>
      <pubDate>Mon, 20 Nov 2017 11:20:25 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/20e42050126656d6d393482e07f3ac37/</guid>
      <description>6.1树莓派基本操作 目前提供了三个应用程序，分别为：raspistill、raspivid、raspistillyuv。其中 raspistill 和 raspistillyuv 非常相似，并且都是用于捕捉图像，而 raspivid 用于捕捉视频。&#xA;所有应用程序均基于命令行方式运行，通过 OpenMAX 的 mmal API 进行编写。OpenMAX 的 mmal API 提供了更易使用的系统组件。注意，mmal 是一个由 Broadcom 为 Videocore 4 系统定制的 API。&#xA;应用程序使用了四个 OpenMAX（mmal）组件：camera（摄像）、preview（预览）、encoder（编码）、null_sink。所有应用程序均使用了摄像组件，raspistill 使用了图像编码组件，raspivid 使用了视频编码组件，raspistillyuv 没有使用编码组件，而是直接将 YUV 或 RGB 从摄像组件输出到文件。&#xA;预览显示为可选参数，但是可以用于全屏或输出到指定的显示器显示区域进行显示。如果预览被禁用，那么 null_silk 组件将会对预览帧进行“吸收”。这是由于尽管不需要摄像头生成供显示所用的的预览帧，但是仍需要使用它们进行曝光计算和白平衡设置的缘故。&#xA;此外，还可以省略文件名参数，这样既可以直接预览显示而不写入文件，或者直接输出到标准输出设备上。命令行帮助可以通过直接输入应用程序名称获得。&#xA;6.1.1安装摄像头硬件 警告：摄像头对静电非常敏感。如果您在安装摄像头电路板时没有防静电手环，可以尝试触摸一下水龙头、金属水槽或其它类似的东西即可。&#xA;摄像头电路板与 Raspberry Pi 通过一条 15 芯的排线进行连接。仅有两个连接座需要连接，排线需要安装到摄像头电路板和 Raspberry Pi 上。您需要正确安装，否则摄像头无法工作。对于摄像头电路板，排线末端的蓝色标记应该背对着电路板。而 Raspberry Pi 部分，蓝色标记应该正对着网络接口方向。&#xA;尽管两部分连接座不尽相同，但它们的工作方式很相似。对于 Raspberry Pi，拉起连接座两端的卡扣。它应该很容易拉起，并能够轻微活动。把排线完全插入到连接座中，并保证竖直，然后轻轻按下两端的卡扣。摄像头电路板方面，也需要您将卡扣向电路板相反方向拉开，然后轻轻插入排线，最后将卡扣推回。摄像头电路板的连接座与 Pi 上的区别就在这里。&#xA;6.1.2安装摄像头软件 执行下文介绍的命令行进行下载并安装最新的内核，GPU 固件及应用程序。您需要连接到互联网才可以实现以下操作。&#xA;$sudo apt-get update $sudo apt-get upgrade 接下来，您首先需要在 Raspberry Pi 的 raspi-config 程序中启用摄像头的支持。</description>
    </item>
    <item>
      <title>The nice WEB for DL</title>
      <link>https://anwangtanmi.github.io/posts/9a24ee79ef3b14c43bfa2766aa851672/</link>
      <pubDate>Mon, 09 Oct 2017 16:48:45 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/9a24ee79ef3b14c43bfa2766aa851672/</guid>
      <description>Hello!This is my first blog for DL,now I will shape some great Webs which may better and efficiently learn DL. 1 NOTE paper and code for tracking:&#xA;http://blog.csdn.net/cyh_24/article/details/51592156&#xA;2 Deep Learning papers reading roadmap for anyone who are eager to learn this amazing tech:&#xA;https://github.com/songrotek/Deep-Learning-Papers-Reading-Roadmap&#xA;3 CS231n course learn:&#xA;https://zhuanlan.zhihu.com/p/21930884&#xA;to be continued…</description>
    </item>
    <item>
      <title>Socket TCP协议 实时通信的粘包处理 Java与C&#43;&#43;实现</title>
      <link>https://anwangtanmi.github.io/posts/ba2bd66cfe1bcd48bac243612f20c952/</link>
      <pubDate>Sat, 12 Aug 2017 09:46:45 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/ba2bd66cfe1bcd48bac243612f20c952/</guid>
      <description>原理： （经典）tcp粘包分析&#xA;场景： 此项目是处理实时监测数据，一旦tcp socket建立连接，会不间断实时发送数据，峰值输数据量在3M/秒，这样的数据量必然会造成数据粘包。&#xA;目的： TCP连接面向流，读取网络的一包数据不一定正好是协议里定义的完整的一包，有可能是多包，有可能是半包，也有可能是一包半，现在要将每次读取的数据进行分包，也就是粘包处理，提取出完整的一包数据供上层使用，上层需要将完整的一包数据里的数据根据协议定义的格式提取出来。&#xA;实现： 将收到的数据copy到缓存区，在缓存区里循环从起始位按照协议找出完整的一包数据提取出来。 关键点在于根据协议找出完整一包数据的长度。&#xA;从网络读取数据后拷贝到缓存区 判断：缓存区里数据占位，长度小于某个值n，return再次读取网络数据。这个值n长度的数据内要能解析出单个完整包的长度，以便后续处理 循环：如果缓存区长度大于解析出来的完整一包的长度 执行： 取出完整一包数据后，然后剔除这包，将缓存区剩余数据放置起始位 循环里再次判断： 长度小于某个值n，return再次读取网络数据。 这个值n长度的数据内要能解析出单个完整包的长度，以便后续处理 如果协议定义了帧头，可以在取包的长度之前校验帧头，确保数据正确。&#xA;这里说明定义缓冲区buffer的长度大小：必须要大于可能收到的最大数据包的长度加上read读取一次网络最大数据长度 原因是缓冲区里可能剩下不到一包数据，下一次读取网络数据后要将数据copy至缓冲区，如果超过缓冲区大小就无法进行处理。可在copy时加一层判断，如果超过缓存区，就直接返回，断开连接。代表这种数据包不能进行处理。如果缓存区设计合理，不会出现此种情况。read读取一次网络最大数据长度是在read到的buffer定义的长度。缓冲区的buffer不要设置过大，占用太多内存。 数据源说明：第一位固定#。第二位表示之后有几位代表了之后的数据的长度，比如第一条数据的第二位4，代表之后的四位3350是从0：开始共有3350个字节长度的数据。之后的数据跟业务相关。&#xA;主要代码： Java实现： 不可用于生产环境，理解思想后根据业务数据处理粘包&#xA;private static int MAXDATALEN = 500000; //处理数据缓冲池的长度 private static int RECEIVEDATALEN = 200000;//读取网络数据包最大长度 private int SiglePackageLen = 0;//提取出包的长度 private int SequenceLen = 0;//当前缓冲区内数据长度 private byte BuffSequencePackage[] = new byte[MAXDATALEN];//数据缓冲池 public void readData() { //读取网络数据长度 int RecvLen; //缓存区 byte ReceiveData[] = new byte[RECEIVEDATALEN]; try { while (AdapterManager.</description>
    </item>
    <item>
      <title>windows 环境下,为lua添加luasocket库</title>
      <link>https://anwangtanmi.github.io/posts/2ece124ea183c9987959f00332d44053/</link>
      <pubDate>Thu, 27 Jul 2017 17:14:00 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/2ece124ea183c9987959f00332d44053/</guid>
      <description> 1.首先下载luasocket库 可以直接下载编译好的库，也可以去github上下载源码后自己自己编译： 编译好的库下载地址：&#xA;http://files.luaforge.net/releases/luasocket/luasocket 源码下载地址：&#xA;https://github.com/diegonehab/luasocket 到官网上看了一下luasocket 的install方案，有几点还是值得注意的，luasocket库包含了以下文件，如果下载的库里面的文件少了，可能造成某些功能无法使用： ‘’ 然后贴一张这边编译好的库的层次结构： 主要这三个文件夹，其他的可以不要，再贴一下这几个文件夹内部的层级结构： 这样的话几个目录的层级结构就很清楚了 还有一点需要注意的就是这里面的文件是依赖于lua5.1.x的，如果lua的版本与此不匹配也可能出现问题（我试了下lua5.3不行），这一切准备完毕后就可以继续下一步了。 2.将luasocket库嵌入lua 我们先来认识一下里面的一些文件，编译好的库里面包含两个dll文件，其余的都是lua文件，如果我们了解lua中的require的机制，那么下面的内容应该很easy了，lua中的require加载一个模块时，会先从它的全局环境中去拿两个变量的值，一个是LUA_PATH,另一个是LUAC_PATH，（注意大小写），如果第一个值不为空，那么lua会以其值提供的一个路径模式去匹配相应路径下的文件，如果第二个值不为空，lua会以同样的方式去相应路径下去加载c的库，（比如我们下载的文件中的dll），我们可以通过系统的环境变量来设置上述两个变量的值，这样的话，只要我们把这两个环境变量的值设置成我们下载的库中的相应路径，那就ok了。下面来看图: 这里说明一下，我是把库里面的文件放到了我lua的解释器文件夹下（D：Lua5.1），你们也可以放到任意地方，再看我的环境变量（LUA_CPATH）的值：我的luasocket库的上一级目录路径（我的在D:\Lua5.1）+?.dll,这里的问号会被require的参数替换掉，再看我的环境变量（LUA_PATH）的值：我的luasocket库的上一级目录路径（我的在D:\Lua5.1）+lua\?.lua,这里的lua就是上面图片中的那个lua的文件夹，问号会被require的参数替换掉，因为那个lua的文件夹里面还有一个socket的文件夹，所以我们需要再添luasocket库的上一级目录路径（我的在D:\Lua5.1）+lua\socket\?.lua,注意LUA_PATH中的这两个路径要用；隔开。简单解释一下，上面配置的路径的意思就是当我require一个lua的模块时，他会从我们前面luasocket库的lua文件夹中和lua文件夹下的socket文件夹中寻找相应的lua文件，当我们require一个c的库的时候，会从我们的luasocket库的mime文件夹和socket文件夹下去加载相应的库文件，为什么这里没有针对mime和socket文件夹分开设置路径？打开luasocket库中的socket.lua文件会发现，它帮我们加载时填写的路径里面已经包含了相应的目录（一个是socket.core另一个是mim.core）这个点在c下面会被翻译为目录分隔符，所以我们不需要分开处理，好的，到这里，如果前面的工作没问题的话我们的配置工作就完成了，下面我们就来打开一下我们的luasocket库： lua的解释器程序中直接编辑require（”socket”），然后打印返回值的_VERSION 就可以看到当前luasocket的版本信息了，下面是运行效果图： 到这里，luasocket库怎么添加到windows环境中的方法就已经说完了，博主水平有限，如有不正确的地方欢迎批评指正 </description>
    </item>
    <item>
      <title>极品工控插件 iocomp 中 iXYPlotX1配置全面解析</title>
      <link>https://anwangtanmi.github.io/posts/d525b8a0a22637229b5a71dc4d2305df/</link>
      <pubDate>Thu, 13 Jul 2017 10:15:09 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/d525b8a0a22637229b5a71dc4d2305df/</guid>
      <description>极品工业控件Iocomp 在VB6.0平台使用 绘制曲线 iXYPlotX1全面解析&#xA;1新建工程 要把Form1的界面拉宽一点，增加分辨率。&#xA;2加载iocomp部件 3新建 iXYPlotX1 部件 选择这个图标在Form1中拉伸出一个范围。如下图所示。&#xA;4 更改标题栏的字体与颜色，并可实现汉语显示 注：Margin 为标题距离表格线的距离，可正负，双精度。 5、背景颜色设置 背景颜色默认为黑色，一般情况下是可以使用的，而且对比度很高。但是有些情况需要打印图形，这个时候黑色的底色就哭了。怎么办？调整底色方法如下图。&#xA;6 增加显示通道 7改变通道标题字颜色 8改变横纵坐标的标线与标数的颜色 9 改变表格细分栏颜色，调整最佳对比度 10 标题栏、横纵坐标、通道指示栏汉字输入程序段 Private Sub Form_Load()&#xA;‘//=== 曲线绘制窗口参数修改 ===&#xA;iXYPlotX1.Channel(0).TitleText = ” 通道一风速 m/s”&#xA;iXYPlotX1.Channel(1).TitleText = ” 通道2 压差x100Pa”&#xA;iXYPlotX1.Channel(2).TitleText = ” 通道Ⅲ扭矩 N·m”&#xA;iXYPlotX1.Channel(3).TitleText = ” 通道④转速 x1000rpm”&#xA;iXYPlotX1.TitleText = “这是曲线显示标题栏”&#xA;iXYPlotX1.XAxis(0).Title = “这是横坐标”&#xA;iXYPlotX1.YAxis(0).Title = “这是纵坐标”&#xA;End Sub&#xA;11 模拟绘制曲线程序与显示效果图 Private Sub Timer1_Timer()&#xA;‘//—— 绘制曲线 ——</description>
    </item>
    <item>
      <title>PHP图片水印类（GD库）</title>
      <link>https://anwangtanmi.github.io/posts/9bad1abe8ba4ad5cb9fce64364d915ca/</link>
      <pubDate>Fri, 16 Jun 2017 22:06:28 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/9bad1abe8ba4ad5cb9fce64364d915ca/</guid>
      <description> 这几天学习了一下GD扩展库，昨天写了一个图片验证码，今天继续写了一个给图片增加水印的类。&#xA;什么是图片水印 先来看一下什么是水印：&#xA;水印，是指在造纸过程中形成的，“夹”在纸中而不是在纸的表面，迎光透视时可以清晰看到有明暗纹理的图形、人像或文字，它是纸张在生产过程中用改变纸浆纤维密度的方法而制成的。通常人民币、购物卷、粮票、证劵等等，都采用此方式，以防止造假&#xA;类似的，图片水印就是在自己制作的图片或自己网站的图片上贴上一个标签 ， 表明作者信息或网站信息，也可以防止别人盗用。 通常水印可以是文字或者另一图片，并且有一定透明度，不影响原图的查看。&#xA;PHP生成水印图的步骤 这里的水印可以是文字或者是图片。 1. 打开需要处理的图片 2. 计算水印的位置 3. 增加水印（文字或图片） 4. 保存新图片 5. 释放资源（可以省略，php可以自动释放）&#xA;所使用的GD函数 打开和关闭图片就不说了，这里说的是处理图片水印所需要的GD函数&#xA;1.计算文本框大小所需要的函数：&#xA;array imageftbbox ( float $size , float $angle , string </description>
    </item>
    <item>
      <title>OpenGL开启Gouraud明暗处理，减少马赫夫效应</title>
      <link>https://anwangtanmi.github.io/posts/2558b4dc5fd51aaae1b0f6e7c6311863/</link>
      <pubDate>Tue, 18 Apr 2017 10:23:41 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/2558b4dc5fd51aaae1b0f6e7c6311863/</guid>
      <description>在我们建立三维模型的过程中，当用多边形网格或者是三角面片来近似的表示曲面的表面时，曲面被离散成许多的平面多边形，如果我们的网格较大，离散度较粗，在模型表面使用明暗处理后，两两相邻的多边形会出现凸起或者是凹陷的折痕，在连接处显得比周围处亮或者暗，这就是所谓的马赫夫效应，如下图所示&#xA;针对于出现的马赫夫效应，我们需要进行明暗处理，消除或者是减少三维模型的马赫夫效应，使其看上去更加的光滑美观，常用的明暗处理技术有双线性光强插值—Gouraud明暗处理技术和双线性法向插值-Phong明暗处理技术。以下展示经过明暗处理前后结果对比&#xA;OpenGL提供了两种着色模式void glShadeModel ( GLenum mode)，恒定着色GL_FLAT，光滑着色GL_SMOOTH，而GL_SMOOTH中则是使用了Gouraud明暗处理技术，对于Phong明暗处理技术可以参见http://blog.csdn.net/dalewzm/article/details/46291397&#xA;http://blog.csdn.net/silangquan/article/details/10011169&#xA;Gouraud明暗处理算法在处理亮度的不连续性方面很有效，但是在明暗强度函数的斜率急剧变化处仍然可以看到马赫夫效应，不能完全消除光强度的不连续性。而Phong明暗处理是对表面的法向量而不是亮度进行插值，大大改善了Gouraud模型对高亮度镜面反射光的处理，在每一点都是用法向量的一个近似值，所以一般法向量插值的结果要优于亮度插值，在很大程度上消除了马赫夫效应，但是会大大增加明暗处理的时间。&#xA;鉴于此，我在用MC算法建立三维模型的时候，由于我的网格设置较大，导致出现了马赫夫效应，即模型表面的可视化效果不光滑，如下：&#xA;于是使用OpenGL自带的Gouraud明暗处理技术，以一个MC算法生成的章鱼模型为例子，效果如下&#xA;相比未使用明暗处理的模型，使用了Gouraud处理的模型从可视化的角度上来看更加的光滑，效果更好。</description>
    </item>
    <item>
      <title>用Java实现给图片添加文字水印</title>
      <link>https://anwangtanmi.github.io/posts/dc21b38a44a3b75fcc1016a2fcf00357/</link>
      <pubDate>Sun, 12 Mar 2017 23:04:50 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/dc21b38a44a3b75fcc1016a2fcf00357/</guid>
      <description>程序背景 在网络中的很多地方都有水印的存在，比如微信公众号上面的图片，微博，以及这个CSDN博客上面的图片……所以突发奇想，看看自己能否写一个可以给图片添加水印的工具类。&#xA;程序代码 package image; import java.awt.Color; import java.awt.Font; import java.awt.Graphics2D; import java.awt.Image; import java.awt.image.BufferedImage; import java.io.File; import java.io.FileOutputStream; import javax.imageio.ImageIO; /** * @author 白芷 * @Date 2017/03/12 * @use 利用Java代码给图片加水印 */ public class WaterMarkUtils { /** * @param srcImgPath 源图片路径 * @param tarImgPath 保存的图片路径 * @param waterMarkContent 水印内容 * @param markContentColor 水印颜色 * @param font 水印字体 */ public void addWaterMark(String srcImgPath, String tarImgPath, String waterMarkContent,Color markContentColor,Font font) { try { // 读取原图片信息 File srcImgFile = new File(srcImgPath);//得到文件 Image srcImg = ImageIO.</description>
    </item>
    <item>
      <title>Deeplink:web唤醒app</title>
      <link>https://anwangtanmi.github.io/posts/23263d434ca5e45d828ec9b1aa29208e/</link>
      <pubDate>Fri, 10 Mar 2017 15:40:31 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/23263d434ca5e45d828ec9b1aa29208e/</guid>
      <description>在Android平台URI主要分五个部分：scheme, authority, path, queryParameter, queryString。其中authority又分为host和port。格式如下：(url的所有字母命名只能为小写) scheme://host:port/path?qureyParameter=queryString 例如：myscheme://www.febmaple.com:80/mypath?key=mykey&#xA;在Android的Manifest配置文件中，在要启动的activity下配置项中有配置。 其中包含内容有:&#xA;&amp;lt;data android:host=&#34;&#34; android:mimeType=&#34;&#34; android:path=&#34;&#34; android:pathPattern=&#34;&#34; android:pathPrefix=&#34;&#34; android:port=&#34;&#34; android:scheme=&#34;&#34; android:ssp=&#34;&#34; android:sspPattern=&#34;&#34; android:sspPrefix=&#34;&#34;/&amp;gt; 1、web端html里写入 Click 2、android端在menifest的响应activity的intentfilter下配置,一般只需配置scheme和host即可。 3、这样手机系统自带浏览器碰到不能处理的scheme之后会发送intent给能处理的应用，因为我们的app可以处理该scheme，所以我的app得到启动。（ps：如果用webview加载html，webview碰到处理不了的scheme并不会发送intent找app处理，而系统自带浏览器是可以的，当然我们的需求就是用系统自带浏览器触发）。&#xA;Show u my code:&#xA;一、跳到app首页：新建一个app工程用webview加载所写的html，用以触发目标app。（实际需求是直接在系统浏览器里触发目标app） 1、建立html放到工程的main/assets目录下&#xA;&amp;lt;/span&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;Test Schemeh1&amp;gt; &amp;lt;a href=&#34;myscheme://www.febmaple.com:80/mypath?key=mykey&#34;&amp;gt;Clicka&amp;gt; body&amp;gt; html&amp;gt; 2、webview加载本地html内容来触发目标app&#xA;wvUrl.loadUrl(&#34;file:///android_asset/test.html&#34;); 3、在app manifeset的**欢迎**activity添加intent-filter配置data标签.&#xA;&amp;lt;activity android:name=&#34;.ui.launching.DemoLaunchingActivity&#34; android:screenOrientation=&#34;portrait&#34;&amp;gt; &amp;lt;intent-filter&amp;gt; &amp;lt;action android:name=&#34;android.intent.action.MAIN&#34;/&amp;gt; &amp;lt;category android:name=&#34;android.intent.category.LAUNCHER&#34;/&amp;gt; intent-filter&amp;gt; &amp;lt;intent-filter&amp;gt; &amp;lt;action android:name=&#34;android.intent.action.VIEW&#34;/&amp;gt; &amp;lt;category android:name=&#34;android.intent.category.DEFAULT&#34;/&amp;gt; &amp;lt;category android:name=&#34;android.intent.category.BROWSABLE&#34;/&amp;gt; &amp;lt;data android:scheme=&#34;myscheme&#34;/&amp;gt; intent-filter&amp;gt; activity&amp;gt; 4、在配置好的Activity里即可获取外部跳转的参数信息。&#xA;@Override protected void onCreate(Bundle savedInstanceState) { super.</description>
    </item>
    <item>
      <title>MD5登录&#43;SQL用户名密码校验</title>
      <link>https://anwangtanmi.github.io/posts/a9176014f3d7e82e162d90089998d57a/</link>
      <pubDate>Thu, 16 Feb 2017 10:34:58 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/a9176014f3d7e82e162d90089998d57a/</guid>
      <description>这是一个winform程序,MD5计算,SQLserver表格数据查询,修改操作.&#xA;点击登录时,会将ID和转换成MD5值的密码 与数据库用户表中的信息作查询,由查询结果判断是否登录成功.&#xA;1.登录成功:可以使用修改密码button,(显示欢迎),点击修改密码,弹出新窗口,可以在新窗口中作修改密码操作(检验旧密码,确认新密码),存储在数据库中的密码依旧是MD5值&#xA;2.登录失败:由返回值确定是用户名不存在还是密码错误&#xA;登录&#xA;private void btnLogin_Click(object sender, EventArgs e) { string loginId = txtId.Text.Trim(); string loginPwd = CommonHelp.GetMD5FromString(txtPwd.Text).ToLower(); //校验用户名是否存在以及密码是否正确 string sql = &#34;select CC_AutoId,CC_UserName,CC_LoginPassword from T_Seats where cc_loginId=@uid&#34;; SqlParameter pms = new SqlParameter(&#34;@uid&#34;, loginId); //用户名密码的校验标记 bool userExist = false; bool pwdCorrect = false; using (SqlDataReader reader= SqlHelper.ExecuteReader(sql, CommandType.Text, pms)) { if (reader.HasRows) { userExist = true; if (reader.Read()) { //获取查询到的密码 string uPwd = reader.GetString(2); //密码比较 if (uPwd==loginPwd) { pwdCorrect = true; btn3.</description>
    </item>
    <item>
      <title>C# Selenium-疑难杂症</title>
      <link>https://anwangtanmi.github.io/posts/ff3027a12661cd419b1a819ac7fc7ab5/</link>
      <pubDate>Tue, 07 Feb 2017 13:17:59 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/ff3027a12661cd419b1a819ac7fc7ab5/</guid>
      <description> C# Selenium-疑难杂症 发现网络上的C#Selenium文章好少，讲问题的就更少了。这个文章主要纪录一些疑难杂症和一些解决办法。本文中所用的是wedDriver 也就是Selenium2&#xA;1.StaleElementReferenceException(元素过期异常) 样子下下图;&#xA;在查找元素后，返回了元素对象的引用，但对象里是一堆异常。这里不会报错，只有调试才能看到，属于一个暗坑呀。。&#xA;解决办法：在查找元素前加一个延迟。比如点击后，要获取提示信息。那么应该在点击后延迟一点时间，给页面时间来反应。&#xA;2.stale element reference: element is not attached to the page document(过时元素引用：元素未附加到页面文档) 错误如下图：&#xA;这个错通常出现在找到页面元素，当页面元素变化后没有更新导致的。至于为什么会这样，我推测是元素依附的那个HTML文档是以前的，当没有重新获取，元素对象在新的页面中就消失了，所以会提示找不到了。&#xA;解决办法：重新用FindElement（）方法找一次&#xA;3.no such element: Unable to locate element(没有这样的元素：无法定位元素) 错误下如图： 元素存在HTML中，但是代码中却报错。这会在页面上是处于隐藏的，当然不能找到拉！ 还有一种是路径没有写对。虽然有多种方式，但我不太喜欢用Xpath来定位。Xpath是绝对路径，但我们平时要测试的网页大部分是变化的，那Xpath就需要老修改，不太方便。PS：这里说的变化是开发中修改网页、或是网页更新（百度首页也不可能几年都不变呀）。当HTML被加载后，只要不刷新或是DIV中没有发生网页填充，这时的HTML文档结构是短暂不变的&#xA;解决办法： 1.如果确认路径没有错的情况下，一点要模拟鼠标去写代码。比如这里，账户登录不点击的话，忘记密码是不会显示的，就定位不到了。 2.如果是路径的问题，尽量用唯一的去定位。比如连接中的文字（LinkText）、ID这些&#xA;未完待续 </description>
    </item>
    <item>
      <title>【Maven】—使用Idea创建maven webapp项目遇到的问题总结</title>
      <link>https://anwangtanmi.github.io/posts/c24faeeb99d210670eaefc5f298d6f64/</link>
      <pubDate>Sun, 05 Feb 2017 17:30:03 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/c24faeeb99d210670eaefc5f298d6f64/</guid>
      <description>操作步骤： 1.File–&amp;gt;New–&amp;gt;Project 2.选择maven-archetype-webapp&#xA;3.填写groupId和artifactId&#xA;4.填写maven settings文件的地址、本地仓库的地址&#xA;5.填写projectName&#xA;问题： 1.本机电脑上不同maven项目所用的仓库地址不一致，有的配置的是局域网内的地址，如果本机没处在局域网中就不能用。所以，我让自己电脑中的所有项目都使用一个本地仓库，但是为不同的项目配置不同的settings.xml。下面是我为自己试验项目配的settings.xml&#xA;&amp;lt;settings xmlns=&#34;http://maven.apache.org/SETTINGS/1.0.0&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:schemaLocation=&#34;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&#34;&amp;gt; &amp;lt;localRepository&amp;gt;D:\maven\repositorylocalRepository&amp;gt; &amp;lt;mirrors&amp;gt; &amp;lt;mirror&amp;gt; &amp;lt;id&amp;gt;alimavenid&amp;gt; &amp;lt;name&amp;gt;aliyun mavenname&amp;gt; &amp;lt;url&amp;gt;http://maven.aliyun.com/nexus/content/groups/public/url&amp;gt; &amp;lt;mirrorOf&amp;gt;centralmirrorOf&amp;gt; mirror&amp;gt; mirrors&amp;gt; settings&amp;gt; 所以在上面的步骤4时，需要修改user settings.xml文件的位置。&#xA;2.idea maven mvn archetype:generate 速度缓慢，控制台一直显示Generating project in Batch mode，状态栏一直Running。 webapp的archetype下载缓慢，项目的目录结构一直创建不出来。 我们需要在上述步骤的第4步时，添加一个属性项。这样archetype就不会从远程仓库加载。&#xA;archetypecatalog的值可以是remote，internal，local区别如下：&#xA;remote，远程Maven库中提供的模板。mvn archetype:generate默认使用该类模板 internal，Apache Maven项目默认提供的模板。mvn archetype:generate -DarchetypeCatalog=internal使用该类模板 local，本地Maven库中提供的模板。mvn archetype:generate默认使用该类模板，作为remote的补充。Maven初始为空，执行mvn install时会将当前项目加入local模板库&#xA;总结： 1.archetype&#xA;archetype： In short, Archetype is a Maven project templating toolkit。 maven-archetype-webapp ： An archetype to generate a sample Maven Webapp project.</description>
    </item>
    <item>
      <title>VS Code折腾记 – (3) 多图解VSCode基础功能</title>
      <link>https://anwangtanmi.github.io/posts/14073ef3f81107c66758d361f41bc911/</link>
      <pubDate>Thu, 19 Jan 2017 22:54:40 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/14073ef3f81107c66758d361f41bc911/</guid>
      <description>前言 想了想，对于一个刚接触VSCODE的人来说，有什么比图片更通俗易懂的呢？&#xA;界面&amp;amp;功能截图 启动界面 : 快捷键（Ctrl + Shift + E） Search &amp;amp;&amp;amp; replace ： 快捷键（Ctrl + Shift + H） Git： 快捷键（Ctrl + Shift + G） Debug： 快捷键（Ctrl + Shift + D） Extend： 快捷键（Ctrl + Shift + X） 结言 快过年啦，预祝大伙新年快乐，万事如意</description>
    </item>
    <item>
      <title>阻止屏幕变暗进入休眠状态</title>
      <link>https://anwangtanmi.github.io/posts/ed1273f1e3fd1687b9cfebe1cde46773/</link>
      <pubDate>Fri, 06 Jan 2017 10:46:56 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/ed1273f1e3fd1687b9cfebe1cde46773/</guid>
      <description>阻止屏幕变暗进入休眠状态 //阻止屏幕变暗，慎重使用,缺省为no [UIApplication sharedApplication].idleTimerDisabled = YES; 慎重使用本功能，因为非常耗电。</description>
    </item>
    <item>
      <title>mt19937 随机数</title>
      <link>https://anwangtanmi.github.io/posts/c46890b4c9de6a9de8cb95f42c92898a/</link>
      <pubDate>Tue, 27 Dec 2016 11:09:33 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/c46890b4c9de6a9de8cb95f42c92898a/</guid>
      <description>一下内容整理自网络资源：&#xA;我们讲的随机数其实暗指伪随机数。不少朋友可能想到C语言的rand()，可惜这个函数产生的随机数随机性非常差，而且速度很慢，相信几乎不能胜任一般的应用。&#xA;古老的LCG(linear congruential generator)代表了最好的伪随机数产生器算法。主要原因是容易理解，容易实现，而且速度快。这种算法数学上基于X(n+1) = (a * X(n) + c) % m这样的公式，其中：&#xA;模m, m &amp;gt; 0&#xA;系数a, 0 &amp;lt; a &amp;lt; m&#xA;增量c, 0 &amp;lt;= c &amp;lt; m&#xA;原始值(种子) 0 &amp;lt;= X(0) &amp;lt; m&#xA;其中参数c, m, a比较敏感，或者说直接影响了伪随机数产生的质量。&#xA;一般而言，高LCG的m是2的指数次幂(一般2^32或者2^64)，因为这样取模操作截断最右的32或64位就可以了。多数编译器的库中使用了该理论实现其伪随机数发生器rand()。下面是部分编译器使用的各个参数值：&#xA;Source m a c rand() / Random(L)的种子位 Numerical Recipes 2^32 1664525 1013904223 Borland C/C++ 2^32 22695477 1 位30..16 in rand(), 30..0 in lrand() glibc (used by GCC) 2^32 1103515245 12345 位30.</description>
    </item>
    <item>
      <title>Win10白色图标制作及替换</title>
      <link>https://anwangtanmi.github.io/posts/3b760eb1a7510c7583c97d43b04bd631/</link>
      <pubDate>Sat, 17 Sep 2016 16:57:34 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/3b760eb1a7510c7583c97d43b04bd631/</guid>
      <description>win10白色图标制作： 一、软件准备IcoFX：提取图标、生成图标。&#xA;Photoshop：修改编辑图标。&#xA;二、制作步骤1、 提取图标打开IcoFX，直接在桌面上选择快捷方式，拉拽以icoFX打开。&#xA;打开后提取图标&#xA;打开图标后保存为：png格式&#xA;2，然后使用ps打开，开始编辑&#xA;先建立一块透明背景，256×256就够了，然后打开图片，将需要保留的白色部分保留，删除其他部分，或者根据自己的需要自定义&#xA;1，点击魔术棒，选择白色区域以外的地方，删除&#xA;删除不需要的地方，保留需要的地方，然后使用白色前景色，再用油漆桶将需要的地方涂为白色&#xA;弄好之后就是上面的那张图片，然后保存，做好的图片在次使用icoFX打开，选择创建一个图标&#xA;然后保存为图标之后就可以开始替换了。&#xA;替换图标： 替换图标的方式有多种，我只说两种我用的。 1，图标可以放在统一的地方，也可以放在程序安装路径 桌面快捷方式右键——属性——–打开文件位置——-然后将图标移动到此处——-在回去属性页面点击更换图标——–浏览找到图标位置—-替换成功 2.用exe资源查看器（我用的Restorator 2007）打开程序exe文件，然后找到图标，用制作的白色图标替换，然后保存，软件会自动帮助备份 注意：exe替换成功后有些软件会将通知栏图标也变为白色，但有些软件不会，exe替换成功后需要清理一下&#xA;Windows通知区域图标历史记录 在网上找到的方法是下面这两种：第一种方法，手工修改注册表：1、按“Win R”组合键，输入“regedit”打开注册表编辑器，然后打开如下键值： HKEY_CLASSES_ROOT\Local Settings\Software\Microsoft\Windows\CurrentVersion\TrayNotify　在右边你可以看到两个键值：IconStreams和PastIconsStream，将它们的值删除。2、然后调出任务管理器将进程“explorer.exe”终止，再在任务管理器中点击“文件——新建任务”，输入“explorer”，回车，以此重新启动该系统进程。(或者重新启动计算机）。现在再来查看一下通知区域的图标，过期的图标已经被成功清理了。第二种方法：用批处理文件清理Windows通知区域图标历史记录：第一种方法虽好，但是有点技术问题在其中，对于菜鸟们来说有点难度，有没有简单的方法？网上有人提供了一个BAT批处理小工具，专门用来清理Windows通知区域图标历史记录。这个BAT文件安全性高，不会造成系统损坏，适用于当前主流的Windows7\vista\XP系统，使用如图所示： bat清理我只在win7上用过，在win10上还没有测试 批处理： @ ECHO OFF&#xA;SET PROG=清理系统通知区域 （XP/WIN7/VISTA）&#xA;COLOR 0a&#xA;@ ECHO.&#xA;@ ECHO. 说 明&#xA;@ ECHO.&#xA;@ ECHO ——————————————————————————–&#xA;@ ECHO.&#xA;@ ECHO. WINDOWS 系统能在通知区域自动隐藏不活动的图标，这是个非常实用的功能。但是日积&#xA;@ ECHO.月累之下，通知区域的图标越来越多，有的是很久之前的图标，甚至该软件已经卸载。图标&#xA;@ ECHO.的增多不仅臃肿且看起来十分的不舒服。此批处理文件能帮你清理掉通知区域的历史图标。&#xA;@ ECHO.&#xA;@ ECHO ——————————————————————————–&#xA;TITLE %PROG%&#xA;PAUSE&#xA;CLS&#xA;@ ECHO.&#xA;@ ECHO.</description>
    </item>
    <item>
      <title>ob原理的代码</title>
      <link>https://anwangtanmi.github.io/posts/bddfcd4e97575382239d2059dd45f820/</link>
      <pubDate>Tue, 13 Sep 2016 16:11:40 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/bddfcd4e97575382239d2059dd45f820/</guid>
      <description> </description>
    </item>
    <item>
      <title>基于多尺度对比度x射线图像增强算法2</title>
      <link>https://anwangtanmi.github.io/posts/8150b8a050934071406f95aca7a492d1/</link>
      <pubDate>Wed, 27 Jul 2016 13:17:08 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/8150b8a050934071406f95aca7a492d1/</guid>
      <description>﻿﻿ 基本流程 ：&#xA;LOG校正—&amp;gt;&amp;gt;图像分解–&amp;gt;&amp;gt;图像细节处理–&amp;gt;&amp;gt;图像重建–&amp;gt;&amp;gt;输出曲线调整.&#xA;该算法是经过多年实践完善dx增强算法&#xA;算法2是在算法1的基础上完善的,&#xA;主要解决了边阴影问题；&#xA;黑背景问题；增强过度边界溢出问题；&#xA;同时还解决了因为去栅后处理增强栅线问题；&#xA;程序使用SSE指令集和intel编译器&#xA;使得增加处理过程后不增加处理时间；&#xA;该算法对线对几乎没有影响,最大限度保持了线对；&#xA;该程序只是处理DEMO版本，只有一个默认参数，&#xA;demo下载地址&#xA;http://download.csdn.net/detail/moyumoyu/9587475&#xA;处理效果：&#xA;处理DEMO</description>
    </item>
    <item>
      <title>【CDP-云设计模式】第3章，4.深度健康检查模式（Deep Health Check Pattern）</title>
      <link>https://anwangtanmi.github.io/posts/e22a0bac46abebd4e6cac61e9d941e55/</link>
      <pubDate>Mon, 11 Jul 2016 08:37:22 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/e22a0bac46abebd4e6cac61e9d941e55/</guid>
      <description>1.要解决的问题 在分配负载进程时，可以在负载均衡器中使用健康检查功能来评估绑定于负载均衡器上的服务器状态。&#xA;例如：在一个包含web服务器、代理服务器、应用程序服务器和数据库服务器的配置中，让我们考虑在web服务器之前使用负载均衡器的情况。&#xA;负载均衡器能够评估web服务器的状态，并在web服务器出现故障时将其切断。然而，负载均衡器不能识别后端服务器状态，例如代理服务器、应用程序服务器和数据库服务器。&#xA;2.云模式的说明 你可以运用云负载均衡器中的健康检查功能，使用PHP、JavaServelet或类似的（程序）建立一个动态页面来执行检查。这个程序可以检查代理服务器、应用程序服务器、数据库服务器等这一类服务器的运行，并将结果返回给负载均衡器。这样就可以将系统作为一个整体进行检查。&#xA;3.实施 在AWS中，ELB的健康检查功能对HTTP(S)是否能连接到指定的URL进行了状态检查。使用这一功能，将健康检查的结果指向一个动态页面。&#xA;我们将使用一个由web服务器、代理服务器、应用程序服务器和数据库服务器组成的系统来举例说明如何实现。 （步骤）&#xA;启动ELB，并开启健康检查功能。&#xA;创建运行在应用服务器上的程序。使其在运行时需要访问数据库。&#xA;将ELB的健康检查地址设置为此程序的URL。向此URL发出请求来激活这个程序。&#xA;由ELB执行健康检查。&#xA;4.配置 5.好处 这使得你可以检查系统运行时所需的所有服务器。&#xA;根据程序如何响应健康检查，它可能会执行关闭过程（即拒绝请求），也可能会根据失效的细节返回自定义错误信息。&#xA;6.注意事项 如果有大量的服务器，那么健康检查本身可能会造成网络拥塞，所以必须仔细考虑健康检查的的时机。&#xA;如果数据库服务器成为单一故障点并发生宕机，这可能会引起一个过度反应而使得所有服务器宕机，这取决于后端服务器检查程序的编写。&#xA;同时使用数据库复制模式可以防止数据库服务器成为单一故障点。</description>
    </item>
    <item>
      <title>全黑图像去除</title>
      <link>https://anwangtanmi.github.io/posts/93a0945ae8f06188e63b59d41f64f02f/</link>
      <pubDate>Wed, 16 Mar 2016 14:37:40 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/93a0945ae8f06188e63b59d41f64f02f/</guid>
      <description>本系列文章由&#xA;@yhl_leo 出品，转载请注明出处。&#xA;文章链接：&#xA;http://blog.csdn.net/yhl_leo/article/details/50904358&#xA;昨天一个朋友，向我求助，帮忙去除掉一组遥感影像数据中，因为裁剪时产生的全黑图像，实现起来也很简单，就将工程代码提供给大家：&#xA;GitHub链接：yhlleo/ImageFormatConversion&#xA;图像格式为单通道16-bit的tif，可以使用OpenCV库读取：&#xA;cv::Mat curImage = cv::imread(fileName, IMREAD_UNCHANGED); 因为图像是16-bit的，所指使用图片查看器，浏览的话，肯定是全黑的。但是可以在Photoshop中，调整灰度曲线，显示图片内容（将曲线调成近似直角折线）：&#xA;那些黑色图像（真的是全黑，像素值为0），判断方法比较简单，获取图像灰度最大最小值，区间范围是0，必然是全黑图像：&#xA;double pMax = 0, pMin = 0; cv::minMaxIdx(curImage, &amp;amp;pMin, &amp;amp;pMax); int pRange = pMax - pMin; if ( pRange &amp;gt; 0 ) { // ... } else { // Black image // ... } 如果想把16-bit图像转为常见的8-bit图像，我使用的方法是这样的：&#xA;if( pRange &amp;gt; 0 ) { for ( int i=0; iint pValue = ( static_cast&amp;lt;int&amp;gt;(*++data_cur &amp;amp; 0xffff) - ipMin ) * 255 / pRange; data_trans[i] = static_cast(pValue); } } 即，使用简单的线性拉伸方法：</description>
    </item>
    <item>
      <title>我的暗博</title>
      <link>https://anwangtanmi.github.io/posts/81eced5788baae7303595ba399379137/</link>
      <pubDate>Sat, 07 Mar 2015 14:32:15 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/81eced5788baae7303595ba399379137/</guid>
      <description>暗网就是搜索引擎搜索不到的网络. 我的暗博, 搜索引擎可以搜索得到, 但是已经是加密的.&#xA;一. 实现原理很简单 1. 发表: 对博文进行加密, 然后进行十六进制可视处理, 发表到博客.&#xA;2. 阅读: 对加密博文进行解密, 转换成明文, 就可以阅读.&#xA;3. 缺点: 因为需要解密, 所以没有直接点击阅读方便.&#xA;4. 优点: 有些私人的内容, 你可以发布到网上, 别人也不知道你的秘密.&#xA;二. 暗博工具界面 图1&#xA;这是暗博工具的界面, 包含博客内容输入, 密码输入, 正向生成和逆向生成.&#xA;下载地址: http://download.csdn.net/detail/cay22/8510293&#xA;2.0地址: http://download.csdn.net/detail/cay22/9153771&#xA;三. 暗博生成的文本 [================================================] [Date = 2015-10-02 11:52:27] [Password = 12345] [SPassword = true] [PDescribe = 12345] [BDescribe = 12345] [DarkBlog = 41905908000000000098CDC397DCAB111B1C0698A33441024CA83FF07DCB629CC82C6A0181D588119AE1B2E308F9CBF95D85E22C5ECCA00D4B7114F4BCACF8B1 AFC77BC51380100E0E7AB26576EB124C94B57CB109D6DE3D9E8B629580B263EAD5F2266B370555347A3AA741D996432C2491AAE53B0DF6BA] [================================================] 把这段文本拷贝到工具, “逆向”即可还原暗博原文.</description>
    </item>
    <item>
      <title>捕获海康威视IPCamera图像，转成OpenCV可以处理的图像（一）</title>
      <link>https://anwangtanmi.github.io/posts/2f906de0d41d8c3aad5e16ae7ba9283e/</link>
      <pubDate>Mon, 16 Jun 2014 18:32:41 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/2f906de0d41d8c3aad5e16ae7ba9283e/</guid>
      <description>海康威视IPCamera图像捕获 捕获海康威视IPCamera图像，转成OpenCV可以处理的IplImage图像（一）&#xA;捕获海康威视IPCamera图像，转成OpenCV可以处理的IplImage图像（二）&#xA;所使用海康威视摄像头型号：DS-2CD4026FWD-(A)(P)&#xA;海康威视IPCamera图像捕获方法有两种：&#xA;（1）利用SDK里面的NET_DVR_CaptureJPEGPicture_NEW进行视频抓图&#xA;（2）捕获实时流，将实时流解码成YV12，然后转换成RGB&#xA;在这篇博文里，我先介绍第一种方法。&#xA;第一种方法，关键是调用NET_DVR_CaptureJPEGPicture_NEW这个函数。关于这个函数的参数，可以在SDK中找到，我这里截个图以作说明。&#xA;这个函数Ret是用于返回该图像大小的一个参数，但是该函数的这个参数大概是没有用引用或者指针的方式来传递参数，导致返回值一直是我初始化的0，因此为后面的操作带来了些许的不便——不得不使用一个较大的内存来保存图像一定能存储的下。&#xA;NET_DVR_CaptureJPEGPicture_NEW这个函数是将单帧数据捕获并保存成JPEG，存放在指定的内存空间中。也就是内存里的JPEG。为了获得OpenCV能处理的IplImage图像，必须在内存中进行解码。&#xA;OpenCV在内存中解码的函数只有一个：imdecode，下图是imdecode的说明&#xA;该函数要求buf必须是数组或者是byte类型的vector. 因此需要对char * 类型的JPEG压缩图像进行存储格式转换。&#xA;#include #include #include #include #include &#34;HCNetSDK.h&#34; #include &#34;highgui.h&#34; #include &#34;cv.h&#34; using namespace cv; using namespace std; //typedef HWND (WINAPI *PROCGETCONSOLEWINDOW)(); //PROCGETCONSOLEWINDOW GetConsoleWindow; int main(int argc, char * argv[]) {&#x9;//--------------------------------------- // 初始化 NET_DVR_Init(); //设置连接时间与重连时间 NET_DVR_SetConnectTime(2000, 1); NET_DVR_SetReconnect(10000, true); //--------------------------------------- //获取控制台窗口句柄 //HMODULE hKernel32 = GetModuleHandle((LPCWSTR)&#34;kernel32&#34;); //GetConsoleWindow = (PROCGETCONSOLEWINDOW)GetProcAddress(hKernel32,&#34;GetConsoleWindow&#34;); //--------------------------------------- // 注册设备 LONG lUserID; NET_DVR_DEVICEINFO_V30 struDeviceInfo; lUserID = NET_DVR_Login_V30(&#34;</description>
    </item>
    <item>
      <title>【iOS】UIColor&#43;Change颜色类的类目扩展</title>
      <link>https://anwangtanmi.github.io/posts/aa0cb091736d88037b86da2cc99ebd0c/</link>
      <pubDate>Sat, 24 May 2014 23:10:39 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/aa0cb091736d88037b86da2cc99ebd0c/</guid>
      <description>在颜色类UIColor的基础上用类目(Category)做了扩展。&#xA;主要功能方法如下：&#xA;获取颜色对象的RGB数值 －（CGFloat）getRGB;&#xA;说明：该方法在网上流行的方法上做了一些改进，&#xA;对黑灰白这些不能直接获取的颜色做了特殊处理。&#xA;对于其它无法取得RGB的值，默认返回0，0，0.&#xA;将颜色对象转换为canvas用字符串格式 －（NSString *）canvasColorString;&#xA;将颜色对象转换为Web用字符串格式 －（NSString *）webColorString;&#xA;将颜色对象变亮 －（UIColor *）lighten;&#xA;将颜色对象变暗 －（UIColor *）darken; 将两个颜色对象混合 －（UIColor *）mix: (UIColor *) c; 博文首发地址：http://blog.csdn.net/duzixi&#xA;最新代码下载地址：https://github.com/duzixi/UIColor-Change&#xA;源代码如下：&#xA;UIColor+Change.h&#xA;// // UIColor+Change.h // ChangeColor // // Created by 杜子兮 on 14-3-13. // Edited by 杜子兮 on 14-5-23. // Edited by 杜子兮 on 14-7-12. for Canvas. // Copyright (c) 2014年 lanou3g.com All rights reserved. // #import @interface UIColor (Change) /// 获取canvas用的颜色字符串 - (NSString *)canvasColorString; ///获取网页颜色字串 - (NSString *) webColorString; ///获取RGB值 - (CGFloat *) getRGB; ///让颜色更亮 - (UIColor *) lighten; ///让颜色更暗 - (UIColor *) darken; ///取两个颜色的中间 - (UIColor *) mix: (UIColor *) color; @end UIColor+Change.</description>
    </item>
    <item>
      <title>C#设置透明按钮样式</title>
      <link>https://anwangtanmi.github.io/posts/072c4fe4ef3fa0b49b69e05e1cde0e13/</link>
      <pubDate>Mon, 23 Dec 2013 17:27:58 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/072c4fe4ef3fa0b49b69e05e1cde0e13/</guid>
      <description> /// /// 设置透明按钮样式 /// private void SetBtnStyle(Button btn) { btn.FlatStyle = FlatStyle.Flat;//样式 btn.ForeColor = Color.Transparent;//前景 btn.BackColor = Color.Transparent;//去背景 btn.FlatAppearance.BorderSize = 0;//去边线 btn.FlatAppearance.MouseOverBackColor = Color.Transparent;//鼠标经过 btn.FlatAppearance.MouseDownBackColor = Color.Transparent;//鼠标按下 } private void btn_MouseHover(object sender, EventArgs e) { Button btn = sender as Button; btn.FlatAppearance.BorderSize = 1; } private void btn_MouseLeave(object sender, EventArgs e) { Button btn = sender as Button; btn.FlatAppearance.BorderSize = 0; } </description>
    </item>
    <item>
      <title>YUV422转BGR888（海思3516平台）</title>
      <link>https://anwangtanmi.github.io/posts/3bb21b9141514cdbf080b538b9bfe0c3/</link>
      <pubDate>Fri, 15 Mar 2013 09:14:55 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/3bb21b9141514cdbf080b538b9bfe0c3/</guid>
      <description>#include &#34;hi_comm_ive.h&#34; #include &#34;mpi_ive.h&#34; #pragma pack(1) typedef struct{ short type; int size; short reserved1; short reserved2; int offset; } BMPHeader; typedef struct{ int size; int width; int height; short planes; short bitsPerPixel; unsigned compression; unsigned imageSize; int xPelsPerMeter; int yPelsPerMeter; int clrUsed; int clrImportant; } BMPInfoHeader; #pragma pack() int saveBMPFile(unsigned char* src, int width, int height, const char* name){ BMPHeader hdr; BMPInfoHeader infoHdr; int ret = 0; FILE* fp = NULL; if(NULL == src) { return (-1); } fp = fopen(name,&#34;</description>
    </item>
    <item>
      <title>暗时间</title>
      <link>https://anwangtanmi.github.io/posts/dd943f4601ace57b7281adc88d497d1f/</link>
      <pubDate>Mon, 21 Dec 2009 10:58:00 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/dd943f4601ace57b7281adc88d497d1f/</guid>
      <description>暗时间&#xA;如果你有一台计算机，你装了一个系统之后就整天把它搁置在那里，你觉得这台计算机被实际使用了吗？没有。因为CPU整天运行的就是空闲进程。运行空闲进程也是一天，运行大数据量计算的程序也是一天，对于CPU来说同样的一天，价值却是完全不一样的。&#xA;大脑也是如此。&#xA;善于利用思维时间的人，可以无形中比别人多出很多时间，从而实际意义上能比别人多活很多年。我们经常听说“心理年龄”这个词，思考得多的人，往往心理年龄更大。有人用10年才能领悟一个道理，因为他们是被动领悟——只有在现实撞到他脸上的时候才感到疼，疼完了之后还是不记得时时提醒自己，结果很快时过境迁抛之脑后，等到第二次遇到同一个坑的时候早忘了曾经跌过跟头了，像这样的效率，除非天天摔坑里，否则遗忘的效率总是大过吃亏长的记性。善于利用思维时间的人则能够在重要的事情上时时主动提醒自己，将临时的记忆变成硬编码的行为习惯。&#xA;每个人的手表都走得一样快，但每个人的生命却不是。衡量一个人生活了多少年，应该用思维时间来计算。举一个极端的例子，如果一个人从生下来开始就呆在一个为他特殊建造的无菌保护室里，没有社会交往，没有知识获取，度过了18年，你会不会认为他成年了？&#xA;认为时间对每个人是均等的是一个错觉，认为别人有一天，我也有一天，其实根本不是这样。如果你正在学习一门专业，你使用自己所投入的天数来衡量，很容易会产生一种错觉，认为投入了不少时间，然而其实，“投入时间”这个说法本身就是荒唐的，实际投入的是时间和效率的乘积。你可以“投入”很多时间在一件事情上面，却发现毫无进展，因为你没有整天把你要做的事情，要学习的东西常驻在你的大脑中，时刻给予它最高的优先级。你走路的时候吃饭的时候，做梦的时候心心念念想的就是这件事情，你的CPU总是分配给它，这个时候你的思维时间就被利用到了极致，你投入的时间就真正等于了实际流逝的时间，因为你的CPU是满载的。&#xA;如果你有做总结的习惯，你在度过一段时间之后总结自己在某某领域投入了多少时间，建议千万不要粗略地去计算有多少天下班后拿起书来翻看过，因为这样你也许会发现书倒是常翻，但领悟却不见得多深，表面上花的时间不少，收益却不见得那么大。因为看书并记住书中的东西只是记忆，并没有涉及推理，只有靠推理才能深入理解一个事物，看到别人看不到的地方，这部分推理的过程就是你的思维时间，也是人一生中占据一个显著比例的“暗时间”，你走路、买菜、洗脸洗手、坐公车、逛街、出游、吃饭、睡觉，所有这些时间都可以成为“暗时间”，你可以充分利用这些时间进行思考，反刍和消化平时看和读的东西，让你的认识能够脱离照本宣科的层面。这段时间看起来微不足道，但日积月累将会产生庞大的效应。&#xA;能够充分利用暗时间的人将无形中多出一大块生命，你也许会发现这样的人似乎玩得不比你少，看得不比你多，但不知怎么的就是比你走得更远。比如我就经常发现一些国外的牛人们为什么不仅学习牛逼，连“业余”玩儿的东东也都搞得特牛逼，一点都不业余（上次在《How We Decide》上看到斯坦福的一个牛人，粒子物理教授，同时是世界扑克大赛的前六名保持者，迄今累计奖金拿了六百多万刀），你会奇怪，这些家伙到底哪来的时间，居然可以在不止一个领域做到卓越？&#xA;程序员们都知道，任务切换需要耗费许多额外的花销，通俗地来讲，首先需要保存当前上下文以便下次能够顺利切换回来，然后要加载目标任务的上下文。如果一个系统不停地在多个任务之间来回倒腾，就会耗费大量的时间在上下文切换上，无形中浪费很多的时间。&#xA;相比之下，如果只做一件任务，就不会有此损失。这就是为什么专注的人比不专注的人时间利用效率高得多的原因。任务切换的暗时间看似非常不明显，甚至很多人认为“多任务”是件很好的事情（有时候的确是），但日积月累起来就会发现，消耗在切换上的时间越来越多。&#xA;另外，大脑开始一件任务的时候必须要有一定时间来“热身”，这个时间因人而异，并且可以通过练习来改变。举个例子，你看了一会书之后，忽然感到一阵无聊，忍不住打开浏览器，十分钟后你想起来还要继续看书，但要回复到当时理想的状态，却需要一段时间来努力去集中精力，把记忆中相关的知识全都激活起来，从而才能进入“状态”，因为你上了十分钟网之后这些记忆已经被抑制了。如果这个“热身”状态需要一刻钟，那么看似十分钟的上网闲逛其实就花费了二十五分钟。&#xA;如果阅读的例子还不够生动，对于程序员来说其实有更好的例子：你写程序写得正high，忽然被叫去开了一通会，写到一半的代码搁在那儿。等你开完会回来你需要多久能够重新进入状态？又或者，你正在调试程序，你已经花了二十分钟的时间把与这个bug可能相关的代码前前后后都理解了一遍，心中构建了一个大致的地图，就在这时，呃，你又被叫去开了个会(:D)，开完会回来，可想而知，得花上一些时间来回想一下刚刚弄清的东西了。&#xA;迅速进入状态的能力是可以锻炼的，根据我个人的经验，至少可以缩短到3-5分钟。但要想完全进入状态，却是很难在这么短的时间实现的。所谓完全进入状态，举个例子：你看了3个小时的书，或者调试了半个小时的程序之后，往往满脑子都是相关的东西，所有这些知识都处在活跃状态，换言之你大脑中所有相关的记忆神经网络都被激活了，要达到这样一种忘记时间流逝的“沉浸”状态（心理学上叫做“流体验”），不是三两分钟的事情。而一旦这种状态被破坏，无形间效率就会大打折扣。这也是为什么我总是倾向于创造大块的时间来阅读重要的东西，因为这样有利于“沉浸”进去，使得新知识可以和大脑中与其相关的各种既有的知识充分融合，关联起来，后者对于深刻的记忆非常有帮助。&#xA;要充分利用暗时间，不仅要能够迅速进入状态，另一个很重要的习惯就是能够保持状态多久（思维体力）。《The Psychology of Invention in the Mathematical Field》上有一段关于庞加莱的思考习惯的介绍，很有代表性。庞加莱经常在去海边休假或者在路上走的时候在脑海中思索数学问题，很多时候解答就在这些时候忽然闪现。虽然我和庞加莱是没法比的，但是常常也在路上想出答案，这真是一种愉悦的体验。&#xA;能够迅速进入专注状态，以及能够长期保持专注状态，是高效学习的两个最重要习惯。&#xA;很多人都有这样的体验（包括我自己），工作了之后，要处理的事情一下多出了很多，不像在校园，环境简单，生活单纯，能够心无旁骛地做一件事情而不被打扰。工作之后的状况就是，首先需要处理的事情变多，导致时不时需要在多个任务之间切换；另一方面，即便能够把任务的优先级分配得比较合理，也难免在做一件事情的时候心中忽然想起另一件事还没做的焦虑来，因为没做完的事情会在大脑中留下一个“隐藏的进程”，时不时地发个消息提醒你一下，中断你正在做的事情。&#xA;因此这里就涉及到最后一个高效的习惯：抗干扰。只有具备超强的抗干扰能力，才能有效地利用起前面提到的种种暗时间。抗干扰能力也是可以练习出来的，上本科那会经常坐车，所以我就常常拿着本大部头在车上看，坐着看或者站着看都可，事实证明在有干扰的环境中看书是非常锻炼专注能力的一个办法:D 另外，经常利用各种碎片时间阅读和思考，对迅速集中注意力和保持注意力都非常有帮助。记得很久以前TopLanguage上大伙曾经有次饶有兴趣地讨论“马桶时间”的利用，包括在卫生间放个小书柜。（估计很多同学心有戚戚焉吧:D）</description>
    </item>
    <item>
      <title>［经验总结］Ubuntu 9.10初用手记</title>
      <link>https://anwangtanmi.github.io/posts/c8597a6357455ef0a2b06f9ba22397e2/</link>
      <pubDate>Sun, 08 Nov 2009 21:13:00 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/c8597a6357455ef0a2b06f9ba22397e2/</guid>
      <description>• 界面更好看，边缘处理更圆滑，图标显示更清晰。&#xA;• 输入法花哨了，但还看不出ibus在输入方面比scim明显好在哪？ 可能是与其它系统配合得更好，反正用了一天也没有像SCIM 那样出现输不出字的现象。&#xA;• 号称的启动加速，我没感觉，反而觉得启动和关闭时渐明渐暗的Ubuntu图标有点后现代。&#xA;• Ubuntu One注册了还没用上，希望下一版本将这个功能交给google。&#xA;• 汉化之后不能连网 ，卸载network-manager，将wicd_1.6.1-3ubuntu1_all（依赖python-urwid_0.9.8.4-1_i386）安装了之后才能上网，这个问题用了半天才搞定！ 但桌面上网络提示，一直没看到。&#xA;• Tomboy、FireFox、OpenOffice等常用软件都升级了，功能略有增加。&#xA;• 在新立德中安装了nofree-flash之后，能在Firefox中正常播放flash，但flash页面的中文显示为乱码。&#xA;• fqterm中文字体更好看了。&#xA;• 应用程序菜单中加了个Ubuntu软件中心，卸载软件更方便了。&#xA;• 机器上原来安装的Ubuntu 8.10，从光盘全新安装Ubuntu 9.10时没有提示保留原有系统的/home文件夹和常用软件个性化配置，安装之前只得备份了一份home目录，虽然后来证明这个担心是多余的，但相对于以前版本的贴心提示，这一版的处理模式算是退步了。</description>
    </item>
    <item>
      <title>phpBB中文站</title>
      <link>https://anwangtanmi.github.io/posts/4cf3e4869dc1769fdef347613095784b/</link>
      <pubDate>Tue, 17 Jun 2008 16:56:00 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/4cf3e4869dc1769fdef347613095784b/</guid>
      <description> [phpBB中文站地址] http://www.phpbbchina.com/ [PHP – 官方网站] http://www.php.net/&#xA;[PHP – 关键词] php&#xA;pdt&#xA;[PHP – 相关论坛] http://php.board.newsmth.net/&#xA;http://bbs.pku.edu.cn/, homepage看版&#xA;http://forum.csdn.net/SList/PHP/&#xA;[PHP – 下载] AppServ 2.5.9, http://www.appservnetwork.com/&#xA;Zend Optimizer 3.3.0a, http://www.zend.com/products/zend_optimizer phpMyAdmin 2.11.2, http://www.phpmyadmin.net/home_page/index.php Zend Core 2.5.0, http://www.zend.com/products/zend_core Zend Platform 3.0.3, http://www.zend.com/products/zend_platform PHP 5.2.5, http://www.php.net/releases/5_2_5.php Zend Studio 5.5, http://www.zend.com/products/zend_studio Zend Guard 5.0, http://www.zend.com/products/zend_guard&#xA;PDT Project 1.0.1M1, http://www.eclipse.org/pdt/ [PHP – Manual手册] http://www.php.net/manual/&#xA;[PHP – XOOPS] http://xoops.org.cn/&#xA;[PHP – phpBB] http://www.phpbbchina.com/ </description>
    </item>
    <item>
      <title>从网页抓取数据的一般方法</title>
      <link>https://anwangtanmi.github.io/posts/7f459caeee5c87b5f1416a9f65a25a15/</link>
      <pubDate>Fri, 28 Dec 2007 01:08:00 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/7f459caeee5c87b5f1416a9f65a25a15/</guid>
      <description>首先要了解对方网页的运行机制 ，这可以用httpwacth或者httplook来看一下http发送和接收的数据。这两个工具应该说是比较简单易懂的。这里就不再介绍了。主要关注的内容是header和post的内容。一般会包括cookie，Referer页面和其他一些乱其八糟可能看不懂的变量，还有就是正常交互的参数，比如需要post或者get的querystring所包含的东西。 httplook和httpwacth 网上有很多下载的，这里推荐使用httpwach，因为可以直接嵌入到ie中，个人觉得这个比较好用。这两个工具可以到我上传在csdn的资源中下载，地址为&#xA;http://download.csdn.net/user/jinjazz 这里简单给出一段可以抓取数据的c#代码，比如登录某个网站，获取登录成功后的html代码，供数据分析使用。&#xA;private&#xA;void&#xA;login()&#xA;…&#xA;{&#xA;System.Net.WebClient wb = new System.Net.WebClient();&#xA;System.Collections.Specialized.NameValueCollection header = new System.Collections.Specialized.NameValueCollection();&#xA;header.Add( “ Cookie “ , “ czJ_cookietime=2592000; czJ_onlineusernum=1651; czJ_sid=w4bGJd “ );&#xA;header.Add( “ Referer “ , @” http://www.test_by_jinjazz.com.cn/bbs/login.php “ );&#xA;wb.Headers.Add(header);&#xA;System.Collections.Specialized.NameValueCollection data = new System.Collections.Specialized.NameValueCollection();&#xA;data.Add( “ formhash “ , “ ebd2faac “ );&#xA;data.Add( “ referer “ , “ http://www.test_by_jinjazz.com.cn/bbs/search.php “ );&#xA;data.Add( “ loginfield “ , “ username “ );</description>
    </item>
    <item>
      <title>一个简单方法实现bmp背景透明</title>
      <link>https://anwangtanmi.github.io/posts/ef009a21643449909464c47d6228ccb9/</link>
      <pubDate>Tue, 27 Nov 2007 17:32:00 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/ef009a21643449909464c47d6228ccb9/</guid>
      <description>看看是不是很简单？&#xA;void&#xA;MakeBackgroundTransparent(Bitmap img)&#xA;{&#xA;Color pixel =&#xA;img.GetPixel(&#xA;0&#xA;, img.Height –&#xA;1&#xA;);&#xA;img.MakeTransparent();&#xA;Color color =&#xA;Color.FromArgb(&#xA;0&#xA;, pixel);&#xA;img.SetPixel(&#xA;0&#xA;, img.Height –&#xA;1&#xA;, color);&#xA;} 如果你有更好的方法，请不吝赐教！</description>
    </item>
    <item>
      <title>1.26晴 伤</title>
      <link>https://anwangtanmi.github.io/posts/7073f495a6032399f9752faf9d69abb8/</link>
      <pubDate>Fri, 26 Jan 2007 09:42:00 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/7073f495a6032399f9752faf9d69abb8/</guid>
      <description>慢慢的&#xA;慢慢的&#xA;会不自禁的&#xA;用各种各样的方式&#xA;给自己织一层网&#xA;如蜘蛛吐丝般&#xA;用自己的血&#xA;慢慢的&#xA;慢慢的&#xA;凝固&#xA;封闭&#xA;不再有一丝的冲动&#xA;不再让自己伤&#xA;心中&#xA;总难免会泛起一阵阵的&#xA;胃酸&#xA;恶心，还是恶心&#xA;把记忆层封起来&#xA;把痛苦埋葬起来&#xA;让生命&#xA;不再承受之轻&#xA;鹰，会用翅膀拍击长空&#xA;鱼，会用双鳍遨游绿波&#xA;而我&#xA;则只会用自己&#xA;暗红的舌头&#xA;添噬心头的血&#xA;然后&#xA;用阴暗的眼神&#xA;瞥一眼过去&#xA;忘却该忘却的&#xA;生命仍将继续</description>
    </item>
  </channel>
</rss>
