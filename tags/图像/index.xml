<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>图像 on 暗网探秘</title>
    <link>https://anwangtanmi.github.io/tags/%E5%9B%BE%E5%83%8F/</link>
    <description>Recent content in 图像 on 暗网探秘</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 26 May 2017 14:47:43 +0800</lastBuildDate>
    <atom:link href="https://anwangtanmi.github.io/tags/%E5%9B%BE%E5%83%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>TensorFlow学习（十）：图像预处理</title>
      <link>https://anwangtanmi.github.io/posts/f8270ba74eed63ec85b3386afa1b056c/</link>
      <pubDate>Fri, 26 May 2017 14:47:43 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/f8270ba74eed63ec85b3386afa1b056c/</guid>
      <description>更新时间：&#xA;2018.6.2 增加了通过 tf.image 进行数据增强的内容，非常重要，可以直接跳到第四节。&#xA;之前做的一些任务都是从.csv文件里面读取数据来处理，这些元素都已经是处理好的值了，所以很方便。但是更多时候，我们是要从硬盘上的图片直接来做处理，所以，这里需要用到一些基本的图像处理有关的函数了。OpenCV肯定是可以使用的，但是tensorflow本身也提供了一些好用的函数。 因为通过Tensorflow完成图像有关的任务太多了，所以了解一点Tensorflow中自带的图像处理有关的函数是很有必要的。 Tensorflow中内置的图像处理的函数肯定没有OpenCV那么多那么强大啦，但是仅仅是作为简单的预处理的话，完全是够用了。&#xA;主要使用的模块就是tf.image，所以首先要是先把官方文档列出来：Module: tf.image，然后接下来就是按照图片处理的顺序来分别讲解各个函数的使用。 本节的完整测试代码，可以在我的GitHub：LearningTensorFlow/12.ImageProcess/上找到。&#xA;一.图像的编解码 Ⅰ.概览 下面是tensorflow自带编解码部分的函数，这里一起列出来，但是并不会全部都详细讲，因为使用方式大同小异，在例子中只是详细讲其中一个，其他的都可以类比或者看文档写出来，实在是很简单，就不需要多花笔墨。&#xA;decode_gif(…): Decode the first frame of a GIF-encoded image to a uint8 tensor. decode_jpeg(…): Decode a JPEG-encoded image to a uint8 tensor. decode_png(…): Decode a PNG-encoded image to a uint8 or uint16 tensor. decode_image(…): Convenience function for decode_gif, decode_jpeg, and decode_png. encode_jpeg(…): JPEG-encode an image. encode_png(…): PNG-encode an image.&#xA;在这一步，要是只是想把某个或者某些个文件读到ndarray中去，推荐更加高效的做法，就是使用matplot.image中的imread（）方法，或者opencv中的方法，都是很简单无脑的。 比如在这里，我文件夹下面有个叫做“1.jpg”的文件，那么就可以用比较简单的方法得到： 二.数据转化和形状变换 这一步的目的是什么呢？首先，很多图像像素默认是int类型的，在tensorflow里面，float类型的数据更加适合处理，然后形状来说，我们知道，对于图片来说，一个网络的输入尺寸是固定的，而训练的时候图片的尺寸确不一定是固定的，所以有必要用各种方式把图片尺寸转换为固定的适合网络输入的格式。&#xA;Ⅰ.数据类型转化 convert_image_dtype(image,dtype,saturate=False,name=None)</description>
    </item>
  </channel>
</rss>
