<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>application on 暗网探秘</title>
    <link>https://anwangtanmi.github.io/tags/application/</link>
    <description>Recent content in application on 暗网探秘</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 10 Oct 2012 20:51:11 +0800</lastBuildDate>
    <atom:link href="https://anwangtanmi.github.io/tags/application/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>iphone内存管理</title>
      <link>https://anwangtanmi.github.io/posts/d2b81237f0c77ff61f168b637b97d3f3/</link>
      <pubDate>Wed, 10 Oct 2012 20:51:11 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/d2b81237f0c77ff61f168b637b97d3f3/</guid>
      <description>http://hi.baidu.com/spopavenvldiqyr/item/c8d620b6282c4d4abb0e122a&#xA;iphone内存管理(一) BY 洋葱头&#xA;http://hi.baidu.com/yangcong121/home&#xA;内存管理在iphone中一直是一个热点话题。通过一段时间的总结我准备与大家分享一下我对内存管理的一点认识和经验.&#xA;开始之前先给大家分享一些重要的信息&#xA;1。Iphone 3g有128M的内存。但是至少有一半已经用来运行OS了。这意味着你的程序可能只有区区40M的空间让你使用。但是请记住:你可能会在你程序只使用了3M时就收到一个内存警告.&#xA;2。iphone并不使用类似C#的垃圾回收机制,&#xA;3。内存管理的基本原则：每一个 alloc,retain,copy你都需要自己去release&#xA;4。Objective-C runtime实例化一个对象只会在栈上而不会在堆上。&#xA;5。你可以使用autorelease对象，但是要注意的是这种对象如果不将它的内存池release它是不会释放掉的.它可能造成一个很大的内存泄露。但是你用leak又查不出来。&#xA;6。iphone没有交换文件系统,所以也就没有虚拟内存.&#xA;下面是一些建议&#xA;1.回应内存警告&#xA;2.尽量避免使用autorelease&#xA;3.使用延迟加载和再利用&#xA;4.如果图大且同一张图使用次数不多就避免使用imageNamed&#xA;5.table cell妥善使用再利用机制&#xA;6.使用Instruments&#xA;7.使用静态分析工具&#xA;8.使用NSZombieEnabled检测错误详情&#xA;以下我将对上面的建议意义详细讲述&#xA;(1)回应内存警告&#xA;千万不要忘了调用如下代码,这是最简单的形式。如果你有其他需要释放内存的地方你可以写在里面.&#xA;– (void)didReceiveMemoryWarning&#xA;{&#xA;[super didReceiveMemoryWarning];&#xA;}&#xA;而最好最后能通知到application delegate中。然后调用如下&#xA;– (void)applicationDidReceiveMemoryWarning:(UIApplication *)application&#xA;{&#xA;[[ImageCache sharedImageCache] removeAllImagesInMemory];&#xA;}&#xA;这样可以清除缓存的图片。得以缓解紧张的内存使用情况.&#xA;当然,你需要调用如下代码来申请这个通知&#xA;NSNotificationCenter *center = [NSNotificationCenter defaultCenter];&#xA;[center addObserver:self&#xA;selector:@selector(whatever:)&#xA;name:UIApplicationDidReceiveMemoryWarningNotification&#xA;object:nil];&#xA;=============================================================================&#xA;http://ihuby.info/2011/07/18/ios%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&#xA;iOS开发经验总结—内存管理 by ADMIN on JULY 18, 2011 · LEAVE A COMMENT iOS 开发中的一个重要部分就是关于内存的使用管理，用的不好就容易就产生内存泄露或内存错误访问，造成软件的崩溃，影响产品的使用和用户体验。在团队协调开发中也整理过了一些开发规范，正好看到国外的一篇开发博客文章“10-iphone-memory-management-tips”，其重要列表部分我翻译并整理一下。</description>
    </item>
    <item>
      <title>Flex Deep Link(深链接) BrowserManager</title>
      <link>https://anwangtanmi.github.io/posts/b40b11e82cefbbb58cdba4d3acb015f2/</link>
      <pubDate>Fri, 11 Sep 2009 11:41:00 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/b40b11e82cefbbb58cdba4d3acb015f2/</guid>
      <description>最近做游戏的时候，发现退出登陆时URL上会自动加上一个“#”字符，很奇怪，Google+Baidu无数次都没有找到答案。今天无意间看到几个群友在说通过“BrowserManager”获取URL，于是仔细查看了API，又发现了“HistoryManager”，这个问题终于明白了。&#xA;我们通常看的Web页面 可以通过浏览器的“前进”“后退”来查看刚才看过的页面，同样，嵌入的页面中的flash也可以实现这样的功能。方法是通过HistoryManageer类和BrowserManager类两种方法来实现。HistoryManageer类主要是用在Flex2，Flex3后很少用了。待会我将分别介绍这两种方法。&#xA;回到刚才说URL上自动加“#”号的问题：原因是Application 默认historyManagementEnabled属性是ture，也就是说HistoryManageer类功能自动开启了，Application 里面通过程序控制addChild或removeChild任何组件所导致的变化，将会记录在flash的history中，导致重写url，加上“#”字符。故有了这个奇怪的“#”号。在Flex3中，HistoryManager功能在Flex项目中默认打开的还有Accordion 和 TabNavigator组件。对于没有默认打开该功能的组件，如果要实现该功能，则需要另外注册。下面引用两片文章加以说明：&#xA;对于一个网站来说，其是有若干个网页组成的。而各个网页之间的链接叫做超链接。链接成为网页和网页之间的桥梁。那么，对于一个Flash整站来说，有没有一个办法来实现Flash各页面（更恰当的说是各功能模块）之间的链接呢。比如，我想在浏览器中输入一个链接便可以链到Flash整站中的一页—一个功能模块，而不是每次都要通过Flash整站的第一个页面的功能导航进入。把Flash的各个功能块页面化，那么我们该怎么实现呢。到底能不能实现呢？&#xA;答案是肯定的，通过Flex Deep Link 便能实现上述功能。&#xA;目录 [隐藏] 1 第一，Deep Link 简介。 2 第二，HistoryManager。 3 方法： 4 属性： 5 如何分析URl 6 获得链接信息 Flex Deep Link(深链接)-第一，Deep Link 简介。 Deep Link其实也是依赖Flash和浏览器的交互来实现的，通过获取链接地址中#后面的参数来实现页面标记，当你在Flex Bulid3发布一个项目时，其会自动你发布的目录生成一个名为History的文件夹，里面有History.js,HistoryFrame.html,history.css这三个文件，可见Deep Link也是通过和浏览器交互来实现的.如果浏览器不支持JavaScript或者禁用JavaScript，那么Deep LinK肯定是不能用的。&#xA;对于Deep Link应用，最重要的就是学会应用BrowserManager和HistoryManager这两个类。我们由简单到困难，先讲一讲HistoryManager这个类的应用。&#xA;Flex Deep Link(深链接)- 第二，HistoryManager。 HistoryManager功能在Flex项目中是默认打开的，比如在使用Accordion 和 TabNavigator组件时，在不同区域切换时，Flex会自动记录下各个状态，我们可以通过点击浏览器的“前进”和“后退”按钮来前进和倒退，在你切换这些组件的区域时，Flex会自动你在网页链接的后面加写参数，以便记录当前页面的状态。&#xA;默认情况下HistoryManager的功能是打开的，你可以通过设置各个组件或Application的historyManagementEnabled属性为false（默认为TRUE）来关闭此功能。&#xA;这些都没什么好讲的。关键是怎么在一些普通组建上使用HistoryManager功能，默认的navigator container组建都是支持该功能的。要使一些普通组建也支持此功能，必须：&#xA;1.实现mx.managers.IHistoryManagerClient接口。&#xA;2.用HistoryManager’的register()方法为组建注册。&#xA;3.当组件状态改变时保存组件的状态。&#xA;4.通过实施IHistoryManagerClient的saveState() 和 loadState()方法来保存和读取组件状态。&#xA;拿CheckBox为例：&#xA;xmlns:mx=”http://www.adobe.com/2006/mxml”&#xA;label=”Check me” implements=”mx.managers.IHistoryManagerClient” //关键步骤1，实现接口&#xA;creationComplete=”mx.managers.HistoryManager.register(this);”//关键步骤2，注册组件&#xA;change=”boxChanged(event)”//关键步骤3，当组件发生变化时保存状态&#xA;&amp;gt;&#xA;if (newState != selected) {</description>
    </item>
    <item>
      <title>神奇的Tor带你冲浪自由的百科全书Wiki</title>
      <link>https://anwangtanmi.github.io/posts/2c799617e27ac1c96529528664bae967/</link>
      <pubDate>Fri, 16 Jun 2006 13:49:00 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/2c799617e27ac1c96529528664bae967/</guid>
      <description> 很久的时候就听说过&#xA;Wiki（维基百科全书），也在很多的地方看到过Wiki的链接，每次好奇的点击过去，总是无法打开的失望，从此以后头脑中多了一份对于Wiki的牵挂，一份不舍，为什么我就上不去呢？&#xA;最后，我看到了一些关于Tor的介绍，标题起的就很吸引人—–跨越人造的鸿沟：Tor代理服务器。看了之后，大概的有了些印象，下面是wiki上摘录的一些：&#xA;Tor是第二代&#xA;onion routing（洋葱路由）的一种实现，用户通过Tor可以在因特网上进行&#xA;匿名交流。最初该项目由&#xA;美国海军研究实验室（US Naval Research Laboratory）赞助。&#xA;2004年晚些时候，Tor成为&#xA;电子前哨基金会（Electronic Frontier Foundation，&#xA;EFF）的一个项目。2005年后期，EFF不再赞助Tor项目，但他们继续维持Tor的官方网站。&#xA;匿名外连 Tor用户在本机运行一个洋葱代理服务器(onion proxy），这个代理周期性地与其他Tor交流，从而在Tor网络中构成虚拟环路（virtual circuit）。 Tor是在7层protocol stack中的application layer进行加密（也就是按照’onion’的模式）而它之所以被称为onion是因为它的结构就跟洋葱相同，你只能看出它的外表而想要看到核心就必须 把它层层的剥开。即每个router间的传输都经过symmetric key来加密，形成有层次的结构。它中间所经过的各节点，都好像洋葱的一层皮，把客户端包在里面，算是保护信息来源的一种方式，这样在洋葱路由器之间可以 保持通讯安全。同时对于客户端，洋葱代理服务器又作为SOCKS接口。一些应用程序就可以将Tor作为代理服务器，网络通讯就可以通过Tor的虚拟环路来进行。&#xA;进入Tor网络后，加密信息在路由器间传递，最后到达“退出节点”（exit node），明文数据从这个节点直接发往原来的目的地。对于目的主机而言，是从“退出节点”发来信息。&#xA;由于在TCP数据流的级别通讯，Tor显得卓然独立于其他匿名网络。通过使用Tor，一般的应用程序都可以实现匿名，比如IRC、即时通讯，以及浏览网页。浏览网页时，Tor常常与Privoxy联合使用，Privoxy是一个代理服务器，可以在应用层增加保护隐私。&#xA;有了Tor之后，我们就可以自由的上自己想上的网站了，这个要比一般的代理服务器好了很多。我们在&#xA;Tor的官方站点上可以下载，安装后将socket代理设置为localhost:9050，你就可以自由冲浪了。&#xA;Tor的页面中有祥细的&#xA;教程，那里的英文也不是很难，几个简单的步骤就搞定了。而且tor还专门针对firefox有一个torbutton的扩展，可以通过这个扩展来快速的切换是否使用tor。&#xA;不多说了，enjoy it~~~~~~~~~ </description>
    </item>
    <item>
      <title>一次WebStress测试</title>
      <link>https://anwangtanmi.github.io/posts/950ab3494ee4931382b84ed5f28cc040/</link>
      <pubDate>Mon, 07 Mar 2005 18:27:00 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/950ab3494ee4931382b84ed5f28cc040/</guid>
      <description>writer: demonalex&#xA;email: demonalex_at_dark2s.org 前言:看完了SQL的《用WEB压力测试工具模拟请求服务的DOS攻击》，尤觉得意尤未尽，为摸清此软件的&#xA;部分功能，特为此做了一段时间的实验(途中感谢很多网友为此‘捐’出自己的服务器)，写了以&#xA;下一篇烂文，希望能补充SQL大哥在该文中没有点明的知识点。&#xA;参考资料:《用WEB压力测试工具模拟请求服务的DOS攻击》、《WEB压力测试指南》&#xA;WEB压力测试(WebStress)一直以来都是很多IDC评测人员、网络管理员以及网络安全专家针对服务器&#xA;性能的重点考察和评价的对象。今天小神有幸为某位网友的虚拟主机做个WEB压力测试(建议:压力测试通&#xA;常安排在渗透测试之后)。&#xA;实验环境:&#xA;被测试(服务端):WIN2000 ADVANCE SERVER + IIS + 光纤带宽&#xA;测试者(客户端):WIN2000 PROFESSIONAL + MS WEB APPLICATION STRESS + 中国电信ADSL&#xA;实验目的:&#xA;测试与分析WEB服务器所提供的HTTP服务的综合稳定性。&#xA;测试计划:&#xA;测试类型基准(baseline):静态测试案例(HTM、JPG)[因为朋友只使用了简单的HTML]&#xA;测试工具:单客户端、测试案例库，客户端程序&#xA;分析手段:采用对比分析&#xA;测试对象:企业级全能虚拟主机&#xA;对比对象:“中资源”虚拟主机(dark2s.net)&#xA;测试方案条件数值指标:&#xA;*************************************************************************************&#xA;Url 线程 持续时间 是否使用随机延迟 虚拟扼杀带宽 其他数值&#xA;————————————————————————————&#xA;随机遍历地址 20 5分钟 200-400(毫秒) 56K MODEM(44k) default&#xA;*************************************************************************************&#xA;实验步骤:&#xA;使用Web Application Stress(下称WAS)生成两个新的压力测试脚本-&amp;gt;使用RECORD方式记录其URL-&amp;gt;配置&#xA;条件测试指标-&amp;gt;测试-&amp;gt;生成REPORT-&amp;gt;以报表方式对比分析其结果&#xA;具体操作:&#xA;在客户端(localhost)打开MS WEB APPLICATION STRESS主程序的菜单栏选择:”Scripts”-&amp;gt;”Create”-&amp;gt;”&#xA;Record”，选”Record Delay between request”，按”next”。&#xA;“finish”。&#xA;接下来在弹出的浏览器的地址栏中填入你所要测试的WEB服务器地址，随机浏览几个页面，模拟正常浏</description>
    </item>
  </channel>
</rss>
