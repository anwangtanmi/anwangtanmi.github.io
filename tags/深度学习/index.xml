<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>深度学习 on 暗网探秘</title>
    <link>https://anwangtanmi.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</link>
    <description>Recent content in 深度学习 on 暗网探秘</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 07 Feb 2020 22:00:56 +0800</lastBuildDate>
    <atom:link href="https://anwangtanmi.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>吴恩达Deeplearning.ai笔记（4）卷积网络</title>
      <link>https://anwangtanmi.github.io/posts/af3a672a2ff304ae9ffc98777d91f96a/</link>
      <pubDate>Fri, 07 Feb 2020 22:00:56 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/af3a672a2ff304ae9ffc98777d91f96a/</guid>
      <description> （1）边缘检测 左边的6*6矩阵就是输入的图像的像素，中间3*3的是过滤器，右边是输出。&#xA;计算就是如下图：&#xA;为什么这样可以检测出边缘？&#xA;下图左边的6*6矩阵可以看出表示的是中间有一条边界的图像。通过中间的过滤器后得到右边的输出，可以看到检测出了一个正边缘（白色的，表示从亮到暗），正边缘较粗是因为输入是很小的图像（6*6）&#xA;将输入矩阵左右翻转就是下图下半部分的样子，可以看到检测出了负边缘（黑色的，表示从暗到亮）&#xA;下面是常见的三种过滤器。也可以把过滤器的元素作为参数放到网络里去训练，由反向传播得到过滤器元素的值。&#xA;（2）padding 上述方法（valid卷积，即no padding），经过过滤器之后得到图片的大小是（n-f+1）*（n-f+1）&#xA;缺点：1.每过一次过滤器都会减小图像 2.边缘的像素使用次数比中间少，会丢失一些边缘上的信息。&#xA;（same卷积，即使用padding使得输出图像的大小和输入图像的大小一致）可以填充要被检测的图片边缘。填充的量记为p，填充后经过过滤器得到的图像大小是（n+2p-f+1）*（n+2p-f+1）=n*n&#xA;f一般都是奇数，保证填充的对称，并且过滤器有一个中心像素。&#xA;（3）步长 S表示步长，公式求出的输出矩阵的大小如果不是整数要向下取整。&#xA;（4）三维卷积 这里的输入可以是彩色的手写数字图像，而不是上面的灰度图像，所以有三个通道。输入和过滤器都是三维的。得到二维的输出。&#xA;如果想要同时使用多个过滤器呢？&#xA;使用Nc个过滤器就得到n*n*Nc大小的输出&#xA;（5）单层卷积网络示例： 在上面的基础上，每一个经过过滤器之后的输出要加上偏执单元，然后使用激活函数（这里是Relu），才得到下一层。&#xA;（6）总结： 下面这张图总结了卷积网络里面的一些数据关系，有助于加深理解上面的内容。&#xA;点赞 收藏 分享 文章举报 _Yangtze 发布了35 篇原创文章 ·&#xA;获赞 12 ·&#xA;访问量 1万+ 私信 关注 </description>
    </item>
    <item>
      <title>知识蒸馏学习笔记–Distilling the Knowledge in a Neural Network</title>
      <link>https://anwangtanmi.github.io/posts/32387403687fa5880a36a68c89a718f2/</link>
      <pubDate>Mon, 06 Jan 2020 16:18:00 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/32387403687fa5880a36a68c89a718f2/</guid>
      <description> Distilling the Knowledge in a Neural Network Distilling the Knowledge in a Neural Network”首次提出了知识蒸馏（暗知识提取）的概念，通过引入与教师网络（teacher network：复杂、但推理性能优越）相关的软目标（soft-target）作为total loss的一部分，以诱导学生网络（student network：精简、低复杂度）的训练，实现知识迁移（knowledge transfer）。&#xA;那什么是soft-target呢？与之对应的是hard-target,就是样本的真实标签，soft-target是teacher network的预测输出。&#xA;引进soft-target的原因是因为har-target的信息熵很低，soft target包含的信息量大，拥有不同类之间关系的信息（比如同时分类驴和马的时候，尽管某张图片是马，但是soft target就不会像hard target 那样只有马的index处的值为1，其余为0，而是在驴的部分也会有概率）。&#xA;这样做的好处就是表明这个图像除了像马更像驴一点，而不是车、人之类。&#xA;此外，当soft-target熵值较高时，相对hard-target，它每次训练可以提供更多的信息和更小的梯度方差，因此小模型可以用更少的数据和更高的学习率进行训练。&#xA;而这样的soft信息存在于概率中，以及label之间的高低相似性都存在于soft target中。但是如果soft targe是像这样的信息[0.98 0.01 0.01]，就意义不大了，所以需要在softmax中增加温度参数T（这个设置在最终训练完之后的推理中是不需要的）。&#xA;T就是调节参数，一般设为1。T越大，分类的概率分布越“软”&#xA;loss是两者的结合，Hindon认为，最好的训练目标函数为下图，并且第一个权重要大一点&#xA;算法框架示意图如下：&#xA;步骤如下：&#xA;使用hard-target训练大模型。 计算soft target：利用训练好的大模型来计算soft target。也就是大模型“软化后”再经过softmax的output。 训练小模型，小规模的神经网络用相同的T值来学习由大规模神经产生的软目标，接近这个软目标从而学习到数据的结构分布特征；在小模型的基础上再加一个额外的soft target的loss function，通过lambda来调节两个loss functions的比重。 预测时，将训练好的小模型按常规方式（右图）使用。 知识蒸馏，简单来说就是利用一个复杂度高的大模型进行训练，得到类别概率分布（soft-target），然后利用这个概率分布的损失和真实标签（hard-target）的概率分布损失做加权，形成小模型的total损失来指导小模型学习。&#xA;至于为何要引入这个soft-target，是因为大模型学习得到的soft-target包含了很多类之间的信息（我觉得就是学习了很正确的类别之间的信息得到的，所以可以反过来说它包含了很多类别之间的信息，包含类别之间的相似度等。）&#xA;这个soft-targe我感觉跟label-smooth有点像，只是label-smooth并没有用到把label-smooth后的标签和真实标签结合在一起指导模型学习。&#xA;soft-target，可以理解为是学习得到的，更加准确的类似label-smooth后的值。&#xA;而label-smooth是认为指定的，存在不准确因素。&#xA;点赞 收藏 分享 文章举报 梦坠凡尘 发布了67 篇原创文章 ·&#xA;获赞 17 ·&#xA;访问量 2万+ 私信 关注 </description>
    </item>
    <item>
      <title>【深度学习】神经网络入门（最通俗的理解神经网络）</title>
      <link>https://anwangtanmi.github.io/posts/2d08fe4df3a26003076c5d70ab8fd232/</link>
      <pubDate>Mon, 30 Dec 2019 19:28:44 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/2d08fe4df3a26003076c5d70ab8fd232/</guid>
      <description>先从回归(Regression)问题说起。我在本吧已经看到不少人提到如果想实现强AI，就必须让机器学会观察并总结规律的言论。具体地说，要让机器观察什么是圆的，什么是方的，区分各种颜色和形状，然后根据这些特征对某种事物进行分类或预测。其实这就是回归问题。&#xA;如何解决回归问题？我们用眼睛看到某样东西，可以一下子看出它的一些基本特征。可是计算机呢？它看到的只是一堆数字而已，因此要让机器从事物的特征中找到规律，其实是一个如何在数字中找规律的问题。&#xA;例：假如有一串数字，已知前六个是1、3、5、7，9，11，请问第七个是几？&#xA;你一眼能看出来，是13。对，这串数字之间有明显的数学规律，都是奇数，而且是按顺序排列的。&#xA;那么这个呢？前六个是0.14、0.57、1.29、2.29、3.57、5.14，请问第七个是几？&#xA;这个就不那么容易看出来了吧！我们把这几个数字在坐标轴上标识一下，可以看到如下图形：&#xA;用曲线连接这几个点，延着曲线的走势，可以推算出第七个数字——7。&#xA;由此可见，回归问题其实是个曲线拟合(Curve Fitting)问题。那么究竟该如何拟合？机器不可能像你一样，凭感觉随手画一下就拟合了，它必须要通过某种算法才行。&#xA;假设有一堆按一定规律分布的样本点，下面我以拟合直线为例，说说这种算法的原理。&#xA;如果你觉得这篇文章看起来稍微还有些吃力，或者想要系统地学习人工智能，那么推荐你去看床长人工智能教程。非常棒的大神之作，教程不仅通俗易懂，而且很风趣幽默。点击这里可以查看教程。&#xA;其实很简单，先随意画一条直线，然后不断旋转它。每转一下，就分别计算一下每个样本点和直线上对应点的距离(误差)，求出所有点的误差之和。这样不断旋转，当误差之和达到最小时，停止旋转。说得再复杂点，在旋转的过程中，还要不断平移这条直线，这样不断调整，直到误差最小时为止。这种方法就是著名的梯度下降法(Gradient Descent)。为什么是梯度下降呢？在旋转的过程中，当误差越来越小时，旋转或移动的量也跟着逐渐变小，当误差小于某个很小的数，例如0.0001时，我们就可以收工(收敛, Converge)了。啰嗦一句，如果随便转，转过头了再往回转，那就不是梯度下降法。&#xA;我们知道，直线的公式是y=kx+b，k代表斜率，b代表偏移值(y轴上的截距)。也就是说，k可以控制直线的旋转角度，b可以控制直线的移动。强调一下，梯度下降法的实质是不断的修改k、b这两个参数值，使最终的误差达到最小。&#xA;求误差时使用 累加(直线点-样本点)^2，这样比直接求差距 累加(直线点-样本点) 的效果要好。这种利用最小化误差的平方和来解决回归问题的方法叫最小二乘法(Least Square Method)。&#xA;问题到此使似乎就已经解决了，可是我们需要一种适应于各种曲线拟合的方法，所以还需要继续深入研究。&#xA;我们根据拟合直线不断旋转的角度(斜率)和拟合的误差画一条函数曲线，如图：&#xA;从图中可以看出，误差的函数曲线是个二次曲线，凸函数(下凸, Convex)，像个碗的形状，最小值位于碗的最下端。如果在曲线的最底端画一条切线，那么这条切线一定是水平的，在图中可以把横坐标轴看成是这条切线。如果能求出曲线上每个点的切线，就能得到切线位于水平状态时，即切线斜率等于0时的坐标值，这个坐标值就是我们要求的误差最小值和最终的拟合直线的最终斜率。&#xA;这样，梯度下降的问题集中到了切线的旋转上。切线旋转至水平时，切线斜率=0，误差降至最小值。&#xA;切线每次旋转的幅度叫做学习率(Learning Rate)，加大学习率会加快拟合速度，但是如果调得太大会导致切线旋转过度而无法收敛。 [学习率其实是个预先设置好的参数，不会每次变化，不过可以影响每次变化的幅度。]&#xA;注意：对于凹凸不平的误差函数曲线，梯度下降时有可能陷入局部最优解。下图的曲线中有两个坑，切线有可能在第一个坑的最底部趋于水平。&#xA;微分就是专门求曲线切线的工具，求出的切线斜率叫做导数(Derivative)，用dy/dx或f’(x)表示。扩展到多变量的应用，如果要同时求多个曲线的切线，那么其中某个切线的斜率就叫偏导数(Partial Derivative)，用∂y/∂x表示，∂读“偏(partial)”。由于实际应用中，我们一般都是对多变量进行处理，我在后面提到的导数也都是指偏导数。&#xA;以上是线性回归(Linear Regression)的基本内容，以此方法为基础，把直线公式改为曲线公式，还可以扩展出二次回归、三次回归、多项式回归等多种曲线回归。下图是Excel的回归分析功能。&#xA;在多数情况下，曲线回归会比直线回归更精确，但它也增加了拟合的复杂程度。&#xA;直线方程y=kx+b改为二次曲线方程y=ax^2+bx+c时，参数(Parameter)由2个(分别是k、b)变为3个(分别是a、b、c)，特征(Feature)由1个(x)变为2个(x^2和x)。三次曲线和复杂的多项式回归会增加更多的参数和特征。&#xA;前面讲的是总结一串数字的规律，现实生活中我们往往要根据多个特征(多串数字)来分析一件事情，每个原始特征我们都看作是一个维度(Dimension)。例如一个学生的学习成绩好坏要根据语文、数学、英语等多门课程的分数来综合判断，这里每门课程都是一个维度。当使用二次曲线和多变量(多维)拟合的情况下，特征的数量会剧增，特征数=维度^2/2 这个公式可以大概计算出特征增加的情况，例如一个100维的数据，二次多项式拟合后，特征会增加到100*100/2=5000个。&#xA;下面是一张50*50像素的灰度图片，如果用二次多项式拟合的话，它有多少个特征呢？——大约有3百万！&#xA;它的维度是50*50=2500，特征数=2500*2500/2=3,125,000。如果是彩色图片，维度会增加到原来的3倍，那么特征数将增加到接近3千万了！&#xA;这么小的一张图片，就有这么巨大的特征量，可以想像一下我们的数码相机拍下来的照片会有多大的特征量！而我们要做的是从十万乃至亿万张这样的图片中找规律，这可能吗？&#xA;很显然，前面的那些回归方法已经不够用了，我们急需找到一种数学模型，能够在此基础上不断减少特征，降低维度。&#xA;于是，“人工神经网络(ANN, Artificial Neural Network)”就在这样苛刻的条件下粉墨登场了，神经科学的研究成果为机器学习领域开辟了广阔的道路。&#xA;神经元&#xA;有一种假说：“智能来源于单一的算法(One Learning Algorithm)”。如果这一假说成立，那么利用单一的算法(神经网络)处理世界上千变万化的问题就成为可能。我们不必对万事万物进行编程，只需采用以不变应万变的策略即可。有越来越多的证据证明这种假说，例如人类大脑发育初期，每一部分的职责分工是不确定的，也就是说，人脑中负责处理声音的部分其实也可以处理视觉影像&#xA;下图是单个神经元(Neuron)，或者说一个脑细胞的生理结构：&#xA;下面是单个神经元的数学模型，可以看出它是生理结构的简化版，模仿的还挺像：&#xA;解释一下：+1代表偏移值(偏置项, Bias Units)；X1,X2,X2代表初始特征；w0,w1,w2,w3代表权重(Weight)，即参数，是特征的缩放倍数；特征经过缩放和偏移后全部累加起来，此后还要经过一次激活运算然后再输出。激活函数有很多种，后面将会详细说明。&#xA;举例说明：&#xA;X1*w1+X2*w2+…+Xn*wn这种计算方法称为加权求和(Weighted Sum)法，此方法在线性代数里极为常用。加权求和的标准数学符号是，不过为了简化，我在教程里使用女巫布莱尔的符号表示，&#xA;刚好是一个加号和一个乘号的组合。&#xA;这个数学模型有什么意义呢？下面我对照前面那个 y=kx+b 直线拟合的例子来说明一下。&#xA;这时我们把激活函数改为Purelin(45度直线)，Purelin就是y=x，代表保持原来的值不变。&#xA;这样输出值就成了 Y直线点 = b + X直线点*k，即y=kx+b。看到了吧，只是换了个马甲而已，还认的出来吗？下一步，对于每个点都进行这种运算，利用Y直线点和Y样本点计算误差，把误差累加起来，不断地更新b、k的值，由此不断地移动和旋转直线，直到误差变得很小时停住(收敛)。这个过程完全就是前面讲过的梯度下降的线性回归。</description>
    </item>
    <item>
      <title>「Deep Learning」Note on Machine Learning Yearning</title>
      <link>https://anwangtanmi.github.io/posts/17083bfff26963a56e5612c747e4d9f3/</link>
      <pubDate>Fri, 04 May 2018 17:42:43 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/17083bfff26963a56e5612c747e4d9f3/</guid>
      <description>Sina Weibo：小锋子Shawn Tencent E-mail：[email protected] http://blog.csdn.net/dgyuanshaofeng/article/details/80198393&#xA;1 Why Machine Learning Strategy 为什么采用机器学习策略？ 因为机器学习是很多重要应用的基石。比如，web搜索，email反垃圾，语音识别，商品推荐，等等。对于我来说，我关注机器学习算法在医学影像、医学信号和医学文本中的应用。&#xA;书中第一章假设我们创建并运营一个猫图识别公司，并处于努力提高猫检测器准确率的困境中。我们可能有如下想法：1、收集更多猫图；2、在收集过程中，关注训练集的多样性，比如各种姿势的猫、不同毛色的猫、利用不同sensor拍摄的猫；3、让算法迭代更多更充分；4、尝试更大的神经网络；5、尝试更小的神经网络；6、尝试加入正则项，比如L2惩罚；7、改变神经网络结构。此书的作用就是在开发应用中，告诉我们哪些可行的窍门，那些不可行的窍门，节省我们的时间。&#xA;2 How to use this book to help your team 如何使用这本书？&#xA;完成这本书的阅读，为机器学习项目设定工程方向，会有深入的理解。&#xA;3 Chapter 50 Choosing pipeline components: data availability 针对管道系统是否end-to-end，分析了数据获取的影响。 1、end-to-end系统的数据通常较少，需要设计采集装置进行数据收集； 2、但是，我们可以利用手上的数据开发非end-to-end系统。&#xA;Chapter 51 Choosing pipeline components: task simplicity 分析任务简单性，并建议我们分治困难问题。&#xA;Chapter 52 Directly learning rich outputs 简单地说，神经网络很强大，我们的欲望也更多，希望输出更多有用的信息。</description>
    </item>
    <item>
      <title>Deep learning Reading List</title>
      <link>https://anwangtanmi.github.io/posts/7457a43a7f0c3ab9e8f996aeb2f2ad0b/</link>
      <pubDate>Sat, 28 Jan 2017 16:44:27 +0800</pubDate>
      <guid>https://anwangtanmi.github.io/posts/7457a43a7f0c3ab9e8f996aeb2f2ad0b/</guid>
      <description>Deep learning Reading List Following is a growing list of some of the materials i found on the web for Deep Learning beginners.&#xA;Free Online Books Deep Learning by Yoshua Bengio, Ian Goodfellow and Aaron Courville Neural Networks and Deep Learning by Michael Nielsen Deep Learning by Microsoft Research Deep Learning Tutorial by LISA lab, University of Montreal Courses Machine Learning by Andrew Ng in Coursera Neural Networks for Machine Learning by Geoffrey Hinton in Coursera Neural networks class by Hugo Larochelle from Université de Sherbrooke Deep Learning Course by CILVR lab @ NYU CS231n: Convolutional Neural Networks for Visual Recognition On-Going CS224d: Deep Learning for Natural Language Processing Going to start Video and Lectures How To Create A Mind By Ray Kurzweil – Is a inspiring talk Deep Learning, Self-Taught Learning and Unsupervised Feature Learning By Andrew Ng Recent Developments in Deep Learning By Geoff Hinton The Unreasonable Effectiveness of Deep Learning by Yann LeCun Deep Learning of Representations by Yoshua bengio Principles of Hierarchical Temporal Memory by Jeff Hawkins Machine Learning Discussion Group – Deep Learning w/ Stanford AI Lab by Adam Coates Making Sense of the World with Deep Learning By Adam Coates Demystifying Unsupervised Feature Learning By Adam Coates Visual Perception with Deep Learning By Yann LeCun Papers ImageNet Classification with Deep Convolutional Neural Networks Using Very Deep Autoencoders for Content Based Image Retrieval Learning Deep Architectures for AI CMU’s list of papers Tutorials UFLDL Tutorial 1 UFLDL Tutorial 2 Deep Learning for NLP (without Magic) A Deep Learning Tutorial: From Perceptrons to Deep Networks WebSites deeplearning.</description>
    </item>
  </channel>
</rss>
